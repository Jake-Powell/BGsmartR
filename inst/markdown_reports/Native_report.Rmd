---
title: "Native taxa in the living collection"
output: html_document
---

###### {-} 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(plotly)
library(htmltools)
library(sf)
library(here)
library(flextable)
library(ggrepel)
library(downloadthis)

interactive_colour <- function(n){
  color = c('#f46d43', "#FDAE6B", '#848484', '#e6e6e6')
  if(n==2){
    return(color[c(1,4)])
  }
  color[1:n]
}
color_binary <- c('#f46d43', '#e6e6e6')
palette = 'Oranges'
```

```{css, echo = FALSE}
/* from https://ianlunn.github.io/Hover/ */
.hvr-sweep-to-left {
  display: inline-block;
  vertical-align: middle;
  -webkit-transform: perspective(1px) translateZ(0);
  transform: perspective(1px) translateZ(0);
  box-shadow: 0 0 1px rgba(0, 0, 0, 0);
  position: relative;
  -webkit-transition-property: color;
  transition-property: color;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
}
.hvr-sweep-to-left:before {
  content: "";
  position: absolute;
  z-index: -1;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #f46d43;
  -webkit-transform: scaleX(0);
  transform: scaleX(0);
  -webkit-transform-origin: 100% 50%;
  transform-origin: 100% 50%;
  -webkit-transition-property: transform;
  transition-property: transform;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
  -webkit-transition-timing-function: ease-out;
  transition-timing-function: ease-out;
}
.hvr-sweep-to-left:hover, .hvr-sweep-to-left:focus, .hvr-sweep-to-left:active {
  color: white;
}
.hvr-sweep-to-left:hover:before, .hvr-sweep-to-left:focus:before, .hvr-sweep-to-left:active:before {
  -webkit-transform: scaleX(1);
  transform: scaleX(1);
}

.blackbox {
  padding: 1em;
  background: #FDAE6B;
  border: 2px solid #e6e6e6;
  border-radius: 10px;
}
.center {
  text-align: center;
}
```

```{r, imported parameters}
# 
# collection = 'CUBG'
# load('/Users/jakepowell/Cambridge/Enriched_reports_Jake/CUBG_June2023_enriched_report.rda')
# coordinates = c(52.19378853629289,0.1277234065606053)
# load('/Users/jakepowell/Cambridge/WCVP/Version 11/wcvp_with_redlistcategory.rda')
# load('/Users/jakepowell/Cambridge/Geography Module/wgsrpd3.rda')
# 
# native = 'Naturally occurring only'
# extinct = TRUE
# doubtful_locations = FALSE
# min_year = 1970
# export_data = F
# table_font_size = 14
# report_kind = 'static'
# ggtheme = NULL
# separate_figure_folder = FALSE
# value_on_fig = TRUE
# report_kind = 'interactive'
# old_accession_year_codes = 1000
# earliest_allowable_record = 1650
# bru_codes = c("IRE", "GRB")
# native = 'Naturally occurring only'
# extinct = TRUE
# doubtful_locations = FALSE
```

```{r, add logo, eval = report_kind == 'interactive'}
htmltools::img(src = knitr::image_uri(paste0(system.file(package = "BGSmartR"), "/logo.png")), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; width:87.8px; height:100px')
```

```{r theme_ggplot2, echo = FALSE}
library(ggplot2)

# Changing the default theme
if(is.null(ggtheme)){
   ggtheme <- function(base_size = 16) {
      ggplot2::theme_bw(base_size = base_size) %+replace%
        ggplot2::theme(
          plot.title = ggplot2::element_text(size = rel(1), face = "bold", margin = margin(0,0,5,0), hjust = 0),
          panel.grid.minor = ggplot2::element_blank(),
          panel.border = ggplot2::element_blank(),
          axis.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
          axis.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
          axis.line = ggplot2::element_line(color = "black"),
          legend.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
          legend.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
          legend.key = ggplot2::element_rect(fill = "transparent", colour = NA),
          legend.key.size = ggplot2::unit(1.5, "lines"),
          legend.background = ggplot2::element_rect(fill = "transparent", colour = NA),
          strip.background = ggplot2::element_rect(fill = "#17252D", color = "#17252D"),
          strip.text = ggplot2::element_text(size = rel(0.85), face = "bold", color = "white", margin = margin(5,0,5,0))
        )
    }
}
theme_set(ggtheme())
update_geom_defaults("line", list(size = 2))

# Set the colour scale for the plots
scale_colour_continuous <- scale_colour_continuous
scale_colour_discrete   <- scale_colour_discrete
scale_colour_binned     <- scale_colour_binned
scale_fill_continuous <- scale_fill_continuous
scale_fill_discrete <- scale_fill_discrete
scale_fill_binned <- scale_fill_binned
```

```{r, functions for turnover}
turnover_items <- function(report){
  report = report[(report$LossYear >= min_year & report$LossYear <= max_year) | is.na(report$LossYear),]
  combined = data.frame(Year = years)
  
  # Items
  gain = data.frame(table(report$AccYear))
  if(nrow(gain) == 0){
    gained = rep(0,nrow(combined))
    combined$gain_items = gained
  }else{
    names(gain) = c('Year', 'Items')
    gain$Year = as.numeric(as.character(gain$Year))
    gain = gain[gain$Year >=min_year & gain$Year <= max_year,]
    gained = rep(0,nrow(combined))
    gained[match(gain$Year, combined$Year)] = gain$Items
    combined$gain_items = gained
  }
  
  
  loss = data.frame(table(report$LossYear))
  if(nrow(loss) == 0){
    lost = rep(0,nrow(combined))
    combined$loss_items = lost
  }else{
    names(loss) = c('Year', 'Items')
    loss$Year = as.numeric(as.character(loss$Year))
    loss = loss[loss$Year >=min_year & loss$Year <= max_year,]
    lost = rep(0,nrow(combined))
    lost[match(loss$Year, combined$Year)] = loss$Items
    combined$loss_items = lost
  }
  
  
  combined$net_items = combined$gain_items - combined$loss_items
  return(combined)
}

plots_turnover <- function(turnover, trend, report_kind, text = '', separate_figure_folder, data_type = 'items'){
    dataA = data.frame(turnover[,c(1,3)], rep('Lost', nrow(turnover)))
    names(dataA) = LETTERS[1:3]
    dataB = data.frame(turnover[,c(1,2)], rep('Gain', nrow(turnover)))
    names(dataB) = LETTERS[1:3]
    items_data = rbind(dataA, dataB)
  if(report_kind == 'static'){

    p = ggplot(data=items_data, aes(x=A, y=B, group=C)) +
      geom_line(aes(color=C)) +
      # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
      labs(title=paste0("Turnover of ",text," in the LC (By ",data_type,")"),
           x ="Year",
           y = paste0('Number of ',data_type,'')) +
      guides(color=guide_legend(title=paste0('Gain/Loss'))) +
      # theme(text = element_text(size=table_font_size)) +
      scale_color_manual(values=c("blue", "red"))+
      theme(legend.direction = "horizontal", legend.position = "top", legend.justification = "right")
    
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','turnover_',stringr::str_replace_all(text, ' ', '_'),'_gain_loss_',data_type,'.pdf'),device = 'pdf', scale = 1, width = 20, height = 12, limitsize = FALSE)
    }
    p1=p
    
    # Color based on value
    color <- ifelse(turnover$net_items < 0, "pink", "lightblue")
    p = ggplot(turnover, aes(x = Year, y = net_items)) +
      geom_bar(stat = "identity",
               show.legend = FALSE,
               fill = color,      # Background color
               color = "white") + # Border color
      # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
      labs(title=paste0("Net turnover of ",text," in the LC (By ",data_type,")"),
           x ="Year",
           y = paste0('Number of ',data_type,''))
    # theme(text = element_text(size=table_font_size))
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Net_turnover_',stringr::str_replace_all(text, ' ', '_'),'_',data_type,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
    p2=p
    
    
    # Trend plot.
    trend_data = data.frame(year = turnover$Year, trend = trend)
    p = ggplot(trend_data, aes(x = year, y = trend)) +
      geom_line(width = 1.1) +
      labs(title="",
           x ="Year",
           y = paste0('Number of ',data_type,''))
    p3 = p
    return(list(gain_loss = p1, net = p2, trend = p3))
  }
  if(report_kind == 'interactive'){
    # gain_loss plot
    colors = color_binary |> rev()
    fig <- plot_ly(items_data, x = ~A, y = ~B, color = ~C, colors = colors, type = 'scatter', mode = 'lines+markers')
    fig <- fig |> layout(yaxis = list(title = paste0("Number of ",data_type |> tolower(),"")),
                         xaxis = list(title = "Year"))
    fig <- fig |> layout(hovermode = 'x unified')
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','line-turnover_',stringr::str_replace_all(text, ' ', '_'),'_gain_loss_',data_type,'.html'))
    }
    fig1 = fig
    
    # net plot
    colors = color_binary |> rev()
    color <- ifelse(turnover$net_items < 0, colors[1], colors[2])
    texto = paste0('Net: ', turnover$net_items, '<br>',
                   'Gain: ', turnover$gain_items, '<br>',
                   'Loss: ', turnover$loss_items, '<br>'
    )
    fig = plot_ly(turnover, x = ~Year, y = ~net_items, type = 'bar', hoverinfo = "x+text",  hovertext = texto, color = color, colors = rev(colors), showlegend = FALSE)
    fig <- fig |> layout(yaxis = list(title = paste0("Net number of ",data_type |> tolower(),"")),
                         xaxis = list(title = "Year"))
    fig <- fig |> layout(hovermode = 'x unified')
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Bar-Net_',stringr::str_replace_all(text, ' ', '_'),'turnover_of_',data_type,'.html'))
    }
    fig2 = fig
    
    # Trend plot.
    trend_data = data.frame(year = turnover$Year, trend = trend)
    fig = plot_ly(trend_data, x = ~year, y = ~trend, type = 'scatter', mode = 'line', hoverinfo = "x+text", hovertext = trend)
    fig <- fig |> layout(yaxis = list(title = paste0("Number of ",data_type |> tolower(),"")),
                         xaxis = list(title = "Year"))
    fig <- fig |> layout(hovermode = 'x unified')
    fig3= fig
    
    # Combined trend and net.
    fig <- plot_ly()
    # Add traces
    ay <- list(
      tickfont = list(color = "black"),
      overlaying = "y",
      side = "right",
      title = paste0("Total ", tolower(data_type)))
    
      fig <- fig %>% add_trace(x = years, y = turnover$net_items, name = "Net", type = 'bar', hoverinfo = "x+text",  hovertext = texto, color = color, colors = rev(colors), showlegend = FALSE)
     
    fig <- fig %>% add_trace(x = years, y = trend, name = "Total", mode = "lines+markers", type = "scatter", line = list(color = 'black'), marker = list(color = 'black'),yaxis = "y2")
    
  
    # Set figure title, x and y-axes titles
    fig <- fig |> layout(
      title = "", yaxis2 = ay,
      xaxis = list(title="Year"),
      yaxis = list(title = paste0("Net turnover of ", tolower(data_type)))
    ) |>
      layout(plot_bgcolor='white',
             xaxis = list(
               zerolinecolor = '#ffff',
               zerolinewidth = 2,
               gridcolor = 'ffff'),
             yaxis2 = list(
               zeroline = TRUE,
               zerolinecolor = 'ffff',
               zerolinewidth = 2,
               gridcolor = 'ffff',
               showgrid = FALSE),
              yaxis = list(
                zeroline = TRUE,
                zerolinecolor = '#f0f0f0',
                zerolinewidth = 1,
                gridcolor = '#f0f0f0',
                griddash = 'solid',
                gridwidth = 1,showgrid = T),
             margin = list(t = 10, l = 20, r = 70, b = 20, pad = 4),
             autosize = T
      )
    fig <- fig |> layout(hovermode = 'x unified')
    fig4 = fig
    
    return(list(gain_loss = fig1, net = fig2, trend = fig3, trend_and_net = fig4))
    
  }
}

proportional_plots_turnover <- function(turnover,
                                        overall_turnover,
                                        collection_proportion,
                                        separate_figure_folder, 
                                        report_kind,
                                        text = '',
                                        data_type = 'items',
                                        quantity = ''){
  if(report_kind == 'static'){
    # Gain
    plot_data = data.frame(year = turnover[,1],
                           specific = turnover[,2], 
                           all = overall_turnover[,2])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_gain = plot_data
    p = ggplot(plot_data, aes(y=prop_specific, x=year)) + 
      geom_bar(stat="identity", width = 1, fill = 'lightblue', col = 'black') +
      geom_point(aes(x = year, y = prop_specific_collection))+
      labs(title=paste0("Proportion of gained ",data_type," that are ",text," in the LC"),
           x ="Year",
           y = "Percentage (%)") +
      # theme(text = element_text(size=table_font_size)) +
      labs(caption = paste0("Black points are proportion of ",data_type," in the LC that are ",text," each year."))
    p1 = p
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/',stringr::str_replace_all(text,' ','_'),'_gain_',data_type,'_proportion.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
    
    ### Plot of proportion of lost items being native.
    
    plot_data = data.frame(year =  turnover[,1],
                           specific = turnover[,3], 
                           all = overall_turnover[,3])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_loss = plot_data
    
    p = ggplot(plot_data, aes(y=prop_specific, x=year)) + 
      geom_bar(stat="identity", width = 1, fill = 'pink', col = 'black') +
      geom_point(aes(x = year, y = prop_specific_collection))+
      # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
      labs(title=paste0("Proportion of lost ",data_type," that are ",text," in the LC"),
           x ="Year",
           y = "Percentage (%)") +
      # theme(text = element_text(size=table_font_size)) +
      labs(caption = paste0("Black points are proportion of ",data_type," in the LC that are ",text," each year."))
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/',stringr::str_replace_all(text,' ','_'),'_loss_',data_type,'_proportion.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
    
    return(list(gain = p1, loss = p, data_gain = plot_data_gain, data_loss = plot_data_loss))
  }
  if(report_kind =='interactive'){
    # Gain
    plot_data = data.frame(year = turnover[,1],
                           specific = turnover[,2], 
                           all = overall_turnover[,2])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_gain = plot_data
    fig = plot_ly(plot_data, x = ~year, y = ~prop_specific, type = 'bar',
                  name = paste0('New accessions'),
                  marker = list(color = color_binary[2]),
                  hovertemplate = paste("%{y:.2f}% of new accessions <extra></extra>")
                  )
                  
    fig <- fig |> layout(yaxis = list(title = paste0("Percentage")),
                         xaxis = list(title = "Year"))
    fig <- fig |> add_trace(x = ~year, y = ~prop_specific_collection, type = 'scatter', mode = 'lines+markers',
                            name = paste0('Collection'),
                            marker = list(color = 'black'),
                            line = list(color = 'black'),
                             hovertemplate = paste("%{y:.2f}% of the collection <extra></extra>")
                            )
    fig <- fig |> layout(hovermode = 'x unified',
                         yaxis = list(ticksuffix = '%'),
                         xaxis = list(hoverformat = paste0('fvf')),
                         legend=list(title=list(text=paste0('<b>',text |> stringr::str_to_sentence(), '</b>'))))
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Line_Bar-Proportion_of_gained_',stringr::str_replace_all(text, ' ', '_'),'_',data_type,'.html'))
    }
    
    fig1 = fig
    
    ### Plot of proportion of lost items being native.
    
    plot_data = data.frame(year =  turnover[,1],
                           specific = turnover[,3], 
                           all = overall_turnover[,3])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_loss = plot_data
    
    fig = plot_ly(plot_data, x = ~year,
                  y = ~prop_specific,
                  type = 'bar',
                  name = paste0('Lost accessions'),
                  marker = list(color = color_binary[1]),
                  hovertemplate = paste("%{y:.2f}% of lost accessions <extra></extra>"))
    fig <- fig |> layout(yaxis = list(title = paste0("Percentage")),
                         xaxis = list(title = "Year"))
    fig <- fig |> add_trace(x = ~year,
                            y = ~prop_specific_collection,
                            type = 'scatter',
                            mode = 'lines+markers',
                            name = paste0('Collection'),
                            marker = list(color = 'black'),
                            line = list(color = 'black'),
                            hovertemplate = paste("%{y:.2f}% of the collection<extra></extra>"))
    fig <- fig |> layout(hovermode = 'x unified',
                         yaxis = list(ticksuffix = '%'),
                         legend=list(title=list(text=paste0('<b>',text |> stringr::str_to_sentence(), '</b>'))))
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Line_Bar-Proportion_of_lost_',stringr::str_replace_all(text, ' ', '_'),'_',data_type,'.html'))
    }
    
    return(list(gain = fig1, loss = fig,  data_gain = plot_data_gain, data_loss = plot_data_loss))
    
  }
}
```

```{r, Add combined geography column to enriched report}
geography_data = enriched_report[,grepl('_area_code_l3', names(enriched_report))]
want = c('000','010','001','011','100','110','101')

#Depending on the values of the options reduce `want` to only the satisfactory values.
##A) introduced / naturally occurring only.
if(native == 'Introduced only'){
 want = want[grepl('^1',want)]
}else if(native == 'Naturally occurring only'){
 want = want[grepl('^0',want)]
}
## B) Extinct
if(!extinct){
 want = want[!grepl('010|011|110',want)]
}
## C) Doubtful
if(!doubtful_locations){
 want = want[!grepl('001|011|101',want)]
}
# Get the columns in wanted info that contain the geography information we want.
geography_data = geography_data[,grepl(paste0(want,collapse='|'), names(geography_data))]

if(length(want) > 1){
 level3codes =do.call("paste", c(geography_data, sep = ", "))
 level3codes = stringr::str_remove(level3codes, ', NA$')
 level3codes = stringr::str_remove(level3codes, 'NA, ')
}else{
 level3codes = geography_data
}
level3codes[level3codes == "NA"] = NA

enriched_report$geography_codes = level3codes
```

```{r, Get location_type_text}
location_type_text = ''
if(native == 'Naturally occurring only'){
 location_type_text = paste0(location_type_text, 'naturally occurring only,', collapse = ' ')  
}else if(native == 'Introduced only'){
  location_type_text = paste0(location_type_text, 'introduced only,', collapse = ' ')  
 
}else{
  location_type_text = paste0(location_type_text, 'Either naturally occurring or introduced,', collapse = ' ')  
}
if(extinct){
   location_type_text = paste0(location_type_text, ' allowing extinct regions and', collapse = ' ')  
}else{
  location_type_text = paste0(location_type_text, ' not including extinct regions and', collapse = ' ')  
}
if(doubtful_locations){
   location_type_text = paste0(location_type_text, ' allowing doubtful regions.', collapse = ' ')  
 
}else{
  location_type_text = paste0(location_type_text, ' not allowing doubtful regions.', collapse = ' ')  
}
```

`r if(any(! c('AccNoFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"*** \n **Warning!**\n\n This enriched report contains missing 'original' columns needed to perform the analyses in this report. Default values have been created. In particular, the following were missing "}`

`r if(!'AccNoFull' %in% names(enriched_report)){"- AccNoFull: assume each item is its own accession.\n"}`
`r if(!'AccYear' %in% names(enriched_report)){"- AccYear: Cannot do analyses over time.\n"}`
`r if(!'ItemStatusDate' %in% names(enriched_report)){"- AccNoFull: Cannot do analyses over time.\n"}`
`r if(!'ItemStatusType' %in% names(enriched_report)){"- AccNoFull: Cannot do analyses over time.\n"}`

`r if(any(! c('AccNoFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"***"}`

```{r, Find LC location, echo = FALSE}
coord_contained = TRUE
# Extract the location of the collection.
pnts <- data.frame( x = coordinates[2], y = coordinates[1])

# create a points collection
pnts_sf <- do.call("st_sfc",c(lapply(1:nrow(pnts), 
                                     function(i) {sf::st_point(as.numeric(pnts[i, ]))}), list("crs" = 4326))) 

pnts_trans <- st_transform(pnts_sf, 2163) # apply transformation to pnts sf
tt1_trans <- st_transform(wgsrpd3, 2163)      # apply transformation to polygons sf

intersect = as.vector(st_intersects(tt1_trans, pnts_trans, sparse = FALSE))
collection_geog_details = wgsrpd3[which(intersect),-5]
location_name = collection_geog_details$LEVEL3_NAM
location_code = collection_geog_details$LEVEL3_COD

if(length(location_name) == 0){
  coord_contained = FALSE
  # Try and find the nearest polygon.
  collection_geog_details  =  wgsrpd3[which.min(as.vector(sf::st_distance(tt1_trans, pnts_trans))),-5]
  location_name = collection_geog_details$LEVEL3_NAM
  location_code = collection_geog_details$LEVEL3_COD
}



# If we are given bru_codes set the location codes to these. 
coord_location = location_code
coord_name = location_name

if(!is.na(bru_codes[1])){
  location_code = bru_codes
  location_name = wgsrpd3$LEVEL3_NAM[match(bru_codes, wgsrpd3$LEVEL3_COD)]
  collection_geog_details = wgsrpd3[match(bru_codes, wgsrpd3$LEVEL3_COD),-5]
}

```


```{r, Extracting information from enriched report, echo = F}
# Add required columns if missing.
do_over_time = TRUE
needed_columns = c('AccNoFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType')
if(!'AccNoFull' %in% names(enriched_report)){
  enriched_report$AccNoFull = 1:nrow(enriched_report)
}
if(!'AccYear' %in% names(enriched_report)){
  do_over_time = FALSE
  enriched_report$AccYear = rep(0, nrow(enriched_report))
}
if(!'ItemStatusDate' %in% names(enriched_report)){
  do_over_time = FALSE
  enriched_report$ItemStatusDate = rep(NA, nrow(enriched_report))
}
if(!'ItemStatusType' %in% names(enriched_report)){
  do_over_time = FALSE
  enriched_report$ItemStatusType = rep('Existing', nrow(enriched_report))
}
if(all(is.na(enriched_report$ItemStatusDate))){
  do_over_time = FALSE
}
if(all(is.na(enriched_report$ItemStatusType))){
  do_over_time = FALSE
}
if(all(is.na(enriched_report$AccYear))){
  do_over_time = FALSE
}
#Extract endemic information from enriched_report
endemic = rep('Not Endemic', nrow(enriched_report))
endemic_index = which(stringr::str_length(enriched_report$geography_codes) == 3)
endemic[endemic_index] = 'Endemic'
enriched_report$endemic = endemic
rm(endemic)

# Extract threatened. 
threat_cat = c('VU','EN','CR','EW','EX')
threatened = rep('Not Threatened', nrow(enriched_report))
threatened[which(enriched_report$redList_category %in% threat_cat)] = 'Threatened'
threatened[which(enriched_report$POWO_Red_category %in% threat_cat)] = 'Threatened'
enriched_report$threatened = threatened
rm(threatened)

# Extract threatened category. 
threatened_category = rep(NA, nrow(enriched_report))
for(i in 1:length(threat_cat)){
 threatened_category[which(enriched_report$redList_category == threat_cat[i])] = threat_cat[i]
 threatened_category[which(enriched_report$POWO_Red_category == threat_cat[i])] = threat_cat[i]
}
enriched_report$threatened_category = threatened_category
rm(threatened_category)

# Extract native.
nativeo = rep('Not Native', nrow(enriched_report))
native_index = grepl(location_code,enriched_report$geography_codes)
nativeo[native_index] = 'Native'
enriched_report$native = nativeo
rm(nativeo)

# Convert Provenance code to text.
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'G'] = 'Garden'
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'U'] = 'Unknown'
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'W'] = 'Wild'
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'Z'] = 'Wild-derived'

# Create a sanitised taxonomic name.
enriched_report$good_name = paste0(enriched_report$sanitised_taxon, ' ', enriched_report$extracted_author)
best_name = paste0(enriched_report$POWO_taxon_name, ' ', enriched_report$POWO_taxon_authors)
best_name[which(best_name == 'NA NA')] = enriched_report$good_name[which(best_name == 'NA NA')]
enriched_report$good_name = paste0(enriched_report$sanitised_taxon, ' ', enriched_report$extracted_author)
enriched_report$best_name = best_name

# Add the year items are lost (if they are no longer existing)
LossYear = rep(NA,nrow(enriched_report))
ItemStatusYear = as.numeric(stringr::str_extract(enriched_report$ItemStatusDate,pattern = '[0-9]{4}'))
LossYear[enriched_report$ItemStatusType == 'NotExisting'] = ItemStatusYear[enriched_report$ItemStatusType == 'NotExisting']
enriched_report$LossYear = LossYear

enriched_report$AccYearOrig  =enriched_report$AccYear

# Set old unknown records to have a date ( = earliest_allowable_record) and remove all records prior to this time.
if(!is.null(old_accession_year_codes)){
  has_old_accessions_code = which(enriched_report$AccYear %in% old_accession_year_codes)
  no_old_accessions = length(has_old_accessions_code)
  enriched_report$AccYear[has_old_accessions_code] = earliest_allowable_record
}
max_year = as.numeric(format(Sys.Date(),'%Y'))
to_keep = which(as.numeric(enriched_report$AccYear) >= earliest_allowable_record  & as.numeric(enriched_report$AccYear) <= max_year)
still_issue = nrow(enriched_report) - length(to_keep)
# report = report[to_keep,]

report_original = enriched_report


if(separate_figure_folder){
  figures_dir = paste0(output_dir,'/',collection,'_Figures')
  dir.create(figures_dir,showWarnings = FALSE)
}

exporting_data_store = list()
```

###### {-} 

This report explores the native taxa existing in **`r collection`**, and how the representation of native species has varied over time.

<!--  To determine the geographic distribution of items in the living collection we enrich with information from [Plants of the World Online](https://powo.science.kew.org), by matching taxonomic names. POWO uses [TDWG geographical codes](https://www.tdwg.org/standards/wgsrpd/) (Brummitt, 2001) expressed to that system's third level. This splits the world into 369 regions. Thus, each accepted name in POWO is associated with a list of geographic regions. POWO splits the geographic regions associated with a taxa by three conditions: -->

<!-- - Native / introduced, -->
<!-- - Extinct / Not extinct, -->
<!-- - Location is doubtful / otherwise. -->

<!-- This document considers locations that are: `r location_type_text`  -->
 
 `r if(coord_contained){paste0("**",collection,"**", ' is located in the botanical country "', coord_name, '" highlighted in green in the map below, where the black dot shows the location of the living collection. Species in the collection naturally occurring in that green area are considered as native, otherwise as non-native. ')}`

 `r if(!coord_contained){paste0("**",collection, "**", ' is closest to the botanical country "', coord_name, '" highlighted in green in the map below, where the black dot shows the location of the living collection. Species in the collection naturally occurring in that green area are considered as native, otherwise as non-native. ')}` 
 
<!-- `r if(is.na(bru_codes[1])){paste0("Therefore, any taxa whose geographic distribution includes ", location_name, " is classed as native to the living collection. Otherwise, taxa are classed as non-native.")}` -->

<!-- `r if(is.na(bru_codes[1])){paste0("The location of the living collection and the native region are shown below.")}` -->

`r if(!is.na(bru_codes[1])){paste0("In this document we consider plants that are native to ", paste0(location_name, collapse = ', '), " (i.e the plants whose geographic distribution overlaps with those regions), all other plants are classed as non-native.")}`

`r if(!is.na(bru_codes[1])){paste0("The native region, and living collection location (if within the native region) are shown below.")}`


```{r, LC location and native region plot, fig.fullwidth=TRUE, fig.dim = c(10, 4), results='hide',fig.keep='all', message=FALSE}
collection_geog_details$occurrence_type = 'native'
lims <- st_bbox(collection_geog_details)
p <- rWCVP::wcvp_distribution_map(collection_geog_details, crop_map=T) + 
  theme(legend.position="none") +
  geom_sf(data=pnts_sf, fill="black",col="black", shape=20, size = 5) +
  coord_sf(xlim=lims[c(1,3)], ylim=lims[c(2,4)]) +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        plot.title = element_text(hjust = 0.5))

if(separate_figure_folder){
ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Map_LC_location_and_native region.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}

p
```

***
### Native collection size

```{r, How many native species are in the LC - data}
# Find all the native taxa to the location of the LC in WCVP
geography_data = wcvp$geography[,grepl('_area_code_l3', names(wcvp$geography))]
want = c('000','010','001','011','100','110','101')
#Depending on the values of the options reduce `want` to only the satisfactory values.
##A) introduced / naturally occurring only.
if(native == 'Introduced only'){
 want = want[grepl('^1',want)]
}else if(native == 'Naturally occurring only'){
 want = want[grepl('^0',want)]
}
## B) Extinct
if(!extinct){
 want = want[!grepl('010|011|110',want)]
}
## C) Doubtful
if(!doubtful_locations){
 want = want[!grepl('001|011|101',want)]
}
# Get the columns in wanted info that contain the geography information we want.
geography_data = geography_data[,grepl(paste0(want,collapse='|'), names(geography_data))]

if(length(want) > 1){
 level3codes =do.call("paste", c(geography_data, sep = ", "))
 level3codes = stringr::str_remove(level3codes, ', NA$')
 level3codes = stringr::str_remove(level3codes, 'NA, ')
}else{
 level3codes = geography_data
}
level3codes_wcvp = level3codes

native_index = grepl(paste0(location_code,collapse = '|'),level3codes_wcvp)
native_plant_ids =  wcvp$geography$plant_name_id[native_index]
native_plant_ids = native_plant_ids[!is.na(native_plant_ids)]

native_wcvp = wcvp$wcvp_names[wcvp$wcvp_names$plant_name_id %in% native_plant_ids,]

# native_wcvp currently also contains genus only (records) so we need to reduce to species.
native_wcvp = native_wcvp[-which(native_wcvp$taxon_rank == 'Genus'),]

no_native_taxa = nrow(native_wcvp)
no_native_families = length(unique(native_wcvp$family))
no_native_genus = length(unique(native_wcvp$genus))
no_native_species = length(unique(paste0(native_wcvp$genus, ' ', native_wcvp$species)))


# Get the existing native plants from the LC to the location. 
LC_native = enriched_report[enriched_report$POWO_plant_name_id %in% native_plant_ids,]
LC_native_exisiting = LC_native[LC_native$ItemStatusType == 'Existing',]

no_native_items_LC = nrow(LC_native_exisiting)
no_native_accessions_LC = length(unique(LC_native_exisiting$AccNoFull))
no_native_families_LC = length(unique(LC_native_exisiting$POWO_family))
no_native_genus_LC = length(unique(LC_native_exisiting$POWO_genus))
no_native_species_LC = length(unique(paste0(LC_native_exisiting$POWO_genus, ' ', LC_native_exisiting$POWO_species)))
no_native_taxa_LC = length(unique(paste0(LC_native_exisiting$POWO_taxon_name, ' ', LC_native_exisiting$POWO_taxon_authors)))

category = c('Family', 'Genus', 'Species', 'Taxa')
WCVP = c(no_native_families, no_native_genus, no_native_species, no_native_taxa)
LC  = c(no_native_families_LC, no_native_genus_LC, no_native_species_LC, no_native_taxa_LC)
proportion = paste0(round(LC/WCVP*100, digits = 2),'%')

df = data.frame(category, WCVP,LC, proportion)
names(df) = c('Category', 'Native', ' Number found in collection', 'Proportion in collection')

if(export_data){
  exporting_data_store$Representative_of_native_species_in_LC_current = df
}

# Find the native families that are missing from the LC.
family_not_in = unique(native_wcvp$family)[!unique(native_wcvp$family) %in% unique(LC_native_exisiting$POWO_family)]
if(length(family_not_in) > 0){
  wcvp_wanted = native_wcvp[native_wcvp$family %in% family_not_in,]
  wcvp_wanted_format <- wcvp_wanted |>
    dplyr::group_by(.data$family) |>
    dplyr::summarise(total_taxa = length(.data$taxon_name)) |>
    dplyr::ungroup()
  names(wcvp_wanted_format) = c('Family', 'Total Native Taxa')
  
  families_collection = unique(report_original$POWO_family)
  any_in_collection = rep('No', nrow(wcvp_wanted_format))
  any_in_collection[wcvp_wanted_format$Family %in% families_collection] = 'Yes'
  wcvp_wanted_format$In_col = any_in_collection
    names(wcvp_wanted_format) = c('Family', 'Total native taxa', 'Family in collection (not-native)')

  
  
  wcvp_wanted$web_link = paste0("https://powo.science.kew.org/taxon/urn:lsid:ipni.org:names:",wcvp_wanted$powo_id)
   fam_in_collection = rep('No', nrow(wcvp_wanted))
  fam_in_collection[wcvp_wanted$family %in% families_collection] = 'Yes'
  wcvp_wanted$family_in_collection_non_native = fam_in_collection
  wcvp_wanted = wcvp_wanted[c('taxon_name', 'web_link', 'family_in_collection_non_native', 'powo_id', 'ipni_id', "family", "genus", "species_hybrid", "species",              "infraspecific_rank", "infraspecies", "parenthetical_author", "primary_author", "publication_author", "nomenclatural_remarks", "geographic_area", "lifeform_description", "climate_description")]
  wcvp_wanted = wcvp_wanted[order(wcvp_wanted$family),]

 
}


# MANAGEMENT SHEET: Export the management sheet of all native accessions.
native_accessions = LC_native_exisiting
native_accessions = native_accessions[match(unique(native_accessions$AccNoFull),native_accessions$AccNoFull),]
powo_name = paste0(native_accessions$POWO_taxon_name, ' ', native_accessions$POWO_taxon_authors)
powo_name[powo_name == 'NA NA'] = NA
native_accessions$powo_name = powo_name
native_accessions = native_accessions[,match(c('AccNoFull', 'TaxonNameFull', 'powo_name', 'threatened', 'endemic'), names(native_accessions))]
names(native_accessions) = c('Accession Number', 'Original Taxonomic Name and Author', 'POWO Taxonomic Name and Author', 'Threatened', 'Endemic')
if(export_data){
  writexl::write_xlsx(native_accessions, path =paste0(output_dir,'/',collection,'_native_accessions_list.xlsx'))

}

```

```{r, How many native species are in the LC over time B - data}
# LC_native contains, The LC reduced to native plants.
LC_native_over_time = LC_native
# The current year.
year_cur = as.numeric(format(Sys.Date(),'%Y'))

# Get which items are existing each year in the collection.
years = min_year:year_cur
date = paste0(years, '-12-31')

# Add Genus species columns from WCVP.
GenusSpecies = paste0(LC_native_over_time$POWO_genus, ' ', LC_native_over_time$POWO_species)
LC_native_over_time$GenusSpecies_new = GenusSpecies

# Remove those with missing item status date.
LC_native_over_time = LC_native_over_time[!is.na(LC_native_over_time$ItemStatusDate),]
LC_native_over_time = LC_native_over_time[LC_native_over_time$AccYear > 1650 &
                                            LC_native_over_time$AccYear <= year_cur,]
LC_native_over_time = LC_native_over_time[!is.na(LC_native_over_time$AccYear),]
LC_native_over_time = LC_native_over_time[!is.na(LC_native_over_time$ItemStatusDate),]
LC_native_over_time = LC_native_over_time[!is.na(LC_native_over_time$ItemStatusType),]

# Get the species/genera that are existing
plant_existing_LC_native = BGSmartR::exist_at_date(date, AccessionYear = as.character(LC_native_over_time$AccYear),
                       ItemStatusDate = as.character(LC_native_over_time$ItemStatusDate),
                       ItemStatusType = as.character(LC_native_over_time$ItemStatusType),
                       post_date = '3000-01-01')

# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing_LC_native, function(x){
    garden_current = LC_native_over_time[x,]

    # Get the values of interest.
    no_families_LC = length(unique(garden_current$POWO_family))
    no_genus_LC = length(unique(garden_current$POWO_genus))
    no_species_LC = length(unique(paste0(garden_current$POWO_genus, ' ', garden_current$POWO_species)))
    no_taxa_LC = length(unique(paste0(garden_current$POWO_taxon_name, ' ', garden_current$POWO_taxon_authors)))
   
    return(c(no_families_LC, no_genus_LC, no_species_LC, no_taxa_LC))
}) |>
                  data.frame() |>
                  t() |> 
                  data.frame()
names(over_time_info) = c('Family', 'Genus', 'Species', 'Taxa')
over_time_info = data.frame(Date = date, over_time_info)
row.names(over_time_info) = 1:nrow(over_time_info)

if(export_data){
  exporting_data_store$Representative_of_native_species_in_LC_over_time = over_time_info
}

```

In this section we explore the number of native plants relative to non-native plants in the living collection.

```{r, What proportion of the LC at `r collection` is native and how has this varied over time}
LC = enriched_report
LC_existing = LC[LC$ItemStatusType == 'Existing',]

is_native = rep(FALSE, nrow(LC_existing))
is_native[which(LC_existing$POWO_plant_name_id %in% native_plant_ids)] = TRUE
LC_existing$is_native = is_native


no_items = nrow(LC_existing)
no_items_native = sum(LC_existing$is_native)

accessions_data = LC_existing[match(unique(LC_existing$AccNoFull), LC_existing$AccNoFull),]
no_accessions = nrow(accessions_data)
no_accessions_native = sum(accessions_data$is_native)

taxa_data = LC_existing[match(unique(LC_existing$TaxonNameFull), LC_existing$TaxonNameFull),]
no_taxa = nrow(taxa_data)
no_taxa_native = sum(taxa_data$is_native)

species_data = LC_existing[!is.na(LC_existing$POWO_plant_name_id),]
species_data = LC_existing[match(unique(paste0(species_data$POWO_taxon_name, species_data$POWO_taxon_authors)),
                            paste0(species_data$POWO_taxon_name, species_data$POWO_taxon_authors)),]
no_species = nrow(species_data)
no_species_native = sum(species_data$is_native)

Kind = c('Items', 'Accessions', 'Taxa', 'Species')
All = c(no_items, no_accessions, no_taxa, no_species)
Native = c(no_items_native, no_accessions_native, no_taxa_native, no_species_native)
Proportion = paste0(round(Native/All*100,digits=2),'%')

to_show = data.frame(Kind = Kind, All = All, Native = Native, Proportion = Proportion)

if(export_data){
  exporting_data_store$Native_species_in_LC_current = to_show
}
```

```{r, What proportion of the LC at `r collection` is native and how has this varied over time - table}
if(report_kind == 'static'){
  to_show |>
    flextable() |>
    set_caption(caption = paste0('Native / non native plants (', paste0(location_name, collapse = ', '), ') in the LC')) |> 
    font(fontname = "Calibri (Body)", part = "all") |> 
    fontsize(size = table_font_size, part = "body") |> 
    # add footer if you want
    # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
    #                colwidths = 4) |> 
    theme_booktabs() |> # default theme
    autofit()
}
if(report_kind == 'interactive'){
  to_show |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(to_show), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=F,
                                 ordering=F))
  
  
  # DT::datatable(to_show, rownames = FALSE,
  #               # caption = paste0('Native plants in the LC (',paste0(location_name, collapse = ', '),')'),
  #                options = list(dom = 't')
  #               )
}
```

### Change of native species over time

`r if(do_over_time){"In this section we explore how the number of native species in the living collection has varied over time."}`

`r if(!do_over_time){"We do not have the information to perform how the number of native plants in the living collection has varied over time."}`


```{r, What proportion of the LC at `r collection` is native and how has this varied over time - data}
# Get the number of items accession taxa species for native plants in the LC.
over_time_info = lapply(plant_existing_LC_native, function(x){
    garden_current = LC_native_over_time[x,]

    # Get the values of interest.
    no_items = nrow(garden_current)
    no_accessions = length(unique(garden_current$AccNoFull))
    no_taxa = length(unique(garden_current$TaxonNameFull))
    no_species = length(unique(paste0(garden_current$POWO_taxon_name, garden_current$POWO_taxon_authors)[!is.na(garden_current$POWO_plant_name_id)]))
   
    return(c(no_items, no_accessions, no_taxa, no_species))
}) |>
                  data.frame() |>
                  t() |> 
                  data.frame()
names(over_time_info) = c('Items', 'Accessions', 'Taxa', 'Species')
over_time_info = data.frame(Date = date, over_time_info)
row.names(over_time_info) = 1:nrow(over_time_info)
native_data = over_time_info

if(export_data){
  exporting_data_store$Number_of_native_species_in_LC_over_time = native_data
}
```

```{r, What proportion of the LC at `r collection` is native and how has this varied over time - static number figures, eval = report_kind == 'static' & do_over_time,  fig.fullwidth=TRUE, fig.dim = c(10, 6)}
to_do = c('Items', 'Accessions', 'Taxa', 'Species')
titles = c('items', 'accessions', 'taxa', 'species')
for(i in 1:length(to_do)){
  counts = native_data[,match(to_do[i], names(native_data))]
  plot_data = data.frame(date = years, counts = counts)
  
  p = ggplot(data=plot_data, aes(x=date, y=counts)) +
  geom_line()+
  geom_point() +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title="",
        x ="Year",
        y = paste0("Number of ",titles[i])) #+
    # guides(fill=guide_legend(title=paste0("Native ", titles[i]))) +
    # theme(text = element_text(size=table_font_size)) +
    # ggtitle(paste0("Number of native ", titles[i] , " over time")
  
    if(separate_figure_folder){
ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','number_native_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
  
  print(p)
}
```

`r if(report_kind == 'interactive' & do_over_time){"##### {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Items"}`
```{r  Number of native items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
number_native_over_time <- function(native_data, type, title){
  counts = native_data[,match(type, names(native_data))]
plot_data = data.frame(date = years, counts = counts)

fig <- plot_ly(plot_data, x = ~date, y = ~counts, type = 'scatter', mode = 'lines+markers', line = list(color = interactive_colour(1)), marker = list(color = interactive_colour(1)))

fig <- fig |> layout(yaxis = list(title = paste0("Number of ",title)),
                   xaxis = list(title = "Year"))
fig <- fig |> layout(hovermode = 'x unified')
return(fig)
}
fig = number_native_over_time(native_data = native_data, type = 'Items', title = 'items')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','native_number_items_over_time.html'))
}

fig  
```

`r if(report_kind == 'interactive' & do_over_time){"###### Accessions"}`
```{r  Number of native accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = number_native_over_time(native_data = native_data, type = 'Accessions', title = 'accessions')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','native_number_accessions_over_time.html'))
}

fig  
```

`r if(report_kind == 'interactive' & do_over_time){"###### Taxa"}`
```{r  Number of taxa accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = number_native_over_time(native_data = native_data, type = 'Taxa', title = 'taxa')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','native_number_taxa_over_time.html'))
}

fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Species"}`
```{r  Number of native species over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = number_native_over_time(native_data = native_data, type = 'Species', title = 'species')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','native_number_species_over_time.html'))
}

fig
```

`r if(report_kind == 'interactive' & do_over_time){"##### {-}"}`

`r if(do_over_time){"Next we view native plants as a percentage of all plants in the living collection over time."}`

```{r, What proportion of the LC at `r collection` is native and how has this varied over time - percentage data, eval = do_over_time}
# Do the same for the whole collection.
report = enriched_report
report = report[report$AccYear > 1650 & report$AccYear<=year_cur,]
report = report[!is.na(report$ItemStatusDate),]
plant_existing = BGSmartR::exist_at_date(date, AccessionYear = as.character(report$AccYear),
                       ItemStatusDate = as.character(report$ItemStatusDate),
                       ItemStatusType = as.character(report$ItemStatusType),post_date = '3000-01-01')

# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing, function(x){
    garden_current = report[x,]
    
    # Get the values of interest.

    no_items = nrow(garden_current)
    no_accessions = length(unique(garden_current$AccNoFull))
    no_taxa = length(unique(garden_current$TaxonNameFull))
    no_species = length(unique(paste0(garden_current$POWO_taxon_name, garden_current$POWO_taxon_authors)[!is.na(garden_current$POWO_plant_name_id)]))

    return(c(no_items, no_accessions, no_taxa, no_species))
}) |>
                  data.frame() |>
                  t() |> 
                  data.frame()
names(over_time_info) = c('Items', 'Accessions', 'Taxa', 'Species')
over_time_info = data.frame(Date = date, over_time_info)
row.names(over_time_info) = 1:nrow(over_time_info)
LC_data = over_time_info

if(export_data){
  exporting_data_store$Total_species_in_LC_over_time = LC_data
}
```

```{r, What proportion of the LC at `r collection` is native and how has this varied over time - static percentage figures, eval = report_kind == 'static' & do_over_time, fig.fullwidth=TRUE, fig.dim = c(10, 6)}
to_do =  c('Items', 'Accessions', 'Taxa', 'Species')
titles = c('items', 'accessions', 'taxa', 'species')

# Loop over to_do.
for(i in 1:length(to_do)){
  native_counts = native_data[,match(to_do[i], names(native_data))]
  total_counts = LC_data[,match(paste0(to_do[i]), names(LC_data))]
  
  percent = round(native_counts/total_counts*100, digits = 3)

  plot_dataA = data.frame(date =years, 
                               percent = percent,
                               represented = rep('Native', length(date)))
  plot_dataB = data.frame(date =years, 
                             percent = 100-percent,
                              represented = rep('Non Native', length(date)))
  
  plot_data = rbind(plot_dataA, plot_dataB)
  plot_data$represented = factor(plot_data$represented,levels = c('Non Native','Native'))
  
  names(plot_data) = c('dates', 'percentage', 'represented')

  p = ggplot(plot_data, aes(fill=represented, y=percentage, x=dates)) + 
    geom_bar(position="stack", stat="identity", width = 1) +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title="",
        x ="Year",
        y = "Percentage (%)") +
    guides(fill=guide_legend(title=paste0("Native ", titles[i]))) +
   scale_fill_discrete() # +
    # theme(text = element_text(size=table_font_size)) +
    # ggtitle(paste0("Proportion of ", titles[i] , " that are native in the LC over time"))
    
      if(separate_figure_folder){
ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','proportion_native_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
    
  print(p)
}
 

```

`r if(report_kind == 'interactive' & do_over_time){"#####  Proportion of native plants over time graphs  {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Items"}`
```{r  Proportion of native items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
# native_data <<- native_data ; LC_data <<- LC_data ; typeA <<- 'Items' ; titleA <<- 'items'
proportion_native <- function(native_data,LC_data, type, title){
  native_counts = native_data[,match(type, names(native_data))]
  total_counts = LC_data[,match(paste0(type), names(LC_data))]

  percent = round(native_counts/total_counts*100, digits = 3)
  

  # Line graph of only the native plants. 
  plot_data = data.frame(date =years, 
                               percent = percent
                               )
  fig <- plot_ly(plot_data, x = ~date, y = ~percent, type = 'scatter', mode = 'lines+markers', line = list(color = interactive_colour(1)), marker = list(color = interactive_colour(1)))

fig <- fig |> layout(yaxis = list(title = paste0("Percentage of ",title)),
                   xaxis = list(title = "Year"))
fig <- fig |> layout(hovermode = 'x unified',
                     yaxis = list(ticksuffix  ='%', hoverformat = '.1f'))
  

  # Stacked Bar version. 
   # plot_dataA = data.frame(date =years, 
   #                             percent = percent,
   #                             represented = rep('Native', length(date)))
   # 
  # plot_dataB = data.frame(date =years, 
  #                            percent = 100-percent,
  #                             represented = rep('Non-Native', length(date)))
  
  # plot_data = rbind(plot_dataA, plot_dataB)
  # plot_data$represented = factor(plot_data$represented, levels = c('Native', 'Non-Native'))
  # fig <- plot_ly(plot_data, x = ~date, y = ~percent, color = ~represented, type = 'bar', colors = interactive_colour(2))
  # fig <- fig |> layout(yaxis = list(title = paste0('Percentage of ',title)),
  #                      xaxis = list(title = "Year"),
  #                      legend=list(title=list(text=paste0("Native ", title))),
  #                      barmode = 'stack',
  #                      hoverlabel = list(namelength = -1))
  # fig <- fig |> layout(hovermode = 'x unified',
  #                      bargap =0,
  #                      yaxis = list(ticksuffix  ='%', hoverformat = '.1f')
                       
  

return(fig)
}

fig = proportion_native(native_data = native_data,LC_data = LC_data, type = 'Items', title = 'items')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','percentage_of_native_items_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Accessions"}`
```{r  Proportion of native accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = proportion_native(native_data = native_data,LC_data = LC_data, type = 'Accessions', title = 'accessions')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_bar-percentage_of_native_accessions_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Taxa"}`
```{r  Proportion of native taxa over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = proportion_native(native_data = native_data,LC_data = LC_data, type = 'Taxa', title = 'taxa')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_bar-percentage_of_native_taxa_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Species"}`
```{r  Proportion of native species over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = proportion_native(native_data = native_data,LC_data = LC_data, type = 'Species', title = 'species')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_bar-percentage_of_native_species_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"##### {-}"}`

***

### Number of native species relative to WCVP

```{r, How many native species are in the LC B - data}
# Find all the native taxa to the location of the LC in WCVP
geography_data = wcvp$geography[,grepl('_area_code_l3', names(wcvp$geography))]
want = c('000','010','001','011','100','110','101')
#Depending on the values of the options reduce `want` to only the satisfactory values.
##A) introduced / naturally occurring only.
if(native == 'Introduced only'){
 want = want[grepl('^1',want)]
}else if(native == 'Naturally occurring only'){
 want = want[grepl('^0',want)]
}
## B) Extinct
if(!extinct){
 want = want[!grepl('010|011|110',want)]
}
## C) Doubtful
if(!doubtful_locations){
 want = want[!grepl('001|011|101',want)]
}
# Get the columns in wanted info that contain the geography information we want.
geography_data = geography_data[,grepl(paste0(want,collapse='|'), names(geography_data))]

if(length(want) > 1){
 level3codes =do.call("paste", c(geography_data, sep = ", "))
 level3codes = stringr::str_remove(level3codes, ', NA$')
 level3codes = stringr::str_remove(level3codes, 'NA, ')
}else{
 level3codes = geography_data
}
level3codes_wcvp = level3codes

native_index = grepl(paste0(location_code,collapse = '|'),level3codes_wcvp)
native_plant_ids =  wcvp$geography$plant_name_id[native_index]
native_plant_ids = native_plant_ids[!is.na(native_plant_ids)]

native_wcvp = wcvp$wcvp_names[wcvp$wcvp_names$plant_name_id %in% native_plant_ids,]

# native_wcvp currently also contains genus only (records) so we need to reduce to species.
native_wcvp = native_wcvp[-which(native_wcvp$taxon_rank == 'Genus'),]

no_native_taxa = nrow(native_wcvp)
no_native_families = length(unique(native_wcvp$family))
no_native_genus = length(unique(native_wcvp$genus))
no_native_species = length(unique(paste0(native_wcvp$genus, ' ', native_wcvp$species)))


# Get the existing native plants from the LC to the location. 
LC_native = enriched_report[enriched_report$POWO_plant_name_id %in% native_plant_ids,]
LC_native_exisiting = LC_native[LC_native$ItemStatusType == 'Existing',]

no_native_items_LC = nrow(LC_native_exisiting)
no_native_accessions_LC = length(unique(LC_native_exisiting$AccNoFull))
no_native_families_LC = length(unique(LC_native_exisiting$POWO_family))
no_native_genus_LC = length(unique(LC_native_exisiting$POWO_genus))
no_native_species_LC = length(unique(paste0(LC_native_exisiting$POWO_genus, ' ', LC_native_exisiting$POWO_species)))
no_native_taxa_LC = length(unique(paste0(LC_native_exisiting$POWO_taxon_name, ' ', LC_native_exisiting$POWO_taxon_authors)))

category = c('Families', 'Genera', 'Species', 'Taxa')
WCVP = c(no_native_families, no_native_genus, no_native_species, no_native_taxa)
LC  = c(no_native_families_LC, no_native_genus_LC, no_native_species_LC, no_native_taxa_LC)
proportion = paste0(round(LC/WCVP*100, digits = 2),'%')

df = data.frame(category, WCVP,LC, proportion)
df2 = df
names(df2) = c('Category', 'Native', ' Number of native plants found in collection', 'Proportion of native plants found in the collection')
names(df) = c('', 'Total number of native plants', ' Number of native plants found in collection', 'Proportion of native plants found in the collection')

if(export_data){
  exporting_data_store$Representative_of_native_species_in_LC_current = df
}

# Find the native families that are missing from the LC.
family_not_in = unique(native_wcvp$family)[!unique(native_wcvp$family) %in% unique(LC_native_exisiting$POWO_family)]
if(length(family_not_in) > 0){
  wcvp_wanted = native_wcvp[native_wcvp$family %in% family_not_in,]
  wcvp_wanted_format <- wcvp_wanted |>
    dplyr::group_by(.data$family) |>
    dplyr::summarise(total_taxa = length(.data$taxon_name)) |>
    dplyr::ungroup()
  names(wcvp_wanted_format) = c('Family', 'Total Native Taxa')
  
  families_collection = unique(report_original$POWO_family)
  any_in_collection = rep('No', nrow(wcvp_wanted_format))
  any_in_collection[wcvp_wanted_format$Family %in% families_collection] = 'Yes'
  wcvp_wanted_format$In_col = any_in_collection
  wcvp_wanted_format = wcvp_wanted_format[order(wcvp_wanted_format$In_col, wcvp_wanted_format$Family),]
    names(wcvp_wanted_format) = c('Family', 'Total number of native taxa', 'Is the family in the collection (not-native)?')

  
  
  wcvp_wanted$web_link = paste0("https://powo.science.kew.org/taxon/urn:lsid:ipni.org:names:",wcvp_wanted$powo_id)
   fam_in_collection = rep('No', nrow(wcvp_wanted))
  fam_in_collection[wcvp_wanted$family %in% families_collection] = 'Yes'
  wcvp_wanted$family_in_collection_non_native = fam_in_collection
  wcvp_wanted = wcvp_wanted[c('taxon_name', 'web_link', 'family_in_collection_non_native', 'powo_id', 'ipni_id', "family", "genus", "species_hybrid", "species",              "infraspecific_rank", "infraspecies", "parenthetical_author", "primary_author", "publication_author", "nomenclatural_remarks", "geographic_area", "lifeform_description", "climate_description")]
  wcvp_wanted = wcvp_wanted[order(wcvp_wanted$family),]

 
}


# MANAGEMENT SHEET: Export the management sheet of all native accessions.
native_accessions = LC_native_exisiting
native_accessions = native_accessions[match(unique(native_accessions$AccNoFull),native_accessions$AccNoFull),]
powo_name = paste0(native_accessions$POWO_taxon_name, ' ', native_accessions$POWO_taxon_authors)
powo_name[powo_name == 'NA NA'] = NA
native_accessions$powo_name = powo_name
native_accessions = native_accessions[,match(c('AccNoFull', 'TaxonNameFull', 'powo_name', 'threatened', 'endemic'), names(native_accessions))]
names(native_accessions) = c('Accession Number', 'Original Taxonomic Name and Author', 'POWO Taxonomic Name and Author', 'Threatened', 'Endemic')
if(export_data){
  writexl::write_xlsx(native_accessions, path =paste0(output_dir,'/',collection,'_native_accessions_list.xlsx'))

}

```

In the living collection there are `r format(no_native_items_LC, big.mark=',')` items corresponding to  `r format(no_native_accessions_LC, big.mark=',')` accessions of existing native plants.

In the following table we show how many native plants are represented in the living collection at different taxonomic levels relative to all plants from `r paste0(location_name, collapse = ', ')` in WCVP.

```{r, How many native species are in the LC - table}
if(report_kind == 'static'){
  df |>
  flextable() |>
  set_caption(caption = "Native plants in the collection compared to WCVP") |> 
  font(fontname = "Calibri (Body)", part = "all") |> 
  fontsize(size = table_font_size, part = "body") |> 
  # add footer if you want
  # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
  #                colwidths = 4) |> 
  theme_booktabs() |> # default theme
  autofit()
}
if(report_kind == 'interactive'){
  df |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(df), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=F,
                                 ordering=F))
  
  
  # DT::datatable(df, rownames = FALSE,
  #               # caption = paste0('Native plants in the LC compared to ',
  #               #                                       paste0(location_name, collapse = ', '),
  #               #                                       ''),
  #               options = list(dom = 't'))
}

```

`r if(length(family_not_in) > 0){"The families either not represented in the collection or represented by non-native taxa are outlined below, together with the total number of native taxa in each family."}`

```{r families not in the LC - Table, eval = length(family_not_in) > 0}
if(report_kind == 'static'){
  wcvp_wanted_format |>
  flextable() |>
  set_caption(caption = "Native Families not in the LC") |> 
  font(fontname = "Calibri (Body)", part = "all") |> 
  fontsize(size = table_font_size, part = "body") |> 
  # add footer if you want
  # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
  #                colwidths = 4) |> 
  theme_booktabs() |> # default theme
  autofit()
}
if(report_kind == 'interactive'){
  wcvp_wanted_format|>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(wcvp_wanted_format), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=T,
                                 ordering=T),
                  filter = list(position = "top"))
  
  # DT::datatable(wcvp_wanted_format, rownames = FALSE,
  #                options = list(dom = 'tp',pageLength =  5), filter = list(position = "top"))
}

```



`r if(length(family_not_in) > 0){':::: {.blackbox data-latex=""}'}`

`r if(length(family_not_in) > 0){"Download below a list of native plants from the missing families that you could aim to source to increase the diversity and the representation of native taxa in your collection."}`


```{r link to download missing native family plants, eval = report_kind == 'interactive' & length(family_not_in) > 0}
wcvp_wanted |>
  download_this(
    output_name = "WCVP_native_plants_not_in_the_LC",
    output_extension = ".xlsx",
    button_label = "Download native families not in the collection (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained =  T
  )
```

`r if(length(family_not_in) > 0){"::::"}`


`r if(do_over_time){"Below we produce figures detailing how the representation of native plants at different taxonomic levels has changed over time in your living collection."}`



```{r, How many native species are in the LC over time - data}
# LC_native contains, The LC reduced to native plants.
LC_native_over_time = LC_native
# The current year.
year_cur = as.numeric(format(Sys.Date(),'%Y'))

# Get which items are existing each year in the collection.
years = min_year:year_cur
date = paste0(years, '-12-31')

# Add Genus species columns from WCVP.
GenusSpecies = paste0(LC_native_over_time$POWO_genus, ' ', LC_native_over_time$POWO_species)
LC_native_over_time$GenusSpecies_new = GenusSpecies

# Remove those with missing item status date.
LC_native_over_time = LC_native_over_time[!is.na(LC_native_over_time$ItemStatusDate),]
LC_native_over_time = LC_native_over_time[LC_native_over_time$AccYear > 1650 &
                                            LC_native_over_time$AccYear <= year_cur,]
LC_native_over_time = LC_native_over_time[!is.na(LC_native_over_time$AccYear),]
LC_native_over_time = LC_native_over_time[!is.na(LC_native_over_time$ItemStatusDate),]
LC_native_over_time = LC_native_over_time[!is.na(LC_native_over_time$ItemStatusType),]
# Get the species/genera that are existing
plant_existing_LC_native = BGSmartR::exist_at_date(date, AccessionYear = as.character(LC_native_over_time$AccYear),
                       ItemStatusDate = as.character(LC_native_over_time$ItemStatusDate),
                       ItemStatusType = as.character(LC_native_over_time$ItemStatusType),
                       post_date = '3000-01-01')

# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing_LC_native, function(x){
    garden_current = LC_native_over_time[x,]

    # Get the values of interest.
    no_families_LC = length(unique(garden_current$POWO_family))
    no_genus_LC = length(unique(garden_current$POWO_genus))
    no_species_LC = length(unique(paste0(garden_current$POWO_genus, ' ', garden_current$POWO_species)))
    no_taxa_LC = length(unique(paste0(garden_current$POWO_taxon_name, ' ', garden_current$POWO_taxon_authors)))
   
    return(c(no_families_LC, no_genus_LC, no_species_LC, no_taxa_LC))
}) |>
                  data.frame() |>
                  t() |> 
                  data.frame()
names(over_time_info) = c('Families', 'Genera', 'Species', 'Taxa')
over_time_info = data.frame(Date = date, over_time_info)
row.names(over_time_info) = 1:nrow(over_time_info)

if(export_data){
  exporting_data_store$Representative_of_native_species_in_LC_over_time = over_time_info
}

```

```{r  How many native species are in the LC - static figures, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'static' & do_over_time}
to_do = c('Families', 'Genera', 'Species', 'Taxa')
titles  = c('Families', 'Genera', 'Species', 'Taxa')
# Loop over to_do.
for(i in 1:length(to_do)){
  count = as.numeric(unlist(over_time_info[match(to_do[i], names(over_time_info))]))
  percent = round(count/df$Native[which(df$Category == to_do[i])]*100, digits = 3)
  
  plot_dataA = data.frame(date =years, 
                               percent = percent,
                               represented = rep('Represented', length(date)))
  plot_dataB = data.frame(date =years, 
                             percent = 100-percent,
                              represented = rep('Not Represented', length(date)))
  
  plot_data = rbind(plot_dataA, plot_dataB)
  
  
  names(plot_data) = c('dates', 'percentage', 'represented')

  p = ggplot(plot_data, aes(fill=represented, y=percentage, x=dates)) + 
    geom_bar(position="stack", stat="identity", width = 1) +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(x ="Year",
        y = "Percentage (%)") +
    guides(fill=guide_legend(title=paste0("Native ", titles[i]))) +
    scale_color_manual(values = c('#f46d43', '#e6e6e6')
)
    # scale_fill_discrete() #+
    # ggtitle(paste0("Representation of ", titles[i] , " over time"))
  
  if(separate_figure_folder){
ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','How_many_native_species_are_in_the_LC', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}
  print(p)
}


 
```

`r if(report_kind == 'interactive' & do_over_time){"##### Representation over time graphs {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Families"}`
```{r  How many native species are in the LC - interactive Family plot, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
represented_figure <- function(data, whole_collection, type, title){
  count = as.numeric(unlist(data[match(type, names(data))]))
  percent = round(count/whole_collection$Native[which(whole_collection$Category == type)]*100, digits = 3)
  plot_dataA = data.frame(date =years, 
                               percent = percent,
                               represented = rep('Represented', length(date)))
  plot_dataB = data.frame(date =years, 
                             percent = 100-percent,
                              represented = rep('Not Represented', length(date)))
  
  plot_data = rbind(plot_dataA, plot_dataB)
  plot_data$represented = factor(plot_data$represented, levels = c('Represented', 'Not Represented'))
  
  fig <- plot_ly(plot_data, x = ~date, y = ~percent, color = ~represented, type = 'bar', colors = interactive_colour(2))
  fig <- fig |> layout(yaxis = list(title = paste0('Percentage of ',title)),
                       xaxis = list(title = "Year"),
                       legend=list(title=list(text=paste0("Native ", title))),
                       barmode = 'stack',
                       hoverlabel = list(namelength = -1))
  fig <- fig |> layout(hovermode = 'x unified',
                       bargap =0,
                       yaxis = list(ticksuffix  ='%', hoverformat = '.1f')
                       
  )

return(fig)
}

fig = represented_figure(data = over_time_info, whole_collection = df2, type = 'Families', title = 'families')

  if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','native_family_represented_over_time.html'))
}

fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Genera"}`
```{r  How many native species are in the LC - interactive Genera plot, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = represented_figure(data = over_time_info, whole_collection = df2, type = 'Genera', title = 'genera')
  
  if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','native_genera_represented_over_time.html'))
}
 
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Species"}`
```{r  How many native species are in the LC - interactive Species plot, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = represented_figure(data = over_time_info, whole_collection = df2, type = 'Species', title = 'species')
  
  if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','native_species_represented_over_time.html'))
}
 
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Taxa"}`
```{r  How many native species are in the LC - interactive Taxa plot, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = represented_figure(data = over_time_info, whole_collection = df2, type = 'Taxa', title = 'taxa')
  
  if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','native_taxa_represented_over_time.html'))
}
 
fig
```



***

### Provenance of native species

In this section we explore the provenance of native plants in the collection.

```{r, Provenance of native plants in the LC, ,  results='hide',fig.keep='all', message=FALSE}
# LC_native_exisiting the data of existing native plants in the LC. 
wanted_order = c('Wild', 'Wild-derived', 'Garden', 'Unknown')
prov_items = data.frame(table(LC_native_exisiting$ProvenanceCode))
rows = match(wanted_order, prov_items[,1])
other = which(!prov_items[,1] %in% wanted_order)
o = c(rows,other)
o = o[!is.na(o)]
prov_items = prov_items[o,]
names(prov_items) = c('Provenance', 'Items')
# prov_items$Provenance  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(prov_items$Provenance, c('G', 'U', 'W', 'Z'))]  
prov_items$percent = paste0(round(prov_items$Items / sum(prov_items$Items)*100,digits = 1),'%')
prov_items <- prov_items %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Items))), 
         pos = Items/2 + dplyr::lead(csum, 1),
         pos = dplyr::if_else(is.na(pos), Items/2, pos))


prov_accessions = data.frame(table(LC_native_exisiting$ProvenanceCode[match(unique(LC_native_exisiting$AccNoFull), LC_native_exisiting$AccNoFull)]))
rows = match(wanted_order, prov_accessions[,1])
other = which(!prov_accessions[,1] %in% wanted_order)
o = c(rows,other)
o = o[!is.na(o)]
prov_accessions = prov_accessions[o,]
names(prov_accessions) = c('Provenance', 'Accessions')
# prov_accessions$Provenance  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(prov_accessions$Provenance, c('G', 'U', 'W', 'Z'))]
prov_accessions$percent = paste0(round(prov_accessions$Accessions / sum(prov_accessions$Accessions)*100,digits = 1),'%')
prov_accessions <- prov_accessions %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Accessions))), 
         pos = Accessions/2 + dplyr::lead(csum, 1),
         pos = dplyr::if_else(is.na(pos), Accessions/2, pos))

flex_data = data.frame(prov_items$Provenance,
                       prov_items$Items, 
                       paste0(round(prov_items$Items/sum(prov_items$Items)*100,digits=2),'%'),
                       prov_accessions$Accessions,
                       paste0(round(prov_accessions$Accessions/sum(prov_accessions$Accessions)*100,digits=2),'%'))
names(flex_data) = c('Provenance', 'Number of items', 'Proportion of items', 'Number of accessions', 'Proportion of accessions')

rows = match(wanted_order, flex_data$Provenance)
other = which(!flex_data$Provenance %in% wanted_order)
o = c(rows,other)
o = o[!is.na(o)]
flex_data = flex_data[o,]

if(export_data){
  exporting_data_store$Provenance_of_existing_native_plants_in_the_LC = flex_data
}


### Create provenance by taxa to see if any have multiple provenance codes. 
taxa_prov_og = LC_native_exisiting |>
  dplyr::group_by(best_name) |>
  summarise(wild_items = sum(.data$ProvenanceCode == 'Wild'),
            z_items = sum(.data$ProvenanceCode == "Wild-derived"),
            garden_items = sum(.data$ProvenanceCode == 'Garden'),
            unknown_items = sum(.data$ProvenanceCode == 'Unknown'),
            original_name = toString(.data$TaxonNameFull |> unique())
            )

taxa_prov = taxa_prov_og[,c(1:5)] |> as.data.frame()
for(i in 2:5){taxa_prov[,i] = taxa_prov[,i] |> as.numeric()}

wild_taxa = taxa_prov$best_name[taxa_prov$wild_items > 0]
z_taxa = taxa_prov$best_name[taxa_prov$z_items > 0]
g_taxa = taxa_prov$best_name[taxa_prov$garden_items > 0]
u_taxa = taxa_prov$best_name[taxa_prov$unknown_items > 0]
x = list() ; category.names = NULL ; colours = NULL
if(length(wild_taxa) > 0 ){x$w = wild_taxa ; category.names = c(category.names, "Wild") ; colours = c(colours, interactive_colour(4)[c(1)])}
if(length(u_taxa) > 0 ){x$u = u_taxa ; category.names = c(category.names, "Unknown") ; colours = c(colours, interactive_colour(4)[c(4)])}
if(length(z_taxa) > 0 ){x$z = z_taxa ; category.names = c(category.names, "Wild-derived"); colours = c(colours, interactive_colour(4)[c(2)])}
if(length(g_taxa) > 0 ){x$g = g_taxa ; category.names = c(category.names, "Garden"); colours = c(colours, interactive_colour(4)[c(3)])}
library(VennDiagram)
venn_diag = venn.diagram(x, filename = NULL,
                         category.names = category.names,
                         fill =colours,
                         disable.logging = TRUE,
                         main.fontfamily = "arial",
                         main.fontface = "sans")


# Make a data.frame of the overlapping taxa for a download.
taxa_prov_og$no_val =  lapply(taxa_prov_og[,-6] |> as.data.frame() |> t() |> as.data.frame(),function(x){
  sum(as.numeric(x[-1]) != 0)
}) |> unlist()

taxa_prov = taxa_prov_og[taxa_prov_og$no_val > 1,]
taxa_prov = taxa_prov[,-7]
taxa_prov =taxa_prov[,c(1,6,2,3,4,5)]
names(taxa_prov) = c("Best name found by BGSmartR",
                     "Original Taxonomic name/s",
                     "Number of Wild Origin Items",
                     "Number of Wild-derived Origin Items",
                     "Number of Garden Origin Items",
                     "Number of Unknown Origin Items")


### (END) Create provenance by taxa to see if any have multiple provenance codes. 


### MANAGEMENT SHEET: Wild/Wild-derived accessions of native plants
```

The table and the pie charts below show the numbers of native plants in the living collection by provenance categories.

```{r, Provenance of native plants in the LC pie charts, echo = FALSE, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'static'}
# Basic piechart
pie1 = ggplot(prov_items, aes(x="", y=Items, fill=Provenance)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtheme(base_size = 18) +
  ggtitle('Items') +
  scale_fill_discrete() +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

pie2 = ggplot(prov_accessions, aes(x="", y=Accessions, fill=Provenance)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtitle('Accessions') + 
  scale_fill_discrete() +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

    if(value_on_fig){
      pie1 = pie1 + geom_label_repel(aes(y = pos,label = percent),
                   size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white")   
      
      pie2 = pie2 + geom_label_repel(aes(y = pos,label = percent),
                   size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white") 
  }

p = ggpubr::ggarrange(pie1, pie2, ncol=2, nrow=1, common.legend = TRUE, legend="bottom")

if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Provenance_of_native_plants.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}


p

```

`r if(report_kind == 'interactive'){"#####  Provenance of native species in the living collection {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Chart"}`
```{r  Provenance of existing native items in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
figs = list()
colours = interactive_colour(4)
names(colours) = c('Wild', 'Wild-derived', 'Garden', 'Unknown')
colours = colours[match(prov_items$Provenance, names(colours))]

# Items
text = paste0(prov_items$Items, ' ',prov_items$Provenance,' origin native items')
fig1 <- plot_ly(prov_items, labels = ~Provenance, values = ~Items, hoverinfo = "text",  hovertext = text, sort = FALSE, marker = list(colors = colours))
fig1 <- fig1 |> add_pie(hole = 0.6)
fig1 <- fig1 |> layout(title = "Items",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
figs$items = fig1
#Accessions
text = paste0(prov_accessions$Accessions, ' ',prov_accessions$Provenance,' origin native items')
fig2 <- plot_ly(prov_accessions, labels = ~Provenance, values = ~Accessions, hoverinfo = "text",  hovertext = text, sort = FALSE, marker = list(colors = colours))
fig2 <- fig2 |> add_pie(hole = 0.6)
fig2 <- fig2 |> layout(title = "Accessions",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
figs$accessions = fig2

# Together
p <- plot_ly() |>
  add_pie(data = prov_items, labels = ~Provenance, values = ~Items, hole = 0.6,
          title = "Items", name ='', sort = FALSE, marker = list(colors = colours),
          domain = list(row = 0, column = 0)) |>
  add_pie(data = prov_accessions, labels = ~Provenance, values = ~Accessions, hole = 0.6,
          title = "Accessions", name ='', sort = FALSE, marker = list(colors = colours),
         domain = list(row = 0, column = 1))  |>
  layout(title = "", showlegend = TRUE,
          grid=list(rows=1, columns=2),
         plot_bgcolor="#f0f0f0",
         legend = list(orientation = 'h', xanchor = "center", x = 0.5),
         xaxis = list(title=paste0('Items', 'Accessions'), showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         margin = c(0,0,0,0))


if(separate_figure_folder){
  htmlwidgets::saveWidget(figs$items, file = paste0(figures_dir, '/','native_provenance_existing_items.html'))
  htmlwidgets::saveWidget(figs$accessions, file = paste0(figures_dir, '/','native_provenance_existing_accessions.html'))
}

p
  
```

`r if(report_kind == 'interactive'){"###### Table"}`

```{r Provenance of native plants in the LC - Table}
if(report_kind == 'static'){
flex_data |>
  flextable() |>
  set_caption(caption = paste0('Provenance of existing native plants in the LC')) |> 
  font(fontname = "Calibri (Body)", part = "all") |> 
  fontsize(size = table_font_size, part = "body") |> 
  # add footer if you want
  # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
  #                colwidths = 4) |> 
  theme_booktabs() |> # default theme
  separate_header() |> 
  align(align = "center", part = "all") |>
  autofit()
}
if(report_kind == 'interactive'){
  flex_data |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(flex_data), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=F,
                                 ordering=F))
  
  # DT::datatable(flex_data, rownames = FALSE,
  #               # caption = paste0('Provenance of exisiting native plants in the LC'),
  #               options = list(dom = 't'))
}

```

`r if(report_kind == 'interactive'){"##### {-}"}`

`r if(do_over_time){"We now look at how the provenance of native plants in the living collection has changed over time."}`

`r if(!do_over_time){"We do not have the information to explore how provenance of native plants in the living collection has changed over time."}`

```{r, Provenance of native plants in the LC- change over time data, eval = do_over_time}
# LC_native_over_time contains the over time native plants.
redlistcatA = LC_native_over_time$redList_category
redlistcatB = LC_native_over_time$POWO_Red_category

redlist_used = rep(NA, nrow(LC_native_over_time))
redlist_used[redlistcatA == 'VU' | redlistcatB == 'VU'] = 'VU'
redlist_used[redlistcatA == 'EN' | redlistcatB == 'EN'] = 'EN'
redlist_used[redlistcatA == 'CR' | redlistcatB == 'CR'] = 'CR'
redlist_used[redlistcatA == 'EW' | redlistcatB == 'EW'] = 'EW'
redlist_used[redlistcatA == 'EX' | redlistcatB == 'EX'] = 'EX'

LC_native_over_time$redlist_used = redlist_used

# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing_LC_native, function(x){
  garden_current = LC_native_over_time[x,]
  
  prov_items =  data.frame(table(garden_current$ProvenanceCode))
  if(nrow(prov_items) == 0){
    return(list(prov_items = prov_items,
              prov_accessions = prov_items,
              redlistcat_items = prov_items,
              redlistcat_accessions = prov_items,
              redlistcat_taxa = prov_items))
  }
  names(prov_items) = c('Provenance', 'Items')
  
  prov_accessions = data.frame(table(garden_current$ProvenanceCode[match(unique(garden_current$AccNoFull), garden_current$AccNoFull)]))
  names(prov_accessions) = c('Provenance', 'Accessions')
  
  redlistcat_items = data.frame(table(garden_current$redlist_used))
  if(ncol(redlistcat_items) != 2){redlistcat_items = data.frame(matrix(ncol = 2, nrow = 0))}
  names(redlistcat_items) = c('RedListCategory', 'Items')
  
  redlistcat_accessions = data.frame(table(garden_current$redlist_used[match(unique(garden_current$AccNoFull), garden_current$AccNoFull)]))
  if(ncol(redlistcat_accessions) != 2){redlistcat_accessions = data.frame(matrix(ncol = 2, nrow = 0))}
  
  names(redlistcat_accessions) = c('RedListCategory', 'Accessions')
  
  taxa = paste0(garden_current$POWO_taxon_name, ' ', garden_current$POWO_taxon_authors)
  redlistcat_taxa = data.frame(table(garden_current$redlist_used[match(unique(taxa), taxa)]))
  if(ncol(redlistcat_taxa) != 2){redlistcat_taxa = data.frame(matrix(ncol = 2, nrow = 0))}
  
  names(redlistcat_taxa) = c('RedListCategory', 'Accessions')
  
  
  return(list(prov_items = prov_items,
              prov_accessions = prov_accessions,
              redlistcat_items = redlistcat_items,
              redlistcat_accessions = redlistcat_accessions,
              redlistcat_taxa = redlistcat_taxa))
})
prov_redlist_native_over_time = over_time_info

```

```{r, Provenance of native plants in the LC- change over time figures, fig.fullwidth=FALSE, fig.dim = c(10, 6), , eval = report_kind == 'static' & do_over_time}
to_do = c('items', 'accessions')
for(i in 1:length(to_do)){
  # Get the data from over_time_info.
  data_wanted = NULL
  wanted_item = which(grepl('prov',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
  for(jj in 1:length(over_time_info)){
    info_year = over_time_info[[jj]][[wanted_item]]
    if(nrow(info_year) == 0){
      next
    }
    prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
    info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)),
                           info_year = info_year,
                           prop = prop)
    data_wanted = rbind(data_wanted, info_year)

  }
  names(data_wanted) = c('year', 'Provenance', 'Items', 'prop')
  data_wanted[,2] = as.character(data_wanted[,2])
  # data_wanted[,2]  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(data_wanted[,2], c('G', 'U', 'W', 'Z') )]
  data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))
  
  
    if(export_data){
    item_name = paste0('Provenance_of_native_plants_in_the_LC_proportion_over_time_',to_do[i])
  exporting_data_store$AA = data_wanted
  names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
    }
  
    p = ggplot(data_wanted, aes(fill=Provenance, y=prop, x=year)) + 
    geom_bar(position="stack", stat="identity", width = 1) +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title="",
        x ="Year",
        y = "Percentage (%)") +
    guides(fill=guide_legend(title=paste0('Provenance')))# +
    # theme(text = element_text(size=table_font_size)) +
    # ggtitle(paste0("Provenance of ", to_do[i] , " that are native in the LC over time"))
    
    if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Provenance_of_native_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}
  print(p)

}
```

`r if(report_kind == 'interactive'& do_over_time){"##### {.tabset}"}`

`r if(report_kind == 'interactive'& do_over_time){"###### Items"}`
```{r  Provenance of native items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'& do_over_time}
wanted_order = c('Wild', 'Wild-derived', 'Garden', 'Unknown')
to_do = c('items', 'accessions')
i=1

# Get the data from over_time_info.
data_wanted = NULL
wanted_item = which(grepl('prov',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
for(jj in 1:length(over_time_info)){
  info_year = over_time_info[[jj]][[wanted_item]]
  if(nrow(info_year) == 0){
    next
  }
  rows = match(wanted_order, info_year[,1])
  other = which(!info_year[,1] %in% wanted_order)
  o = c(rows,other)
  o = o[!is.na(o)]
  info_year = info_year[o,]
  prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
  info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)),
                         info_year = info_year,
                         prop = prop)
  data_wanted = rbind(data_wanted, info_year)

}
names(data_wanted) = c('year', 'Provenance', 'Items', 'prop')
data_wanted[,2] = as.character(data_wanted[,2])
# data_wanted[,2]  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(data_wanted[,2], c('G', 'U', 'W', 'Z') )]
data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))


  if(export_data){
  item_name = paste0('Provenance_of_native_plants_in_the_LC_proportion_over_time_',to_do[i])
exporting_data_store$AA = data_wanted
names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
  }


text = paste0(round(data_wanted$prop,digits=2), '% (',data_wanted$Items,' items) ')
data_wanted$text = text
data_wanted$Provenance = factor(data_wanted$Provenance, levels= unique(data_wanted$Provenance))
fig <- plot_ly(data_wanted, x = ~year, y = ~prop, color = ~Provenance, type = 'bar', text = ~text,
               hovertemplate = '%{text}', colors = colours )
fig <- fig |> layout(yaxis = list(title = 'Percentage', ticksuffix  ='%', hoverformat = '.1f'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text='')),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)

fig

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','native_provenance_over_time_by_item.html'))
}
```

`r if(report_kind == 'interactive'& do_over_time){"###### Accessions"}`
```{r  Provenance of native accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'& do_over_time}
to_do = c('items', 'accessions')
i=2

# Get the data from over_time_info.
data_wanted = NULL
wanted_item = which(grepl('prov',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
for(jj in 1:length(over_time_info)){
  info_year = over_time_info[[jj]][[wanted_item]]
  if(nrow(info_year) == 0){
    next
  }
  rows = match(wanted_order, info_year[,1])
  other = which(!info_year[,1] %in% wanted_order)
  o = c(rows,other)
  o = o[!is.na(o)]
  info_year = info_year[o,]
  prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
  info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)),
                         info_year = info_year,
                         prop = prop)
  data_wanted = rbind(data_wanted, info_year)

}
names(data_wanted) = c('year', 'Provenance', 'Items', 'prop')
data_wanted[,2] = as.character(data_wanted[,2])
# data_wanted[,2]  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(data_wanted[,2], c('G', 'U', 'W', 'Z') )]
data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))


  if(export_data){
  item_name = paste0('Provenance_of_native_plants_in_the_LC_proportion_over_time_',to_do[i])
exporting_data_store$AA = data_wanted
names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
  }


text = paste0(round(data_wanted$prop,digits=2), '% (',data_wanted$Items,' accessions) ')
data_wanted$text = text
data_wanted$Provenance = factor(data_wanted$Provenance, levels= unique(data_wanted$Provenance))
fig <- plot_ly(data_wanted, x = ~year, y = ~prop, color = ~Provenance, type = 'bar', text = ~text,
               hovertemplate = '%{text}',
               sort = FALSE, colors = colours)
fig <- fig |> layout(yaxis = list(title = 'Percentage',ticksuffix  ='%', hoverformat = '.1f' ),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text='')),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)
fig

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','native_provenance_over_time_by_accession.html'))
}
```

`r if(report_kind == 'interactive'& do_over_time){"##### {-}"}`

In the above analysis we have considered native items and accessions where provenance is unique (i.e each accession can only be in one provenance group). Next we look at provenance across taxa. In this case a taxa can be contained in the garden by multiple provenance codes (i.e. one accession of wild origin and one accession of garden origin). To visualise the provenance by taxa we use a Venn diagram visualise how taxa can be expressed by multiple provenances. 

```{r, draw provenace by taxa (venn), results='hide',fig.keep='all', message=FALSE, fig.dim=c(4,4), fig.align = 'center', eval = report_kind == 'interactive' }
grid.newpage()
grid.draw(venn_diag)
```


:::: {.blackbox data-latex=""}

Taxa with multiple provenance types can be downloaded below

```{r}
taxa_prov |>
  download_this(
    output_name = "Taxa with multiple provenances",
    output_extension = ".xlsx",
    button_label = "Download taxa with multiple provenances (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained =  T
  )
```
::::

***

### Turnover analysis

This section looks at the turnover (gain/loss) of accessions of native plants in the living collection.

`r if(!do_over_time){"As we do not have information to explore the data over time we cannot perform turnover analysis."}`

`r if(do_over_time){"We can also view the gain/loss of native accessions as a proportion of all gained/lost items each year. This will show if the incoming proportion of native plants was more or less than the proportion of native plants in the collection."}` 

```{r, Native Turnover - Accessions, eval = do_over_time}
# Start from the original_report
max_year = as.numeric(format(Sys.Date(),'%Y'))
years = min_year:max_year
report = report_original
report = report[report$AccYear > 1650 & report$AccYear<=max_year,]
report = report[!is.na(report$ItemStatusDate),]

## Convert report into accessions
unique_accessions = unique(report$AccNoFull)
LossYear = rep(NA,nrow(report))
ItemStatusYear = as.numeric(stringr::str_extract(report$ItemStatusDate,pattern = '[0-9]{4}'))
LossYear[report$ItemStatusType %in% c('NotExisting', 'Not Existing')] = ItemStatusYear[report$ItemStatusType %in% c('NotExisting', 'Not Existing')]
report$LossYear = LossYear
# Order the items where the lower indices have the most recent death date.
LossYear_dummy = LossYear
LossYear_dummy[is.na(LossYear_dummy)] = 4000
ordered_items = order(LossYear_dummy,decreasing = T)
report = report[ordered_items, ]
# Match to the ordered accessions.
match_to_best = match(unique_accessions,report$AccNoFull)
#Reduce the data to unique accessions with most recent death date.
report = report[match_to_best,]


#Get the number of accessions existing each year for whole collection/
existing_each_year_LC = as.numeric(colSums(BGSmartR::exist_at_date(date = paste0(years,'-12-31'),
                                                                   AccessionYear = as.character(report$AccYear),
                                                                   ItemStatusDate = as.character(report$ItemStatusDate),
                                                                   ItemStatusType = as.character(report$ItemStatusType),
                                                                   post_date = '3000-01-01')))
## Get the turnover for the whole collection.
overall_turnover = turnover_items(report)
exporting_data_store$overall_turnover = overall_turnover

## Get the trends for native accessions.
date = paste0(years, '-12-31')
plant_existing = BGSmartR::exist_at_date(date, AccessionYear = report$AccYear,
                                         ItemStatusDate = report$ItemStatusDate,
                                         ItemStatusType = report$ItemStatusType,
                                         post_date = '3000-01-01')
names(plant_existing) = date
trends = pbapply::pblapply(plant_existing, function(x){
  garden_current = report[x,]
  
  accessions = nrow(garden_current)
  
  breakdown_native = table(garden_current$native)
  
  return(list(accessions = accessions, breakdown_native = breakdown_native))
})
names(trends) = names(plant_existing)
trend = as.numeric(unlist(lapply(trends,function(x){
  sum(x$breakdown_native[!grepl(' ', names(x$breakdown_native))])
})))


do_type = TRUE
report_cur = report[which(report$native == 'Native'),]
if(nrow(report_cur) == 0){
  do_type = FALSE
}else{
  
  
  turnover = turnover_items(report_cur)
  exporting_data_store$turnover_native = turnover
  
  plots = plots_turnover(turnover, trend = trend, report_kind = report_kind, separate_figure_folder = separate_figure_folder, text = 'native', data_type = 'Accessions')
  
  existing_each_year = as.numeric(colSums(BGSmartR::exist_at_date(date = paste0(years,'-12-31'),
                                                                  AccessionYear = report_cur$AccYear,
                                                                  ItemStatusDate = report_cur$ItemStatusDate,
                                                                  ItemStatusType = report_cur$ItemStatusType,
                                                                  post_date = '3000-01-01')))
  collection_proportion = existing_each_year/ existing_each_year_LC
  
  plots_proportional = proportional_plots_turnover(turnover = turnover,
                                                   overall_turnover = overall_turnover,
                                                   collection_proportion = collection_proportion,
                                                   report_kind = report_kind,
                                                   separate_figure_folder = separate_figure_folder,
                                                   text = 'native',
                                                   data_type = 'Accessions')
  exporting_data_store$proportional_turnover_native_gain = plots_proportional$data_gain
  exporting_data_store$proportional_turnover_native_loss = plots_proportional$data_loss
}

# 
# #Lost items
# lost_items = data.frame(t(data.frame(lapply(years, function(year){
#   # Accessions for the year
#   have_status_year = LC_native_over_time[which(LC_native_over_time$status_year == year),]
#   # Number of items lost.
#   lost_items = have_status_year[which(have_status_year$ItemStatusType == 'NotExisting'),]
#   no_lost_items = nrow(lost_items)
#   
#   return(c(year,no_lost_items))
# }))))
# names(lost_items) = c('Year', 'Number of items')
# row.names(lost_items) = 1:nrow(lost_items)
# 
# # Gained items
# gain_items = data.frame(t(data.frame(lapply(years, function(year){
#   # Accessions for the year
#   have_accYear = LC_native_over_time[which(LC_native_over_time$AccYear == year),]
# 
#   no_gain_items = nrow(have_accYear)
#   
#   return(c(year,no_gain_items))
# }))))
# names(gain_items) = c('Year', 'Number of items')
# row.names(gain_items) = 1:nrow(gain_items)
# 
# # items
# items = data.frame(lost_items, gain_items[,2], gain_items[,2] - lost_items[,2])
# names(items) = c('Year', 'Number of lost items', 'Number of gained items', 'Net number of items')
# 
# 
# if(export_data){
#   exporting_data_store$Native_turnover_items = items
# }
# DT::datatable(items, rownames = FALSE, caption = paste0('Native turnover (items)'),
#               options = list(scrollX =  TRUE,
#                              scrollY = '70vh',
#                              pageLength =  min(nrow(items),200),
#                              columnDefs = list(list(className = 'dt-center', targets = 0:3))
#                              ),
#               escape = FALSE)
```


```{r, Native Turnover - Gain/Loss items figures,  fig.fullwidth=FALSE, fig.dim = c(10, 4), results='hide',fig.keep='all', message=FALSE, eval = report_kind == 'static' & do_over_time}
# dataA = data.frame(items[,c(1,2)], rep('Lost', nrow(items)))
# names(dataA) = LETTERS[1:3]
# dataB = data.frame(items[,c(1,3)], rep('Gain', nrow(items)))
# names(dataB) = LETTERS[1:3]
# items_data = rbind(dataA, dataB)
# 
# p = ggplot(data=items_data, aes(x=A, y=B, group=C)) +
#   geom_line(aes(color=C)) +
#     # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
#     labs(title="",
#         x ="Year",
#         y = paste0('Number of items')) +
#     guides(color=guide_legend(title=paste0('Gain/Loss'))) +
#     # theme(text = element_text(size=table_font_size)) +
#     # ggtitle(paste0("Gain/Loss of native items in the LC over time"))
#   scale_color_manual(values=c("blue", "red"))
#   print(p)
#   
#   if(separate_figure_folder){
#   ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Native_turnover_items.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
# }
# 
#   
# # Color based on value
# color <- ifelse(items$`Net number of items` < 0, "pink", "lightblue")
# 
# p = ggplot(items, aes(x = Year, y = `Net number of items`)) +
#   geom_bar(stat = "identity",
#            show.legend = FALSE,
#            fill = color,      # Background color
#            color = "white") + # Border color
#   # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
#   labs(title="",
#       x ="Year",
#       y = paste0('Number of items')) #+
#   # theme(text = element_text(size=table_font_size)) +
#   # ggtitle(paste0("Net turnover of native items in the LC over time"))
# print(p)  
# 
#   if(separate_figure_folder){
#   ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Native_net_turnover_items.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
# }
```

`r if(report_kind == 'interactive' & do_over_time){"#####  Turnover of native plants over time figures {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Net"}`
```{r  Gain/Loss of native items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
plots$trend_and_net
```

`r if(report_kind == 'interactive' & do_over_time){"###### Gain/Loss"}`
```{r  Net turnover of native items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
plots$gain_loss
```

`r if(report_kind == 'interactive' & do_over_time){"##### {-}"}`

`r if(do_over_time){"As proportion of loss/gained items each year"}`

```{r, Native Turnover - Gain/Loss items proportion figures, fig.fullwidth=TRUE, fig.dim = c(10, 4), results='hide',fig.keep='all', message=FALSE,  eval = report_kind == 'static' & do_over_time}
# ### Plot of proportion of gained items being native.
# plot_data = data.frame(year = gain_items$Year,
#                        native = gain_items$`Number of items`, 
#                        all = gain_items_all$`Number of items`)
# plot_data$prop_native = round(plot_data$native / plot_data$all *100,digits=2)
# native_counts = native_data$Items
# total_counts = LC_data$Items
# plot_data$native_LC = round(native_counts / total_counts *100,digits=2)
# 
#  p = ggplot(plot_data, aes(y=prop_native, x=year)) + 
#     geom_bar(stat="identity", width = 1, fill = 'lightblue', col = 'black') +
#    geom_point(aes(x = year, y = native_LC))+
#     # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
#     labs(title="",
#         x ="Year",
#         y = "Native Percentage (%)") +
#     guides(fill=guide_legend(title=paste0('Provenance'))) +
#     # theme(text = element_text(size=table_font_size)) +
#     # ggtitle(paste0("Proportion of gained items that are native in the LC over time"))
#       labs(caption = "Black points are proportion of items in the LC that are native each year.")
#   print(p)
#   
#       if(separate_figure_folder){
#   ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Native_gain_items_proportion.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
#     }
#   
# ### Plot of proportion of lost items being native.
# 
# plot_data = data.frame(year = lost_items$Year,
#                        native = lost_items$`Number of items`, 
#                        all = lost_items_all$`Number of items`)
# plot_data$prop_native = round(plot_data$native / plot_data$all *100,digits=2)
# native_counts = native_data$Items
# total_counts = LC_data$Items
# plot_data$native_LC = round(native_counts / total_counts *100,digits=2)
# 
#  p = ggplot(plot_data, aes(y=prop_native, x=year)) + 
#     geom_bar(stat="identity", width = 1, fill = 'pink', col = 'black') +
#    geom_point(aes(x = year, y = native_LC))+
#     # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
#     labs(title="",
#         x ="Year",
#         y = "Native Percentage (%)") +
#     guides(fill=guide_legend(title=paste0('Provenance'))) +
#     # theme(text = element_text(size=table_font_size)) +
#     # ggtitle(paste0("Proportion of lost items that are native in the LC over time"))
#       labs(caption = "Black points are proportion of items in the LC that are native each year.")
#   print(p)
# 
#         if(separate_figure_folder){
#   ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Native_loss_items_proportion.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
#     }
```

`r if(report_kind == 'interactive' & do_over_time){"#####  Turnover of native plants over time figures (proportion) {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Gain"}`
```{r  Gain proportion of native items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
plots_proportional$gain
```

`r if(report_kind == 'interactive' & do_over_time){"###### Loss"}`
```{r  Loss proportion of native items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
plots_proportional$loss
```

`r if(report_kind == 'interactive'& do_over_time){"##### {-}"}`

***

### Survival analysis 

```{r, survival analysis, echo = FALSE}
# Remove those without accession year.
do_survival = TRUE
if(!do_over_time){
  do_survival = FALSE
}

if(!is.null(old_accession_year_codes)){
  has_old_accessions_code = which(enriched_report$AccYear %in% old_accession_year_codes)
  no_old_accessions = length(has_old_accessions_code)
  enriched_report$AccYear[has_old_accessions_code] = earliest_allowable_record
}

enriched_report_wanted = enriched_report[as.numeric(enriched_report$AccYear) > 1650 & as.numeric(enriched_report$AccYear) < as.numeric(format(Sys.Date(),'%Y')),]
enriched_report_wanted = enriched_report_wanted[!is.na(enriched_report_wanted$ItemStatusDate),]
enriched_report_wanted = enriched_report_wanted[!is.na(enriched_report_wanted$AccYear),]

# Create a data-frame of the information we want.
wanted_data = data.frame(enriched_report_wanted$TaxonNameFull, enriched_report_wanted$AccYear, enriched_report_wanted$ItemStatusDate, enriched_report_wanted$ItemStatusType)
names(wanted_data) = c('TaxonNameFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType')

if(nrow(wanted_data) == 0){
  do_survival = FALSE
}
if(do_survival){
  #Set accession date (just chose the first of June)
pre_date = rep(NA, length(wanted_data$AccYear))
pre_date = paste(wanted_data$AccYear, "06", "01", sep = "-")

# Convert ItemStatusDate into all dates (i.e if month or day missing add one)
post_date = rep(as.character(Sys.Date()), length(wanted_data$AccYear))
post_date[which(wanted_data$ItemStatusType == "NotExisting")] = as.character(wanted_data$ItemStatusDate[which(wanted_data$ItemStatusType == 
  "NotExisting")])

post_date[which(stringr::str_length(post_date) == 4)] = paste(post_date[which(stringr::str_length(post_date) == 
  4)], "12", "28", sep = "-")
post_date[which(stringr::str_length(post_date) == 7)] = paste(post_date[which(stringr::str_length(post_date) == 
  7)], "28", sep = "-")

# Create the time difference between accession and ItemStatusDate.
time = as.numeric(as.Date(post_date) - as.Date(pre_date)) /365.25

# Create status to tell whether the last item status date was item death or just a check.
status = rep(0,length(wanted_data$AccYear))
status[wanted_data$ItemStatusType == 'NotExisting'] = 1

wanted_data = data.frame(wanted_data, AccessionDate = pre_date,
                         StatusDate = post_date,
                         time = time,
                         Alive_dead = status)


# We haven't removed those with missing ItemStatusDate, these will most likely have negative time so remove these.
missing_itemstatusdate_index = which(wanted_data$time > 0)
status_year = wanted_data$ItemStatusDate |> stringr::str_extract('^[0-9]{4}') |> unlist() |> as.numeric()
status_before_current_year = which(status_year <= format(Sys.Date(),'%Y') |> as.numeric() )
to_keep = intersect(missing_itemstatusdate_index,status_before_current_year)
wanted_data = wanted_data[to_keep,]

enriched_report_wanted = enriched_report_wanted[to_keep,]

## 1) Native or non-native (or doesn't have geography info.)
location = location_code
#Get which records are native.
native_non_native = rep('Not Native',nrow(enriched_report_wanted))
native_non_native[which(enriched_report_wanted$POWO_plant_name_id %in% native_plant_ids)] = 'Native'
native_non_native[is.na(enriched_report_wanted$POWO_Dist_000_area_code_l3)] = NA

data_to_analyse = data.frame(wanted_data$TaxonNameFull,
                             wanted_data$time,
                             wanted_data$Alive_dead,
                             native_non_native)
names(data_to_analyse) = c("TaxonNameFull", "time", "Alive_dead", "native_status")

if(export_data){
  exporting_data_store$Data_for_survival = data_to_analyse
}
}

```

In this section, we look at whether the survival period of native plants is longer than non-native plants. 

<!-- Note that plants can be long-lived and most collections will have plants that are older than the collection itself. Therefore, we need to lean into tools from statistics to analyse the lifespan of plants in a collection. Herein, we use survival analysis to calculate the probability that plants will survive for any number of years.  -->

`r if(FALSE){"Note that \"lifespan\" may be a preferable way to describe this section, however we use survival because accessioned plants may arrive in the garden already a few years old. As we will be using the accession date and item status date to determine the length of time plants have been in the collection this might not align perfectly with the age of the plant. Moreover, it is important to be aware that the data used in the analysis is not \"perfect\" in the sense that plants might have already died a large period of time prior to an audit, moreover this analysis doesn't account for circumstances of plant death which could be natural, or for renovation of a section of the garden, etc. "}`

<!-- In the following analysis, we assume that existing items are still existing to the present day. Therefore, even if the last item status date was a year ago if the plant was found to be existing then we assume it is still existing now. (I could change this to just use alive at Item status date, it won't make much difference. ) -->

<!-- Since we only have the accession year we set the accession date to be the middle of the year (1st June). -->

<!-- Native plants are any that are from `r paste0(location_name, collapse = ', ')`, non-native plants are plants that have geographic information (matched to WCVP) but are not from `r paste0(location_name, collapse = ', ')`. This means that we exclude plants not matched to WCVP for the comparison (cultivars, etc).  -->
 
`r if(do_survival){"Below we present a survival plot (Kaplan-Meier) to show how survival probability changes over time."}`

`r if(!do_survival){"Survival analysis cannot be performed. (This could be due to lack of accession year or item status date."}`

```{r, survival analysis - figure, echo  = FALSE, fig.fullwidth=TRUE, fig.dim = c(10, 6), results='hide',fig.keep='all', message=FALSE, eval = do_survival}
# Create Kaplan-Meier plots comparing native and not native
fit = ggsurvfit::survfit2(survival::Surv(time, Alive_dead) ~ native_status, data = data_to_analyse)

p = fit |> 
  ggsurvfit::ggsurvfit() +
  ggplot2::labs(
    x = "Years",
    y = "Overall survival probability"
  ) + 
  ggsurvfit::add_confidence_interval()+
    # theme(text = element_text(size=table_font_size))+
  # labs(title=paste0("Survival probability of native and non native plants in the LC")) +
  labs(caption = "Shaded region represents 95% confidence interval.") +
  scale_colour_manual(values = c('#f46d43', '#848484')) +
  scale_fill_manual(values = c('#f46d43', '#848484')) +
   theme(
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text=element_text(size=10))


if(report_kind == 'static'){
  if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','native_notnative_survival.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
  }
  p
} 
```

```{r survival_analysis - interactive figure, eval = do_survival, fig.dim = c(10, 4)}
if(report_kind == 'interactive'){
  
  fig = ggplotly(p,dynamicTicks = TRUE)
  fig$x$layout$title$text =''
  fig$x$layout$legend$title$text = ''
  fig$x$layout$hovermode = 'x unified'
  fig$x$data[[2]]$name = 'Non-native'
  fig$x$data[[2]]$legendgroup = 'Non-native'
  fig$x$data[[1]]$name = 'Native'
  fig$x$data[[1]]$legendgroup = 'Native'
  fig$x$data[[4]]$hoverinfo = 'none'
  fig$x$data[[3]]$hoverinfo = 'none'
  
  time_region = round(fig$x$data[[4]]$text |>
    stringr::str_extract(pattern = 'time:[ ]+[0-9\\.]+') |>
    stringr::str_extract(pattern = '[0-9]+\\.[0-9]+') |>
    as.numeric(), digits = 3) 
  lower_region = round(fig$x$data[[4]]$text |>
    stringr::str_extract(pattern = 'conf.low: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100,digits = 2)
  upper_region = round(fig$x$data[[4]]$text |>
    stringr::str_extract(pattern = 'conf.high: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100, digits = 2)
  time = round(fig$x$data[[2]]$x,digits = 3)
  lower = lower_region[match(time, time_region)]
  upper = upper_region[match(time, time_region)]
  
  fig$x$data[[2]]$text = paste0(#'Age (years): ',round(fig$x$data[[2]]$x,digits = ), '<br>',
                                'Survival probability: ', round(fig$x$data[[2]]$y*100,digits = 2),'% <br>',
                                '95% confidence Interval: (', lower,'%, ', upper, '%)')
  
    time_region = round(fig$x$data[[3]]$text |>
    stringr::str_extract(pattern = 'time:[ ]+[0-9\\.]+') |>
    stringr::str_extract(pattern = '[0-9]+\\.[0-9]+') |>
    as.numeric(), digits = 3) 
  lower_region = round(fig$x$data[[3]]$text |>
    stringr::str_extract(pattern = 'conf.low: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100,digits = 2)
  upper_region = round(fig$x$data[[3]]$text |>
    stringr::str_extract(pattern = 'conf.high: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100, digits = 2)
  time = round(fig$x$data[[1]]$x,digits = 3)
  lower = lower_region[match(time, time_region)]
  upper = upper_region[match(time, time_region)]
  
  fig$x$data[[1]]$text = paste0('Age (years): ',round(fig$x$data[[1]]$x,digits = ), '<br>',
                                'Survival probability: ', round(fig$x$data[[1]]$y*100,digits = 2),'% <br>',
                                '95% confidence Interval: (', lower,'%, ', upper, '%)')
  
  #Set initial y-axis tick values 
  fig$x$layout$yaxis$ticktext = c("0.25", "0.50", "0.75", "1.00")
  fig$x$layout$yaxis$tickvals = c(0.25, 0.50, 0.75, 1.00)
  fig$x$layout$font$size = 10 # font size
  fig$x$layout$yaxis$title$font$size = 14
  fig$x$layout$xaxis$title$font$size = 14
  fig$x$layout$xaxis$title$font$color = NULL
   fig$x$layout$yaxis$title$font$color = NULL
  fig$x$layout$yaxis$tickfont$size = 12
  fig$x$layout$xaxis$tickfont$size = 12
  
  
  # fig = fig |> layout(legend = list(orientation = 'h'))
  if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Native_survival_analysis.html'))
}

fig
}
```

`r if(do_survival){"Below we give the median surivival times for native and non-native plants in the collection, and the survival probability for a given number of years."}`

```{r, survival analysis - median survival tables, echo = FALSE, message=FALSE, eval = do_survival}
# We can also get survival probabilities in a table
# 

table_data2 = fit |> 
  gtsummary::tbl_survfit(
    probs = c(0.5),
    label_header = "**Median survival (95% CI)**")

table_data2 = table_data2$table_body
table_data2 = table_data2[,-c(1:4)]
table_data2 = table_data2[-1,]
names(table_data2) = c('Characteristic', 'Median survival + 95% CI (Years)')
table_data2$Characteristic[table_data2$Characteristic == 'Not Native'] = 'Non-native'
table_data2 |>  DT::datatable(extensions = 'Buttons',
                             rownames = FALSE,
                             options = list(scrollX = TRUE,
                                            pageLength = nrow(table_data2),
                                            dom = 'Bt',
                                            buttons = c('copy', 'csv', 'excel', 'pdf'),
                                            paging=FALSE,
                                            ordering=F))


```


```{r, survival analysis - tables, echo = FALSE, message=FALSE, eval = do_survival}
# We can also get survival probabilities in a table
# 
table_data = fit |> 
  gtsummary::tbl_survfit(
    times = c(2,5,10,25,50,100),
    label_header = "{time}-year survival (95% CI)")

table_data = table_data$table_body
  table_data = table_data[,-c(1:4)]
  table_data = table_data[-1,]
  names(table_data) = c('Status', '2-year survival (95% CI)',
                        '5-year survival (95% CI)',
                        '10-year survival (95% CI)',
                        '25-year survival (95% CI)',
                        '50-year survival (95% CI)',
                        '100-year survival (95% CI)')
  table_data = data.frame(t(table_data))
  table_data = table_data[-1,]
  names(table_data) = c('Native', 'Non-native')
  
  
  table_data2 = fit |> 
  gtsummary::tbl_survfit(
    probs = c(0.5),
    label_header = "**Median survival (95% CI)**")

table_data2 = table_data2$table_body
  table_data2 = table_data2[,-c(1:4)]
  table_data2 = table_data2[-1,]
  names(table_data2) = c('Characteristic', 'Median survival (95% CI)')
  
  
  
if(report_kind == 'static'){
  table_data |>
  flextable() |>
  set_caption(caption = paste0('Survival probability table')) |> 
  font(fontname = "Calibri (Body)", part = "all") |> 
  fontsize(size = table_font_size, part = "body") |> 
  # add footer if you want
  # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
  #                colwidths = 4) |> 
  theme_booktabs() |> # default theme
  autofit() |>
  set_table_properties(width = 1, layout = "autofit")
}
if(report_kind == 'interactive'){
  table_data$year  =paste0(c(2,5,10,25,50,100), '-year survival')
  names(table_data)[3] = 'Survival time'
  table_data = table_data[,c(3,1,2)]
  table_data |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = nrow(table_data),
                                 dom = 'Bt',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=FALSE,
                                 ordering=F))

}
```

***

### Endemic and threatened native species

```{r, Among the native plants in a LC, how many of them are endemic or redlisted - Data}
# LC_native_exisiting, native and existing part of LC database.
endemic = rep(FALSE, nrow(LC_native_exisiting))
endemic[which(stringr::str_length(LC_native_exisiting$geography_codes) == 3)] = TRUE
total_endemic = sum(endemic)

threatened = rep(FALSE, nrow(LC_native_exisiting))
threatened[which(LC_native_exisiting$POWO_Red_category %in% c('EN', 'VU', 'CR', 'EW', 'EX'))] = TRUE
threatened[which(LC_native_exisiting$redList_category %in% c('EN', 'VU', 'CR', 'EW', 'EX'))] = TRUE
total_threatened = sum(threatened)

# interest = LC_native_exisiting[which(endemic|threatened),]
# BB = interest[c('TaxonNameFull', 'endemic', 'threatened', 'geography_codes')]
total_threat_endemic = sum(endemic & threatened)
need_venn = total_endemic > 0 | total_threatened > 0
overlap = FALSE
if(total_threat_endemic > 0){
  overlap = TRUE
}
```

`r if(need_venn){paste0("In this section, we concentrate on native plants in the living collection that are either endemic to ", paste0(location_name, collapse = ', ') ," or on IUCN's Red List.")}`

`r if(overlap & need_venn){paste0("Within the native plant collection of ", collection, " there are ", total_endemic, " endemic items and ", total_threatened, " threatened items, where ", total_threat_endemic, " are both. Therefore, ",round(total_endemic/nrow(LC_native_exisiting)*100,digits = 2), "% of the native items are endemic and ",round(total_threatened/nrow(LC_native_exisiting)*100,digits = 2),"% are threatened.")}`

`r if((!overlap) & need_venn){paste0("Withn the native sub-collection of ", collection, " there are ", total_endemic, " endemic items and ", total_threatened, " threatened items. No items are both endemic and threatened."," Therefore, ",round(total_endemic/nrow(LC_native_exisiting)*100,digits = 2), "% of the native items are endemic and ",round(total_threatened/nrow(LC_native_exisiting)*100,digits = 2),"% are threatened.")}`

`r if(!need_venn){"There are no endemic or threatened plants that are native in the LC."}`


```{r, Among the native plants in a LC, how many of them are endemic or redlisted - Venn Diagram, echo = FALSE, results='hide',fig.keep='all', message=FALSE}
if(FALSE){
  library("VennDiagram") 

# move to new plotting page 
grid.newpage() 

# create pairwise Venn diagram 
# draw.pairwise.venn(area1=total_endemic, area2=total_threatened,cross.area=total_threat_endemic, 
#                    category=c("Endemic","Threatened"),fill=c("Yellow", "Red"))

draw.pairwise.venn(
  area1 = total_endemic,
  area2 = total_threatened,
  cross.area = total_threat_endemic,
  category = c("Endemic","Threatened"),
  col=c("#440154ff", '#21908dff'),
  fill = c(alpha("#440154ff",0.3), alpha('#21908dff',0.3)),
  cex = 1.1,
  cat.cex = 1.3,
  cat.default.pos = "outer",
  cat.pos = c(0, 0),
  cat.dist = 0.055,
  # cat.just = list(c(-1, -1), c(1, 1)), ext.pos = 30,
  # ext.dist = -0.05,
  # ext.length = 0.85,
  # ext.line.lwd = 2,
  # ext.line.lty = "dashed",
  scaled = TRUE,
  lwd = c(1,1),
  lty = c(1,1)
)

      if(separate_figure_folder){
ggplot2::ggsave(filename = paste0(figures_dir, '/','Native_threatened_endemic_Venn_diagram.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
}

```


`r if(need_venn){"For these native and endemic/threatened plants we produce a table below detailing how many items of each species are in the collection together with the accession number and when each item was last checked."}`

```{r, Among the native plants in a LC, how many of them are endemic or redlisted - get important taxa, ft.keepnext = FALSE, eval = need_venn}
if('ItemAccNoFull' %in% names(LC_native_exisiting)){
  acc_item = LC_native_exisiting$ItemAccNoFull
}else{
  acc_item = LC_native_exisiting$AccNoFull
}
accessions = LC_native_exisiting$AccNoFull
taxa = paste0(LC_native_exisiting$POWO_taxon_name, ' ', LC_native_exisiting$POWO_taxon_authors)
ItemStatusDate = LC_native_exisiting$ItemStatusDate

data = data.frame(accessions =accessions, 
                  taxa = taxa,
                  ItemStatusDate = ItemStatusDate, 
                  endemic = endemic, 
                  threatened = threatened,
                  acc_item = acc_item)
data_compressed <- data |>
  dplyr::group_by(.data$taxa) |>
  dplyr::summarise(endemic = .data$endemic[1],
                   threatened = .data$threatened[1],
                   ItemStatusDates = toString(.data$ItemStatusDate),
                   Accessions = toString(unique(.data$accessions)),
                   Items = length(.data$ItemStatusDate)
                   
  ) |>
  dplyr::ungroup()

data_compressed = data_compressed[data_compressed$endemic | data_compressed$threatened,]

endemic_val = rep('No', nrow(data_compressed))
endemic_val[data_compressed$endemic] = 'Yes'
data_compressed$endemic = endemic_val

threat_val = rep('No', nrow(data_compressed))
threat_val[data_compressed$threatened] = 'Yes'
data_compressed$threatened = threat_val
 names(data_compressed) = c("Taxa", "Endemic", "Threatened", "Item Status Dates", "Accession IDs", "Number of items" )

if(export_data){
  exporting_data_store$Detail_threatened_and_endemic_native_plants_in_LC = data.frame(data_compressed)
}

# MANAGEMENT SHEET: native plants that are native and either endemic or threatened.
if(export_data){
  writexl::write_xlsx(data_compressed, path =paste0(output_dir,'/',collection,'_native_and_either_endemic_or_threatened_list.xlsx'))

}


```

```{r, Among the native plants in a LC, how many of them are endemic or redlisted - table, ft.keepnext = FALSE, eval = need_venn}
if(report_kind == 'static'){
  data_compressed |>
  flextable() |>
  set_caption(caption = paste0('Endemic and threatened plants in the native sub-collection')) |> 
  font(fontname = "Calibri (Body)", part = "all") |> 
  fontsize(size = table_font_size, part = "body") |> 
  # add footer if you want
  # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
  #                colwidths = 4) |> 
  theme_booktabs() |> # default theme
  autofit() |>
  set_table_properties(width = 1, layout = "autofit")
}
if(report_kind == 'interactive'){
  data_compressed |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(data_compressed), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=T,
                                 ordering=T),
                  filter = list(position = "top"))

}

```

```{r check for data to save}
data_save = data
data_save = data_save[which(data_save$endemic | data_save$threatened),]

do_data_save = nrow(data_save)>0
```


`r if(do_data_save){':::: {.blackbox data-latex=""}'}`

`r if(do_data_save){"For further information you can download the endemic/threatened native plants using the button below."}`

```{r link to download  threatened/endemic native plants, eval = report_kind == 'interactive' & do_data_save}

data_save = data_save[order(data_save$taxa),]

endemic_val = rep('No', nrow(data_save))
endemic_val[data_save$endemic] = 'Yes'
data_save$endemic = endemic_val

threat_val = rep('No', nrow(data_save))
threat_val[data_save$threatened] = 'Yes'
data_save$threatened = threat_val
data_save = data_save[,c(6,2:5)]
names(data_save) = c("Accession + Item Number", "Taxonomic Name", "ItemStatusDate","Is endemic?", "Is Threatened?")


data_save |>
  download_this(
    output_name = "Endemic or threatened Native plants in the LC",
    output_extension = ".xlsx",
    button_label = "Download native endemic/threatened plants (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained =  T
  )

```

`r if(do_data_save){'::::'}`



***

#### Threatened native plants by risk level

In this section we are exploring the threatened, native plants in the collection. We shall do this in two parts: existing plants in the living collection and how this has changed over time.

```{r,  Threatened, native plants in the LC - data}
# LC_native_exisiting
# 
redlistcatA = LC_native_exisiting$redList_category
redlistcatB = LC_native_exisiting$POWO_Red_category

redlist_used = rep(NA, nrow(LC_native_exisiting))
redlist_used[redlistcatA == 'VU' | redlistcatB == 'VU'] = 'VU'
redlist_used[redlistcatA == 'EN' | redlistcatB == 'EN'] = 'EN'
redlist_used[redlistcatA == 'CR' | redlistcatB == 'CR'] = 'CR'
redlist_used[redlistcatA == 'EW' | redlistcatB == 'EW'] = 'EW'
redlist_used[redlistcatA == 'EX' | redlistcatB == 'EX'] = 'EX'

LC_native_exisiting$redlist_used = redlist_used

redlistcat_items = data.frame(table(LC_native_exisiting$redlist_used))
if(nrow(redlistcat_items) == 0){
  redlistcat_items = data.frame(matrix(ncol = 2, nrow = 0))
}
names(redlistcat_items) = c('RedListCategory', 'Items')
redlistcat_items$RedListCategory = as.character(redlistcat_items$RedListCategory)
redlistcat_items$RedListCategory  = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')[match(redlistcat_items$RedListCategory, c('VU', 'EN', 'CR', 'EW', 'EX'))] 

if(nrow(redlistcat_items) > 0){
redlistcat_items$percent = paste0(round(redlistcat_items$Items / sum(redlistcat_items$Items)*100,digits = 1),'%')
redlistcat_items <- redlistcat_items %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Items))), 
         pos = Items/2 + dplyr::lead(csum, 1),
         pos = dplyr::if_else(is.na(pos), Items/2, pos))
}

LC_native_exisiting_redlist = LC_native_exisiting[LC_native_exisiting$redlist_used %in% c('VU', 'EN', 'CR', 'EW', 'EX'),]

redlistcat_accessions = data.frame(table(LC_native_exisiting_redlist$redlist_used[match(unique(LC_native_exisiting_redlist$AccNoFull), LC_native_exisiting_redlist$AccNoFull)]))
if(nrow(redlistcat_accessions) == 0){
  redlistcat_accessions = data.frame(matrix(ncol = 2, nrow = 0))
}
names(redlistcat_accessions) = c('RedListCategory', 'Accessions')
redlistcat_items$RedListCategory = as.character(redlistcat_items$RedListCategory)
redlistcat_accessions$RedListCategory  = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')[match(redlistcat_accessions$RedListCategory, c('VU', 'EN', 'CR', 'EW', 'EX'))]  

if(nrow(redlistcat_accessions) > 0){
redlistcat_accessions$percent = paste0(round(redlistcat_accessions$Accessions / sum(redlistcat_accessions$Accessions)*100,digits = 1),'%')
redlistcat_accessions <- redlistcat_accessions %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Accessions))), 
         pos = Accessions/2 + dplyr::lead(csum, 1),
         pos = dplyr::if_else(is.na(pos), Accessions/2, pos))
}

if(nrow(redlistcat_items) > 0){
  flex_data = data.frame(redlistcat_items$RedListCategory,
                       redlistcat_items$Items, 
                       paste0(round(redlistcat_items$Items/sum(redlistcat_items$Items)*100,digits=2),'%'),
                       redlistcat_accessions$Accessions,
                       paste0(round(redlistcat_accessions$Accessions/sum(redlistcat_accessions$Accessions)*100,digits=2),'%'))
}else{
  flex_data = data.frame(matrix(ncol = 5, nrow = 0))
}
names(flex_data) = c('Red List Category', 'Number of items', 'Proportion of items', 'Number of accessions', 'Proportion of accessions')

have_redlist = eval = nrow(flex_data)>0
if(export_data){
  exporting_data_store$Threatened_category_of_existing_native_plants_in_the_LC = flex_data
}
```

`r if(!have_redlist){"The living collection does not contain any theatened native plants."}`


```{r,  Threatened, native, existing plants in the LC - static pie charts, echo = FALSE, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'static' & have_redlist}
if(nrow(flex_data) > 0){
  # Basic piechart
pie1 = ggplot(redlistcat_items, aes(x="", y=Items, fill=RedListCategory)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtitle('Items') +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

pie2 = ggplot(redlistcat_accessions, aes(x="", y=Accessions, fill=RedListCategory)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtitle('Accessions') +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

    if(value_on_fig){
      pie1 = pie1 + geom_label_repel(aes(y = pos,label = percent),
                   size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white")   
      
      pie2 = pie2 + geom_label_repel(aes(y = pos,label = percent),
                   size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white") 
  }

p = ggpubr::ggarrange(pie1, pie2, ncol=2, nrow=1, common.legend = TRUE, legend="bottom",
                  font.label = list(size = table_font_size))

    if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','native_threatened.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}
p
}

```

`r if(report_kind == 'interactive' & have_redlist){"#####  Threatened category of native taxa in the living collection {.tabset}"}`

`r if(report_kind == 'interactive' & have_redlist){"###### Chart"}`
```{r  Threatened Category of existing native items in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'& have_redlist}
figs = list()

   endangered_cat =  c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')
  endangered_cat_order = endangered_cat[which(!is.na(match(endangered_cat, redlistcat_accessions$RedListCategory)))]
  redlistcat_accessions$RedListCategory = factor(redlistcat_accessions$RedListCategory, levels = endangered_cat_order)
  redlistcat_accessions = redlistcat_accessions[order(redlistcat_accessions$RedListCategory),]

  endangered_cat_order = endangered_cat[which(!is.na(match(endangered_cat, redlistcat_items$RedListCategory)))]
  redlistcat_items$RedListCategory = factor(redlistcat_items$RedListCategory, levels = endangered_cat_order)
  redlistcat_items = redlistcat_items[order(redlistcat_items$RedListCategory),]
 

# Items
text = paste0(redlistcat_items$Items, ' native items with red list category "', redlistcat_items$RedListCategory, '"')
fig1 <- plot_ly(redlistcat_items, labels = ~RedListCategory, values = ~Items, hoverinfo = "text",  hovertext = text, sort = FALSE)
fig1 <- fig1 %>% add_pie(hole = 0.6)
fig1 <- fig1 %>% layout(title = "Items",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))

figs$items = fig1
#Accessions
text = paste0(redlistcat_accessions$Accessions, ' native accessions with red list category "', redlistcat_accessions$RedListCategory, '"')
             
fig2 <- plot_ly(redlistcat_accessions, labels = ~RedListCategory, values = ~Accessions, hoverinfo = "text",  hovertext = text, sort = FALSE)
fig2 <- fig2 %>% add_pie(hole = 0.6)
fig2 <- fig2 %>% layout(title = "Accessions",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))

figs$accessions = fig2
colo = scales::brewer_pal(palette = palette, direction = 1)(5)
names(colo) = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')
# colo = c("Vulnerable" = rgb(242,141,60, max = 255),
#          "Endangered" = rgb(238,81,53, max = 255),
#          "Critically Endangered" = rgb(129,27,39, max = 255),
#          "Extinct in the Wild" = rgb(88,88,88, max = 255)
#          )
colo = colo[match(redlistcat_items$RedListCategory, names(colo))]
# Together
p <- plot_ly() |>
  add_pie(data = redlistcat_items, labels = ~RedListCategory, values = ~Items, hole = 0.6,
          title = "Items", name ='', sort = FALSE, marker = list(colors = colo),
          domain = list(row = 0, column = 0)) |>
  add_pie(data = redlistcat_accessions, labels = ~RedListCategory, values = ~Accessions, hole = 0.6,
          title = "Accessions", name ='', sort = FALSE, marker = list(colors = colo),
         domain = list(row = 0, column = 1))  |>
  layout(title = "", showlegend = TRUE,
          grid=list(rows=1, columns=2),
         plot_bgcolor="#f0f0f0",
         legend = list(orientation = 'h', xanchor = "center", x = 0.5),
         xaxis = list(title=paste0('Items', 'Accessions'), showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         margin = c(0,0,0,0))


if(separate_figure_folder){
  htmlwidgets::saveWidget(figs$items, file = paste0(figures_dir, '/','native_threatened_cat_existing_items.html'))
  htmlwidgets::saveWidget(figs$accessions, file = paste0(figures_dir, '/','native_threatened_cat_existing_accessions.html'))
}

p

```

`r if(report_kind == 'interactive' & have_redlist){"###### Table"}`

```{r, Threatened, native plants in the LC - table, eval = have_redlist}
if(report_kind == 'static'){
  flex_data |>
  flextable() |>
  set_caption(caption = paste0('Threatened category of existing native plants in the LC')) |> 
  font(fontname = "Calibri (Body)", part = "all") |> 
  fontsize(size = table_font_size, part = "body") |> 
  # add footer if you want
  # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
  #                colwidths = 4) |> 
  theme_booktabs() |> # default theme
  separate_header() |> 
  align(align = "center", part = "all") |>
  autofit()
}
if(report_kind == 'interactive'){
flex_data |> DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(10,nrow(flex_data)),
                                 dom = 'Bt',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=FALSE,
                                 ordering=F))
}


```

`r if(report_kind == 'interactive'){"##### {-}"}`

`r if(have_redlist & do_over_time){""}`

`r if(!do_over_time){"We do not have the information to explore how hreatened categories of native plants in the LC has changed over time."}`

```{r, Threatened, native plants in the LC - data over time, fig.fullwidth=FALSE, fig.dim = c(10, 6), eval = do_over_time}
# LC_native_over_time contains the over time native plants.
redlistcatA = LC_native_over_time$redList_category
redlistcatB = LC_native_over_time$POWO_Red_category

redlist_used = rep(NA, nrow(LC_native_over_time))
redlist_used[redlistcatA == 'VU' | redlistcatB == 'VU'] = 'VU'
redlist_used[redlistcatA == 'EN' | redlistcatB == 'EN'] = 'EN'
redlist_used[redlistcatA == 'CR' | redlistcatB == 'CR'] = 'CR'
redlist_used[redlistcatA == 'EW' | redlistcatB == 'EW'] = 'EW'
redlist_used[redlistcatA == 'EX' | redlistcatB == 'EX'] = 'EX'

LC_native_over_time$redlist_used = redlist_used

# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing_LC_native, function(x){
  garden_current = LC_native_over_time[x,]
  redlistcat_items = data.frame(table(garden_current$redlist_used))
  if(ncol(redlistcat_items) != 2){redlistcat_items = data.frame(matrix(ncol = 2, nrow = 0))}
  names(redlistcat_items) = c('RedListCategory', 'Items')
  
  redlistcat_accessions = data.frame(table(garden_current$redlist_used[match(unique(garden_current$AccNoFull), garden_current$AccNoFull)]))
  if(ncol(redlistcat_accessions) != 2){redlistcat_accessions = data.frame(matrix(ncol = 2, nrow = 0))}
  
  names(redlistcat_accessions) = c('RedListCategory', 'Accessions')
  
  taxa = paste0(garden_current$POWO_taxon_name, ' ', garden_current$POWO_taxon_authors)
  redlistcat_taxa = data.frame(table(garden_current$redlist_used[match(unique(taxa), taxa)]))
  if(ncol(redlistcat_taxa) != 2){redlistcat_taxa = data.frame(matrix(ncol = 2, nrow = 0))}
  
  names(redlistcat_taxa) = c('RedListCategory', 'Accessions')
  
  
  return(list(redlistcat_items = redlistcat_items,
              redlistcat_accessions = redlistcat_accessions,
              redlistcat_taxa = redlistcat_taxa))
})


```

```{r, Threatened, native plants in the LC - static proportion over time, fig.fullwidth=FALSE, fig.dim = c(10, 6), eval = report_kind == 'static' & have_redlist & do_over_time}
to_do = c('items', 'accessions')
if(nrow(flex_data) > 0){
for(i in 1:length(to_do)){
  # Get the data from over_time_info.
  data_wanted = NULL
  wanted_item = which(grepl('redlistcat',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
  for(jj in 1:length(over_time_info)){
    info_year = over_time_info[[jj]][[wanted_item]]
     if(nrow(info_year) == 0){
      next
    }
    prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
    info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)), info_year, prop = prop)
    data_wanted = rbind(data_wanted, info_year)
  }
 data_wanted[,2]  = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')[match(data_wanted[,2], c('VU', 'EN', 'CR', 'EW', 'EX'))]  
  data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))
  
  if(export_data){
    item_name = paste0('Threatened_native_plants_in_the_LC_proportion_over_time_',to_do[i])
  exporting_data_store$AA = data_wanted
  names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
}
  
    p = ggplot(data_wanted, aes(fill=RedListCategory, y=prop, x=year)) + 
    geom_bar(position="stack", stat="identity", width = 1) +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title="",
        x ="Year",
        y = "Percentage (%)") +
    guides(fill=guide_legend(title=paste0('RedList Category')))# +
    # theme(text = element_text(size=table_font_size)) +
    # ggtitle(paste0("RedList Category of ", to_do[i] , " that are native in the LC over time"))
    
    if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Native_threatened_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}
  print(p)

}
}
```

`r if(report_kind == 'static' &  have_redlist & do_over_time){"Note that there might not be many threatened native plants. Therefore, we also include line graphs of the number of each threatened category in the LC."}`

```{r, Threatened, native plants in the LC - number over time, fig.fullwidth=FALSE, fig.dim = c(10, 6), eval = report_kind == 'static' & have_redlist & do_over_time}
to_do = c('items', 'accessions', 'taxa')
if(nrow(flex_data) > 0){
for(i in 1:length(to_do)){
  # Get the data from over_time_info.
  data_wanted = NULL
  wanted_item = which(grepl('redlistcat',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
  for(jj in 1:length(over_time_info)){
    info_year = over_time_info[[jj]][[wanted_item]]
     if(nrow(info_year) == 0){
      next
    }
    prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
    info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)), info_year, prop = prop)
    data_wanted = rbind(data_wanted, info_year)
  }
 data_wanted[,2]  = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')[match(data_wanted[,2], c('VU', 'EN', 'CR', 'EW', 'EX'))]  
  data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))
  
  
  # Create plot.
  p = ggplot(data=data_wanted, aes(x=year, y=data_wanted[,3], group=RedListCategory)) +
  geom_line(aes(color=RedListCategory)) +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title="",
        x ="Year",
        y = paste0('Number of ',to_do[i])) +
    guides(color=guide_legend(title=paste0('RedList Category'))) #+
    # theme(text = element_text(size=table_font_size)) +
    # ggtitle(paste0("RedList Category of ", to_do[i] , " that are native in the LC over time"))
  
      if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Number_of_threatened_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
      }
  
  print(p)
}
}
```


`r if(report_kind == 'static' & have_redlist & do_over_time){"We do this in two ways, looking at the number of plants in each threatened category ove time and the proportion if each threatened cateogory over all threatened taxa."}`

`r if(report_kind == 'interactive' & have_redlist & do_over_time){"#####  Threatened plants over time graphs {.tabset}"}`

`r if(report_kind == 'interactive' & have_redlist & do_over_time){"###### Items (Number)"}`
```{r  Number of threatened native items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}

i=1
to_do = c('items', 'accessions', 'taxa')
if(nrow(flex_data) > 0){

  # Get the data from over_time_info.
  data_wanted = NULL
  wanted_item = which(grepl('redlistcat',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
  for(jj in 1:length(over_time_info)){
    info_year = over_time_info[[jj]][[wanted_item]]
     if(nrow(info_year) == 0){
      next
    }
    prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
    info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)), info_year, prop = prop)
    data_wanted = rbind(data_wanted, info_year)
  }
 data_wanted[,2]  = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')[match(data_wanted[,2], c('VU', 'EN', 'CR', 'EW', 'EX'))]  
  data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))
colo = scales::brewer_pal(palette = palette, direction = 1)(5)
names(colo) = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')
  # colo = c("Vulnerable" = rgb(242,141,60, max = 255),
  #        "Endangered" = rgb(238,81,53, max = 255),
  #        "Critically Endangered" = rgb(129,27,39, max = 255),
  #        "Extinct in the Wild" = rgb(88,88,88, max = 255)
  #        )
  endangered_cat =  c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')
  endangered_cat_order = endangered_cat[which(!is.na(match(endangered_cat, data_wanted$RedListCategory)))]
  data_wanted$RedListCategory = factor(data_wanted$RedListCategory, levels = endangered_cat_order)
colo = colo[match(levels(data_wanted$RedListCategory), names(colo))]
  
  fig <- plot_ly(data_wanted, x = ~year, y = ~Items, color = ~RedListCategory, type = 'scatter', mode = 'lines+markers', colors =  colo)

  fig <- fig |> layout(yaxis = list(title = paste0("Number of ",to_do[i])),
                   xaxis = list(title = "Year"))
  fig <- fig |> layout(hovermode = 'x unified')

 
if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Line-number_of_threatened_',to_do[i],'_over_time.html'))
}
  
 fig
}

```

`r if(report_kind == 'interactive' & have_redlist & do_over_time){"###### Accessions (Number)"}`
```{r  Number of threatened native accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & have_redlist & do_over_time}
i=2
to_do = c('items', 'accessions', 'taxa')
if(nrow(flex_data) > 0){

  # Get the data from over_time_info.
  data_wanted = NULL
  wanted_item = which(grepl('redlistcat',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
  for(jj in 1:length(over_time_info)){
    info_year = over_time_info[[jj]][[wanted_item]]
     if(nrow(info_year) == 0){
      next
    }
    prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
    info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)), info_year, prop = prop)
    data_wanted = rbind(data_wanted, info_year)
  }
 data_wanted[,2]  = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')[match(data_wanted[,2], c('VU', 'EN', 'CR', 'EW', 'EX'))]  
  data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))
   endangered_cat =  c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')
  endangered_cat_order = endangered_cat[which(!is.na(match(endangered_cat, data_wanted$RedListCategory)))]
  data_wanted$RedListCategory = factor(data_wanted$RedListCategory, levels = endangered_cat_order)
colo = colo[match(levels(data_wanted$RedListCategory), names(colo))]
  
  fig <- plot_ly(data_wanted, x = ~year, y = ~Accessions, color = ~RedListCategory, type = 'scatter', mode = 'lines+markers',colors =  colo)

  fig <- fig |> layout(yaxis = list(title = paste0("Number of ",to_do[i])),
                   xaxis = list(title = "Year"))
  fig <- fig |> layout(hovermode = 'x unified')

 
if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Line-number_of_threatened_',to_do[i],'_over_time.html'))
}
  fig
}


```

`r if(report_kind == 'interactive'& have_redlist & do_over_time){"###### Taxa (Number)"}`
```{r  Number of threatened native taxa over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & have_redlist & do_over_time}
i=3
to_do = c('items', 'accessions', 'taxa')
if(nrow(flex_data) > 0){

  # Get the data from over_time_info.
  data_wanted = NULL
  wanted_item = which(grepl('redlistcat',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
  for(jj in 1:length(over_time_info)){
    info_year = over_time_info[[jj]][[wanted_item]]
     if(nrow(info_year) == 0){
      next
    }
    prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
    info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)), info_year, prop = prop)
    data_wanted = rbind(data_wanted, info_year)
  }
 data_wanted[,2]  = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')[match(data_wanted[,2], c('VU', 'EN', 'CR', 'EW', 'EX'))]  
  data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))
  
   endangered_cat =  c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')
  endangered_cat_order = endangered_cat[which(!is.na(match(endangered_cat, data_wanted$RedListCategory)))]
  data_wanted$RedListCategory = factor(data_wanted$RedListCategory, levels = endangered_cat_order)
colo = colo[match(levels(data_wanted$RedListCategory), names(colo))]
  fig <- plot_ly(data_wanted, x = ~year, y = ~Accessions, color = ~RedListCategory, type = 'scatter', mode = 'lines+markers', colors =  colo)

  fig <- fig |> layout(yaxis = list(title = paste0("Number of ",to_do[i])),
                   xaxis = list(title = "Year"))
  fig <- fig |> layout(hovermode = 'x unified')

 
if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Line-number_of_threatened_',to_do[i],'_over_time.html'))
}
  fig
}


```

`r if(report_kind == 'interactive' & have_redlist & do_over_time){"###### Items (Proportion)"}`
```{r  Proportion of threatened native items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & have_redlist & do_over_time}
i=1
to_do = c('items', 'accessions')
if(nrow(flex_data) > 0){
  # Get the data from over_time_info.
  data_wanted = NULL
  wanted_item = which(grepl('redlistcat',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
  for(jj in 1:length(over_time_info)){
    info_year = over_time_info[[jj]][[wanted_item]]
     if(nrow(info_year) == 0){
      next
    }
    prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
    info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)), info_year, prop = prop)
    data_wanted = rbind(data_wanted, info_year)
  }
 data_wanted[,2]  = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')[match(data_wanted[,2], c('VU', 'EN', 'CR', 'EW', 'EX'))]  
  data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))
  
   endangered_cat =  rev(c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct'))
  endangered_cat_order = endangered_cat[which(!is.na(match(endangered_cat, data_wanted$RedListCategory)))]
  data_wanted$RedListCategory = factor(data_wanted$RedListCategory, levels = endangered_cat_order)
colo = colo[match(levels(data_wanted$RedListCategory), names(colo))]
  if(export_data){
    item_name = paste0('Threatened_native_plants_in_the_LC_proportion_over_time_',to_do[i])
  exporting_data_store$AA = data_wanted
  names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
}
  
   text = paste0(round(data_wanted$prop,digits=2), '% (',data_wanted$Items,' items) ')
data_wanted$text = text
fig <- plot_ly(data_wanted, x = ~year, y = ~prop, color = ~RedListCategory, type = 'bar', text = ~text,
               hovertemplate = '%{text}',
               sort = FALSE,colors =  colo)
fig <- fig |> layout(yaxis = list(title = 'Percentage'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text=''),  traceorder= 'reversed'),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)



if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_Bar-native_threatened_over_time_by_item.html'))
}

fig
}

```

`r if(report_kind == 'interactive' & have_redlist & do_over_time){"###### Accessions (Proportion)"}`
```{r  Proportion of threatened native accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & have_redlist & do_over_time}
i=2
to_do = c('items', 'accessions')
if(nrow(flex_data) > 0){
  # Get the data from over_time_info.
  data_wanted = NULL
  wanted_item = which(grepl('redlistcat',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
  for(jj in 1:length(over_time_info)){
    info_year = over_time_info[[jj]][[wanted_item]]
     if(nrow(info_year) == 0){
      next
    }
    prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
    info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)), info_year, prop = prop)
    data_wanted = rbind(data_wanted, info_year)
  }
 data_wanted[,2]  = c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct')[match(data_wanted[,2], c('VU', 'EN', 'CR', 'EW', 'EX'))]  
  data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))
  
   endangered_cat =  rev(c('Vulnerable', 'Endangered', 'Critically Endangered', 'Extinct in the Wild', 'Extinct'))
  endangered_cat_order = endangered_cat[which(!is.na(match(endangered_cat, data_wanted$RedListCategory)))]
  data_wanted$RedListCategory = factor(data_wanted$RedListCategory, levels = endangered_cat_order)
colo = colo[match(levels(data_wanted$RedListCategory), names(colo))]
  if(export_data){
    item_name = paste0('Threatened_native_plants_in_the_LC_proportion_over_time_',to_do[i])
  exporting_data_store$AA = data_wanted
  names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
}
  
   text = paste0(round(data_wanted$prop,digits=2), '% (',data_wanted$Accessions,' accessions) ')
data_wanted$text = text
fig <- plot_ly(data_wanted, x = ~year, y = ~prop, color = ~RedListCategory, type = 'bar', text = ~text,
               hovertemplate = '%{text}',
                colors =  colo)
fig <- fig |> layout(yaxis = list(title = 'Percentage'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text=''),  traceorder= 'reversed'),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)



if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_Bar-native_threatened_over_time_by_accessions.html'))
}

fig
}

```


`r if(report_kind == 'interactive' & have_redlist & do_over_time){"##### {-}"}`


***





```{r, export data, echo = FALSE}
if(export_data){
  #remove all data except wanted to be exported.
  # rm(list=setdiff(ls(), c("exporting_data_store", "output_dir", "collection")))
  # Do some changes (which we do in smaller chunks in the actual code.)
  
  exporting_data_store$Number_of_native_species_in_LC_over_time
  Proportion_species_in_LC_over_time = exporting_data_store$Total_species_in_LC_over_time
  for(i in 2:5){
    Proportion_species_in_LC_over_time[[i]] = round(exporting_data_store$Number_of_native_species_in_LC_over_time[[i]] / exporting_data_store$Total_species_in_LC_over_time[[i]] *100, digits = 2)
  }
  exporting_data_store$Total_species_in_LC_over_time = Proportion_species_in_LC_over_time
  names(exporting_data_store)[ names(exporting_data_store) == 'Total_species_in_LC_over_time'] = 'Proportion_species_in_LC_over_time'
  
  # save as .rda.
  save(exporting_data_store, file = paste0(output_dir,'/',collection, '_native_data.rda'))
  
}
```

```{r, save excel version of data, eval = save_excel & export_data}
library(xlsx)
file = paste0(output_dir,'/',collection, '_native_data.xlsx')
wb <- createWorkbook()
datas <- exporting_data_store
data_titles = names(datas) |> stringr::str_replace_all('_', ' ')
sheetnames <- paste0('Sheet ', 1:length(datas))
sheets <- lapply(sheetnames,  createSheet, wb = wb)
for(i in 1:length(datas)){
  # First we'll create a new row, let's put the title on row 2
  titleRow <-createRow(sheets[[i]], rowIndex=1)
  # We'll add a cell to that row (in the first column) for the title
  sheetTitle <-createCell(titleRow, colIndex=1)
  # We'll add the sheet title to the cell
  setCellValue(sheetTitle[[1,1]], data_titles[i])
  # We'll choose the formatting for the cell
  xlsx::addDataFrame(datas[[i]], sheet = sheets[[i]],row.names = FALSE, startRow = 3)
}
saveWorkbook(wb, file = file)

```

### Taxonomic representation of native taxa 

In this section we create sunburst and treemap charts showing all the genera native to `r paste0(location_name, collapse = ', ')` where the genera are grouped into families, orders and higher-level lineages. The charts are shaded lighter to darker orange depending on the proportion of the native lineages that are found in the collection, where lineages in light orange are not represented. This provides a tool to visualise potential lineages to add to the collection in order to increase taxonomic diversity.  

```{r, Create taxonomic diversity genus level, echo = FALSE, message = FALSE}
report = native_wcvp
report = report[report$taxon_status == 'Accepted',]
collection_report = LC_native_exisiting
LC_in_WCVP = match(unique(collection_report$POWO_plant_name_id) ,report$plant_name_id)
LC_in_WCVP = LC_in_WCVP[!is.na(LC_in_WCVP)]
in_LC = rep(F, nrow(report))
in_LC[LC_in_WCVP] = TRUE
report$in_LC = in_LC
report = report[c('family', 'genus', 'in_LC')]
report$fam_gen = paste0(report$family,' ',report$genus)
report <-  report |> 
        dplyr::group_by(fam_gen) |> 
        dplyr::summarise(family = family[1], 
                         genus = genus[1],
                         in_LC = any(in_LC)) |>
  dplyr::ungroup() 



#No families.
# = Use POWO family if available if not use the original.
no_families <- length(unique(report$family))

#No genus
# = Use POWO genus if available if not use the original.
no_genus <- length(unique(report$fam_gen))


report_div  = report

Diversity_class = BGSmartR::Diversity_classification
Classification <- as.data.frame(Diversity_class$Classification)
synomym_families <- as.data.frame(Diversity_class$synomym_families)

fam = report_div$family

# Convert from conserved family name to family name where applicable. 
AA = apply(synomym_families, 2, function(x){
  fam[fam == as.character(x[2])] = as.character(x[1])
  })
report_div$family = fam

matched_families = match(fam, Classification$family)
order = Classification$order[matched_families]
major_Eudicot_lineage = Classification$`major Eudicot lineage`[matched_families]
major_Angiosperm_lineage = Classification$`major Angiosperm lineage`[matched_families]
major_Land_Plants_lineage = Classification$`major Land Plants lineage`[matched_families]


report_div$order = order
report_div$major_Eudicot_lineage = major_Eudicot_lineage
report_div$major_Angiosperm_lineage = major_Angiosperm_lineage
report_div$major_Land_Plants_lineage = major_Land_Plants_lineage

report_cur = report_div

combined_taxo = paste0(report_cur$genus,'---',
                                       report_cur$family,'---',
                                       report_cur$order,'---',
                                       report_cur$major_Eudicot_lineage,'---',
                                       report_cur$major_Angiosperm_lineage,'---',
                                       report_cur$major_Land_Plants_lineage)

with_issue = length(which(grepl('---NA$',combined_taxo)))
combined_taxo_count = as.numeric(report_cur$in_LC)
#remove those without major land plants lineage. (i.e ends in ---NA).
if(with_issue > 0){
  index_remove = which(grepl('---NA$',combined_taxo))
  combined_taxo = combined_taxo[-index_remove]
  combined_taxo_count = combined_taxo_count[-index_remove]
}
# Convert NA in species to Indet.
combined_taxo[which(grepl('^NA---',combined_taxo))] = stringr::str_replace(combined_taxo[which(grepl('^NA---',combined_taxo))], '^NA---', 'Indet.---')


data = data.frame(ID = combined_taxo, count = combined_taxo_count, count_all = 1)
non_combined  = data.frame(t(data.frame(stringr::str_split(data$ID,pattern = '---'))))
names(non_combined) = c('genus', 'family', 'order', 'major_Eudicot_lineage',
                        'major_Angiosperm_lineage', 'major_Land_Plants_lineage')
rownames(non_combined) = 1:nrow(non_combined)

data = data.frame(data, non_combined)

# push species names to genus species (otherwise issues with repeated species names with different genera)

labels = c(unique(data$major_Land_Plants_lineage), unique(data$major_Angiosperm_lineage), unique(data$major_Eudicot_lineage),
           unique(data$order), unique(data$family), unique(data$genus))
major_Land_Plants_lineage_index = 1:length(unique(data$major_Land_Plants_lineage))
major_Angiosperm_lineage_index = (max(major_Land_Plants_lineage_index)+1):(max(major_Land_Plants_lineage_index)+length(unique(data$major_Angiosperm_lineage)))
major_Eudicot_lineage_index = (max(major_Angiosperm_lineage_index)+1):(max(major_Angiosperm_lineage_index)+length(unique(data$major_Eudicot_lineage)))
order_index = (max(major_Eudicot_lineage_index)+1):(max(major_Eudicot_lineage_index)+length(unique(data$order)))
family_index = (max(order_index)+1):(max(order_index)+length(unique(data$family)))
genus_index = (max(family_index)+1):(max(family_index)+length(unique(data$genus)))

parents = rep('', length(labels))
parents[major_Angiosperm_lineage_index] = data$major_Land_Plants_lineage[match(labels[major_Angiosperm_lineage_index], data$major_Angiosperm_lineage)]
parents[major_Eudicot_lineage_index] = data$major_Angiosperm_lineage[match(labels[major_Eudicot_lineage_index], data$major_Eudicot_lineage)]
parents[order_index] = data$major_Eudicot_lineage[match(labels[order_index], data$order)]
parents[family_index] = data$order[match(labels[family_index], data$family)]
parents[genus_index] = data$family[match(labels[genus_index], data$genus)]

values = rep(NA, length(labels))
values[genus_index] = data$count[match(labels[genus_index], data$genus)]
total_for_families <-  aggregate(. ~family, data[,c(5,2)], sum, na.rm = TRUE)
values[family_index] = total_for_families$count[match(labels[family_index], total_for_families$family)]
total_for_order <-  aggregate(. ~order, data[,c(6,2)], sum, na.rm = TRUE)
values[order_index] = total_for_order$count[match(labels[order_index], total_for_order$order)]
total_for_major_Eudicot_lineage <-  aggregate(. ~major_Eudicot_lineage, data[,c(7,2)], sum, na.rm = TRUE)
values[major_Eudicot_lineage_index] = total_for_major_Eudicot_lineage$count[match(labels[major_Eudicot_lineage_index], total_for_major_Eudicot_lineage$major_Eudicot_lineage)]
total_for_major_Angiosperm_lineage <-  aggregate(. ~major_Angiosperm_lineage, data[,c(8,2)], sum, na.rm = TRUE)
values[major_Angiosperm_lineage_index] = total_for_major_Angiosperm_lineage$count[match(labels[major_Angiosperm_lineage_index], total_for_major_Angiosperm_lineage$major_Angiosperm_lineage)]
total_for_major_Land_Plants_lineage <-  aggregate(. ~major_Land_Plants_lineage, data[,c(9,2)], sum, na.rm = TRUE)
values[major_Land_Plants_lineage_index] = total_for_major_Land_Plants_lineage$count[match(labels[major_Land_Plants_lineage_index], total_for_major_Land_Plants_lineage$major_Land_Plants_lineage)]
in_collection = values

values = rep(NA, length(labels))
values[genus_index] = data$count_all[match(labels[genus_index], data$genus)]
total_for_families <-  aggregate(. ~family, data[,c(5,3)], sum, na.rm = TRUE)
values[family_index] = total_for_families$count[match(labels[family_index], total_for_families$family)]
total_for_order <-  aggregate(. ~order, data[,c(6,3)], sum, na.rm = TRUE)
values[order_index] = total_for_order$count[match(labels[order_index], total_for_order$order)]
total_for_major_Eudicot_lineage <-  aggregate(. ~major_Eudicot_lineage, data[,c(7,3)], sum, na.rm = TRUE)
values[major_Eudicot_lineage_index] = total_for_major_Eudicot_lineage$count[match(labels[major_Eudicot_lineage_index], total_for_major_Eudicot_lineage$major_Eudicot_lineage)]
total_for_major_Angiosperm_lineage <-  aggregate(. ~major_Angiosperm_lineage, data[,c(8,3)], sum, na.rm = TRUE)
values[major_Angiosperm_lineage_index] = total_for_major_Angiosperm_lineage$count[match(labels[major_Angiosperm_lineage_index], total_for_major_Angiosperm_lineage$major_Angiosperm_lineage)]
total_for_major_Land_Plants_lineage <-  aggregate(. ~major_Land_Plants_lineage, data[,c(9,3)], sum, na.rm = TRUE)
values[major_Land_Plants_lineage_index] = total_for_major_Land_Plants_lineage$count[match(labels[major_Land_Plants_lineage_index], total_for_major_Land_Plants_lineage$major_Land_Plants_lineage)]
total_wcvp = values


data_formatted = data.frame(ID = labels, labels=labels, parents = parents, values = total_wcvp,  in_LC = in_collection)

#Go back to just species names.
data_formatted$labels[grepl('---', data_formatted$labels)] = unlist(lapply(stringr::str_split(data_formatted$labels[grepl('---', data_formatted$labels)], pattern = '---'), function(x){x[1]}))
data_formatted$ID[grepl('---', data_formatted$ID)] = unlist(lapply(stringr::str_split(data_formatted$ID[grepl('---', data_formatted$ID)], pattern = '---'), function(x){x[1]}))
# data_formatted$labels=unlist(lapply(stringr::str_split(data_formatted$labels, ' '),function(x){x[length(x)]}))
data_formatted$ID = paste0(data_formatted$labels, '---', data_formatted$parents)

data_formatted$parents = paste0(data_formatted$parents,'---',data_formatted$parents[match(data_formatted$parents, data_formatted$labels)])
data_formatted$parents[data_formatted$parents == "---NA"] =''

# Collapse levels.
data_formatted$labels[data_formatted$labels == 'None_Eudicots'] = 'Other'
data_formatted$labels[data_formatted$labels == 'None_Angiosperms'] = 'Other'

# Remove Intermediate levels.
remove_nodes = c('None_Monocots', 'None_Ferns', 'None_Ferns_Eudicot',"None_Gymnosperms", 'None_Lycophytes',   'None_Liverworts', 'None_Hornworts', 'None_Gymnosperms_Eudicot', 'None_Lycophytes_Eudicot', 'None_Liverworts_Eudicot', 'None_Hornworts_Eudicot', 'No_Mosses_Angiosperm_lineage', 'No_Mosses_Eudicot_lineage', 'None_Angiosperms_Eudicot_lineage')
AA = lapply(remove_nodes, function(node){
  # Select the row to remove (begining with "*node*---")
  to_remove = which(grepl(paste0('^',node,'---'), data_formatted$ID))
  if(length(to_remove)> 0 ){
    #Get new parent id and new label from the node to remove.
    new_parent = data_formatted[to_remove,]$parents
    new_label =  unlist(stringr::str_split(new_parent,'---'))[1]
    # Remove the row.
    data_formatted = data_formatted[-to_remove,]
    # Update End of the ID for the new parent
    data_formatted$ID[grepl(paste0(node,'$'),data_formatted$ID)] = unlist(stringr::str_replace(data_formatted$ID[grepl(paste0(node,'$'),data_formatted$ID)],paste0('---',node), paste0('---',new_label)))
    # Update the parents for each node who originally has 'node' as the value. 
    data_formatted$parents[grepl(paste0('^',node, '---'),data_formatted$parents)] = new_parent
    # Update the parents for each node who originally has 'node' as the parent. 
    data_formatted$parents[grepl(paste0(node,'$'),data_formatted$parents)] = unlist(stringr::str_replace(data_formatted$parents[grepl(paste0(node,'$'),data_formatted$parents)],paste0('---',node), paste0('---',new_label)))
  }
  data_formatted <<- data_formatted # This is needed don't remove.
  return()
})


# Add header of 'Collection'
data_formatted$ID[grepl('---$', data_formatted$ID)] = paste0(data_formatted$ID[grepl('---$', data_formatted$ID)] , 'WCVP')
data_formatted$parents[grepl('---$', data_formatted$parents)] = paste0(data_formatted$parents[grepl('---$', data_formatted$parents)] , 'WCVP')
data_formatted$parents[data_formatted$parents == ''] = 'WCVP'

data_formatted[nrow(data_formatted)+1,] = c('WCVP', 'WCVP', '', sum(data_formatted$values[data_formatted$parents == 'WCVP']), sum(data_formatted$in_LC[data_formatted$parents == 'WCVP']) )

### Subfamily level information
# {
#   # Load the downloaded WFO dataset from -> https://www.worldfloraonline.org/downloadData
# file = '/Users/jakepowell/Downloads/classification.csv'
# data = read.csv(file, sep = '\t')
# 
# data_accepted = data[data$taxonomicStatus == 'Accepted',]
# data_care = data[c('family', 'subfamily', 'tribe', 'subtribe','majorGroup','genus')]
# 
# ## Create a summary of families and their subfamilies.
# data_simp <- data_care |>
#   dplyr::group_by(.data$family) |>
#   dplyr::summarise(subfamily = toString(unique(.data$subfamily)),
#                    tribe = toString(unique(.data$tribe)),
#                    subtribe = toString(unique(.data$subtribe)),
#                    majorGroup = toString(unique(.data$majorGroup)),
#                    no_genus = length(unique(.data$genus))
#   ) |>
#   dplyr::ungroup()
# 
# data_simp$subfamily = stringr::str_remove(string = data_simp$subfamily, pattern = 'NA, ')
# data_simp$tribe = stringr::str_remove(string = data_simp$tribe, pattern = 'NA, ')
# data_simp$subtribe = stringr::str_remove(string = data_simp$subtribe, pattern = 'NA, ')
# 
# data_simp = data_simp[rev(order(data_simp$no_genus)),]
# writexl::write_xlsx(data_simp, path = 'Subfamily_information_in_WFO_v.2023.12.xlsx')
# 
# 
# data_accepted = data[data$taxonomicStatus == 'Accepted',]
# data_care = data_accepted[c('family', 'subfamily', 'tribe', 'subtribe','majorGroup','genus')]
# 
# data_simp <- data_care |>
#   dplyr::group_by(.data$family) |>
#   dplyr::summarise(subfamily = toString(unique(.data$subfamily)),
#                    tribe = toString(unique(.data$tribe)),
#                    subtribe = toString(unique(.data$subtribe)),
#                    majorGroup = toString(unique(.data$majorGroup)),
#                    no_genus = length(unique(.data$genus))
#   ) |>
#   dplyr::ungroup()
# 
# data_simp$subfamily = stringr::str_remove(string = data_simp$subfamily, pattern = 'NA, ')
# data_simp$tribe = stringr::str_remove(string = data_simp$tribe, pattern = 'NA, ')
# data_simp$subtribe = stringr::str_remove(string = data_simp$subtribe, pattern = 'NA, ')
# 
# data_simp = data_simp[rev(order(data_simp$no_genus)),]
# data_subfamily = data_simp
# writexl::write_xlsx(data_simp, path = 'Subfamily_information_in_WFO_v.2023.12_accepted_only.xlsx')
# 
# data_tribe <- data_care[data_care$tribe != '',] |>
#   dplyr::group_by(.data$subfamily) |>
#   dplyr::summarise(family = toString(unique(.data$family)),
#                    tribe = toString(unique(.data$tribe)),
#                    subtribe = toString(unique(.data$subtribe)),
#                    majorGroup = toString(unique(.data$majorGroup)),
#                    no_genus = length(unique(.data$genus))
#   ) |>
#   dplyr::ungroup()
# 
# data_tribe$family = stringr::str_remove(string = data_tribe$family, pattern = 'NA, ')
# data_tribe$tribe = stringr::str_remove(string = data_tribe$tribe, pattern = 'NA, ')
# data_tribe$subtribe = stringr::str_remove(string = data_tribe$subtribe, pattern = 'NA, ')
# 
# data_tribe = data_tribe[rev(order(data_tribe$no_genus)),]
# writexl::write_xlsx(data_simp, path = 'Tribe_information_in_WFO_v.2023.12_accepted_only.xlsx')
# 
# data_subtribe <- data_care[data_care$subtribe != '',] |>
#   dplyr::group_by(.data$tribe) |>
#   dplyr::summarise(family = toString(unique(.data$family)),
#                    subfamily = toString(unique(.data$subfamily)),
#                    subtribe = toString(unique(.data$subtribe)),
#                    majorGroup = toString(unique(.data$majorGroup)),
#                    no_genus = length(unique(.data$genus))
#   ) |>
#   dplyr::ungroup()
# 
# data_subtribe = data_subtribe[rev(order(data_subtribe$no_genus)),]
# writexl::write_xlsx(data_simp, path = 'Subtribe_information_in_WFO_v.2023.12_accepted_only.xlsx')
# 
# 
# }

### Add subfamily info to data_formatted
{
  #############################################################################
## Add subfamilies (All)
#############################################################################
## Get the genus that are linked to each sub family.
# families_with_sub = data_simp$family[data_simp$subfamily != ""]
# data_fam_sub = data_care[data_care$family %in% families_with_sub,]
# data_fam_sub$subfamily[data_fam_sub$subfamily == ''] = 'No Subfamily'
# data_fam_sub$together = paste0(data_fam_sub$family, '---', data_fam_sub$subfamily)
# subfamily_genus = unique(data_fam_sub[c("together", 'genus')])
# subfamily_genus_simp <- subfamily_genus |>
#   dplyr::group_by(.data$together) |>
#   dplyr::summarise(all_genera = toString(unique(.data$genus)),
#                    no_genera = length(unique(.data$genus))
#   ) |>
#   dplyr::ungroup()
# subfamily_genus_simp$family = stringr::str_extract(subfamily_genus_simp$together, '[A-Za-z ]*')
# subfamily_genus_simp$sub_family = stringr::str_extract(subfamily_genus_simp$together, '[A-Za-z ]*$')
# 
# # Remove those without a subfamily (we will deal with these later)
# subfamily_genus_simp = subfamily_genus_simp[subfamily_genus_simp$sub_family != "No Subfamily",]
# save(subfamily_genus_simp, file = 'subfamily_genus_simp.rda')
# load('subfamily_genus_simp.rda')
subfamily_genus_simp = BGSmartR::subfamily_genus_simp
for(i in 1:nrow(subfamily_genus_simp)){
  # for(i in 1:30){
  subfamily_info = subfamily_genus_simp[i,]
  subfamily_genera = unlist(stringr::str_split(subfamily_info$all_genera ,', '))
  subfamily_genera = subfamily_genera[subfamily_genera !=  ""]
  if(length(subfamily_genera) == 0){
    next
  }
  in_formatted = which(grepl(paste0(subfamily_info$family, '$'),data_formatted$ID) &
                         grepl(paste0(subfamily_genera, collapse = '|'),data_formatted$labels))
  length(in_formatted) >0
  if(length(in_formatted) >0){
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(subfamily_info$sub_family,'---', subfamily_info$family)
    new = c(new_ID, subfamily_info$sub_family, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = subfamily_info$family, replacement = subfamily_info$sub_family)
    data_want$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new
  }
}

####### Deal with genera with no subfamily (when others in the family have a sub-family.)
# Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
families_with_subfamilies = unique(subfamily_genus_simp$family)
all_subfamilies = unique(subfamily_genus_simp$sub_family)
# Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
for(i in 1:length(families_with_subfamilies)){
  family = families_with_subfamilies[i]
  # Fine records whose parent is the familiy in question and extract the data.

  in_formatted = which(grepl(paste0(family,'$'),data_formatted$ID))
  data_want = data_formatted[in_formatted,]

  # Check if we have any records where we have genus---family (i.e no  subfamily)
  without_subfamily = which(!data_want$labels %in% all_subfamilies)

  #If we have at least one genus-family we need to group these into no subfamily.
  if(length(without_subfamily) > 0){
    data_without_subfam = data_want[without_subfamily,]

    new_ID = paste0('No Subfamily','---', family)

    new_node = new = c(new_ID, 'No Subfamily', data_want$parents[1], sum(as.numeric(data_without_subfam$values)), sum(as.numeric(data_without_subfam$in_LC)))

    data_without_subfam$ID = stringr::str_replace(data_without_subfam$ID,pattern = family, replacement = 'No Subfamily')
    data_without_subfam$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted[without_subfamily],] = data_without_subfam

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new_node
  }

}

#############################################################################
## Add tribes (All)
#############################################################################

## Get the genus that are linked to each sub family.
# subfamilies_with_tribe = data_tribe$subfamily[data_tribe$tribe != ""]
# data_fam_sub = data_care[data_care$subfamily %in% subfamilies_with_tribe,]
# data_fam_sub$tribe[data_fam_sub$tribe == ''] = 'No Tribe'
# data_fam_sub$together = paste0(data_fam_sub$subfamily, '---', data_fam_sub$tribe)
# subfamily_genus = unique(data_fam_sub[c("together", 'genus')])
# tribe_genus_simp <- subfamily_genus |>
#   dplyr::group_by(.data$together) |>
#   dplyr::summarise(all_genera = toString(unique(.data$genus)),
#                    no_genera = length(unique(.data$genus))
#   ) |>
#   dplyr::ungroup()
# tribe_genus_simp$tribe = stringr::str_extract(tribe_genus_simp$together, '[A-Za-z ]*$')
# tribe_genus_simp$sub_family = stringr::str_extract(tribe_genus_simp$together, '[A-Za-z ]*')
# 
# # Remove those without a subfamily (we will deal with these later)
# tribe_genus_simp = tribe_genus_simp[tribe_genus_simp$sub_family != "No Subfamily",]
# save(tribe_genus_simp, file = 'tribe_genus_simp.rda')
# load('tribe_genus_simp.rda')
tribe_genus_simp = BGSmartR::tribe_genus_simp
for(i in 1:nrow(tribe_genus_simp)){
  # for(i in 1:14){
  tribe_info = tribe_genus_simp[i,]
  tribe_genera = unlist(stringr::str_split(tribe_info$all_genera ,', '))
  tribe_genera = tribe_genera[tribe_genera !=  ""]
  if(length(tribe_genera) == 0){
    next
  }
  in_formatted = which(grepl(paste0(tribe_info$sub_family, '$'),data_formatted$ID) &
                         data_formatted$labels %in% tribe_genera)
  length(in_formatted) >0
  if(length(in_formatted) >0){
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(tribe_info$tribe,'---', tribe_info$sub_family)
    new = c(new_ID, tribe_info$tribe, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = tribe_info$sub_family, replacement = tribe_info$tribe)
    data_want$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want
    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new
  }
}

####### Deal with genera with no subfamily (when others in the family have a sub-family.)
# Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
subfamilies_with_tribes = unique(tribe_genus_simp$sub_family)
all_tribes = unique(tribe_genus_simp$tribe)
# Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
for(i in 1:length(subfamilies_with_tribes)){
  subfamily = subfamilies_with_tribes[i]
  # Fine records whose parent is the familiy in question and extract the data.

  in_formatted = which(grepl(paste0(subfamily,'$'),data_formatted$ID))
  data_want = data_formatted[in_formatted,]

  # Check if we have any records where we have genus---subfamily (i.e no  subfamily)
  without_tribe = which(!data_want$labels %in% all_tribes)

  #If we have at least one genus-subfamily we need to group these into no subfamily.
  if(length(without_tribe) > 0){
    data_without_tribe = data_want[without_tribe,]

    new_ID = paste0('No Tribe','---', subfamily)

    new_node = new = c(new_ID, 'No Tribe', data_want$parents[1], sum(as.numeric(data_without_tribe$values)), sum(as.numeric(data_without_tribe$in_LC)))

    data_without_tribe$ID = stringr::str_replace(data_without_tribe$ID,pattern = subfamily, replacement = 'No Tribe')
    data_without_tribe$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted[without_tribe],] = data_without_tribe

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new_node
  }

}


#############################################################################
## Add Subtribes (All)
#############################################################################
# asteraceae = data_simp[data_simp$family == "Asteraceae",]

## Get the genus that are linked to each sub family.
# tribes_with_subtribes = data_subtribe$tribe[data_subtribe$subtribe != ""]
# data_fam_sub = data_care[data_care$tribe %in% tribes_with_subtribes,]
# data_fam_sub$subtribe[data_fam_sub$subtribe == ''] = 'No Subtribe'
# data_fam_sub$together = paste0(data_fam_sub$tribe, '---', data_fam_sub$subtribe)
# subtribe_genus = unique(data_fam_sub[c("together", 'genus')])
# subtribe_genus_simp <- subtribe_genus |>
#   dplyr::group_by(.data$together) |>
#   dplyr::summarise(all_genera = toString(unique(.data$genus)),
#                    no_genera = length(unique(.data$genus))
#   ) |>
#   dplyr::ungroup()
# subtribe_genus_simp$subtribe = stringr::str_extract(subtribe_genus_simp$together, '[A-Za-z ]*$')
# subtribe_genus_simp$tribe = stringr::str_extract(subtribe_genus_simp$together, '[A-Za-z ]*')
# 
# # Remove those without a subfamily (we will deal with these later)
# subtribe_genus_simp = subtribe_genus_simp[subtribe_genus_simp$subtribe != "No Subtribe",]
# save(subtribe_genus_simp, file = 'subtribe_genus_simp.rda')
# load('subtribe_genus_simp.rda')
subtribe_genus_simp = BGSmartR::subtribe_genus_simp
for(i in 1:nrow(subtribe_genus_simp)){
  # for(i in 1:30){
  subtribe_info = subtribe_genus_simp[i,]
  subtribe_genera = unlist(stringr::str_split(subtribe_info$all_genera ,', '))
  subtribe_genera = subtribe_genera[subtribe_genera !=  ""]
  if(length(subtribe_genera) == 0){
    next
  }
  in_formatted = which(grepl(paste0(subtribe_info$tribe, '$'),data_formatted$ID) & data_formatted$labels %in% subtribe_genera)
  if(length(in_formatted) == 0){
    next
  }
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(subtribe_info$subtribe,'---', subtribe_info$tribe)
    new = c(new_ID, subtribe_info$subtribe, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = subtribe_info$tribe, replacement = subtribe_info$subtribe)
    data_want$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new
}

####### Deal with genera with no subfamily (when others in the family have a sub-family.)
# Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
tribes_with_subtribes = unique(subtribe_genus_simp$tribe)
all_subtribes = unique(subtribe_genus_simp$subtribe)
# Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
for(i in 1:length(tribes_with_subtribes)){
  tribe = tribes_with_subtribes[i]
  # Fine records whose parent is the familiy in question and extract the data.

  in_formatted = which(grepl(paste0(tribe,'$'),data_formatted$ID))
  data_want = data_formatted[in_formatted,]

  # Check if we have any records where we have genus---tribe (i.e no  tribe)
  without_subtribe = which(!data_want$labels %in% all_subtribes)

  #If we have at least one genus-tribe we need to group these into no tribe
  if(length(without_subtribe) > 0){
    data_without_tribe = data_want[without_subtribe,]

    new_ID = paste0('No Subtribe','---', tribe)

    new_node = new = c(new_ID, 'No Subtribe', data_want$parents[1], sum(as.numeric(data_without_tribe$values)), sum(as.numeric(data_without_tribe$in_LC)))

    data_without_tribe$ID = stringr::str_replace(data_without_tribe$ID,pattern = tribe, replacement = 'No Subtribe')
    data_without_tribe$parents = new_ID


    # Replace original genus-family with the new genus-tribe
    data_formatted[in_formatted[without_subtribe],] = data_without_tribe

    # Add the new node for the tribe
    data_formatted[nrow(data_formatted)+1,] = new_node
  }

}


#############################################################################

}



data_formatted$percentage = as.numeric(data_formatted$in_LC) / as.numeric(data_formatted$values)
rbPal <- colorRampPalette(c("#FEEDDE", "#FDD0A2", "#FDAE6B", "#FD8D3C", "#F16913", "#D94801", "#8C2D04"))
data_formatted$Col <- rbPal(100)[as.numeric(cut(data_formatted$percentage,breaks = 100))]

data_formatted$hover = paste0(round(data_formatted$percentage*100,digits = 2),'% of native ', data_formatted$labels, ' genera found within the LC (',data_formatted$in_LC,'/',data_formatted$values,')')
```

```{r, Create  taxonomic diversity at genus with contained/missing, echo = F}
if(report_kind == 'interactive'){
 fig <- plotly::plot_ly(data_formatted,
                             ids = ~ID,
                             labels = ~labels,
                             parents =~parents,
                             values = ~values,
                             type = 'sunburst',
                             insidetextorientation='radial',
                             branchvalues = 'total',
                             maxdepth = 4,
                             marker=list(colors=data_formatted$Col, line = list(color = 'white')),
                             hoverinfo = "text",  hovertext = data_formatted$hover
                             )

 fig2 <- plotly::plot_ly(data_formatted,
                             ids = ~ID,
                             labels = ~labels,
                             parents =~parents,
                             values = ~values,
                             type = 'treemap',
                             branchvalues = 'total',
                             maxdepth = 4,
                             marker=list(colors=data_formatted$Col, line = list(color = 'white')),
                         hoverinfo = "text",  hovertext = data_formatted$hover)
                        
if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','sunburst:taxonomic_diversity.html'))
  htmlwidgets::saveWidget(fig2, file = paste0(figures_dir, '/','treemap:taxonomic_diversity.html'))
}

}
```

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Sunburst"}`
```{r  Sunburst genera, fig.fullwidth=TRUE, fig.dim = c(10, 8), eval = report_kind == 'interactive'}
fig
```

`r if(report_kind == 'interactive'){"###### Treemap"}`
```{r  tree map genera, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
fig2
```

`r if(report_kind == 'interactive'){"##### {-}"}`

***

```{r rm(data_formatted)}
```
