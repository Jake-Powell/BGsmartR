---
title: "Taxonomic diversity in the living collection"
output: html_document
always_allow_html: true
---

###### {-}
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(plotly)
library(htmltools)
library(sf)
library(here)
library(flextable)
library(ggrepel)
library(downloadthis)

interactive_colour <- function(n){
  color = c('#f46d43', "#FDAE6B", '#848484', '#e6e6e6')
  if(n==2){
    return(color[c(1,4)])
  }
  color[1:n]
}
color_binary <- c('#f46d43', '#e6e6e6')
palette = 'Oranges'
```

```{css, echo = FALSE}
/* from https://ianlunn.github.io/Hover/ */
.hvr-sweep-to-left {
display: inline-block;
vertical-align: middle;
-webkit-transform: perspective(1px) translateZ(0);
transform: perspective(1px) translateZ(0);
box-shadow: 0 0 1px rgba(0, 0, 0, 0);
position: relative;
-webkit-transition-property: color;
transition-property: color;
-webkit-transition-duration: 0.3s;
transition-duration: 0.3s;
}
.hvr-sweep-to-left:before {
content: "";
position: absolute;
z-index: -1;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: #f46d43;
-webkit-transform: scaleX(0);
transform: scaleX(0);
-webkit-transform-origin: 100% 50%;
transform-origin: 100% 50%;
-webkit-transition-property: transform;
transition-property: transform;
-webkit-transition-duration: 0.3s;
transition-duration: 0.3s;
-webkit-transition-timing-function: ease-out;
transition-timing-function: ease-out;
}
.hvr-sweep-to-left:hover, .hvr-sweep-to-left:focus, .hvr-sweep-to-left:active {
color: white;
}
.hvr-sweep-to-left:hover:before, .hvr-sweep-to-left:focus:before, .hvr-sweep-to-left:active:before {
-webkit-transform: scaleX(1);
transform: scaleX(1);
}

.blackbox {
padding: 1em;
background: #FDAE6B;
border: 2px solid #e6e6e6;
border-radius: 10px;
}
.center {
text-align: center;
}
```

```{r, imported parameters}
# # #Inputs
# load('/Users/jakepowell/Cambridge/Enriched_reports_Jake/CUBG_June2023_enriched_report.rda')
# collection = 'CUBG'
# PlantClassification_filepath = '/Users/jakepowell/Cambridge/PlantClassification.xlsx'
# load('/Users/jakepowell/Cambridge/WCVP/Version 11/wcvp_with_redlistcategory.rda')
# separate_figure_folder = FALSE
# output_dir = getwd()
# report_kind = 'static'
# ggtheme = NULL
# value_on_fig = TRUE
# min_year = 1970
# join_bigger_than = 4
# 
# PlantClassification = readxl::read_xlsx(path = PlantClassification_filepath)

```

```{r, add logo, eval = report_kind == 'interactive'}
htmltools::img(src = knitr::image_uri(paste0(system.file(package = "BGSmartR"), "/logo.png")), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; width:87.8px; height:100px')
```

```{r theme_ggplot2, echo = FALSE}
library(ggplot2)
# Changing the default theme
if(is.null(ggtheme)){
  ggtheme <- function(base_size = 16) {
    ggplot2::theme_bw(base_size = base_size) %+replace%
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = rel(1), face = "bold", margin = margin(0,0,5,0), hjust = 0),
        panel.grid.minor = ggplot2::element_blank(),
        panel.background = element_rect(fill = 'transparent', color = NA),
        panel.border = ggplot2::element_blank(),
        axis.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
        axis.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
        axis.line = ggplot2::element_line(color = "black"),
        legend.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
        legend.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
        legend.key = ggplot2::element_rect(fill = "transparent", colour = NA),
        legend.key.size = ggplot2::unit(1.5, "lines"),
        legend.background = ggplot2::element_rect(fill = "transparent", colour = NA),
        strip.background = ggplot2::element_rect(fill = "#17252D", color = "#17252D"),
        strip.text = ggplot2::element_text(size = rel(0.85), face = "bold", color = "white", margin = margin(5,0,5,0))
      )
  }
}
theme_set(ggtheme())
update_geom_defaults("line", list(size = 2))

# Set the colour scale for the plots
scale_colour_continuous <- scale_colour_continuous
scale_colour_discrete   <- scale_colour_discrete
scale_colour_binned     <- scale_colour_binned
scale_fill_continuous <- scale_fill_continuous
scale_fill_discrete <- scale_fill_discrete
scale_fill_binned <- scale_fill_binned
```

`r if(any(!c('no_gardens','AccNoFull') %in% names(enriched_report))){"*** \n **Warning!**\n\n This enriched report contains missing 'original' columns needed to perform the analyses in this report. Default values have been created. In particular, the following were missing "}`

`r if(!'no_gardens' %in% names(enriched_report)){"- no_gardens: cannot perform global scale analysis.\n"}`
`r if(!'AccNoFull' %in% names(enriched_report)){"- AccNoFull: assume each item is its own accession.\n"}`

`r if(any(!c('no_gardens','AccNoFull') %in% names(enriched_report))){"***"}`

```{r, Extracting information from enriched report, echo = F}
if(!'AccNoFull' %in% names(enriched_report)){enriched_report$AccNoFull = 1:nrow(enriched_report)}
if(!'no_gardens' %in% names(enriched_report)){do_global = FALSE}
report = enriched_report
no_records = nrow(report)

# Reduce the report to existing (non-cultivars or hybrids)
index_want = which(report$ItemStatusType == 'Existing' & !grepl('0|5|6',report$taxon_type))
no_want = length(index_want)
report = report[index_want,]

# Get the best name from POWO first o/w original report.
report$good_name = paste0(report$sanitised_taxon, ' ', report$extracted_author)
best_name = paste0(report$POWO_taxon_name, ' ', report$POWO_taxon_authors)
best_name[which(best_name == 'NA NA')] = report$good_name[which(best_name == 'NA NA')]
report$best_name = best_name

#Select columns of interest
interest = report[,match(c('AccNoFull','sanitised_taxon', 'extracted_author', 'POWO_taxon_name', 'POWO_taxon_authors', 'good_name', 'no_gardens'), names(report))]


if(separate_figure_folder){
  figures_dir = paste0(output_dir,'/',collection,'_Figures')
  dir.create(figures_dir,showWarnings = FALSE)
}
```

This report explores taxonomic diversity at **`r collection`**.

In particular this report explores the representation of different clades in the living collection (Angiosperms, Monocots, etc). In this analysis we restrict the plants in the collection by removing cultivars. 


Note that within this report we compare the taxonomic coverage of the collection relative to accepted plants within WCVP. Therefore, we do not calculate this comparison for non-vascular plants as this is not contained within WCVP.

Any analyses over time reconstructs the existing plants in the collection on the 31st of December each year. 

***

## Number of items held by taxonomic hierarchy

Below we produce a sunburst and treemap charts to show the taxonomic diversity of the collection. Clicking on segments of the chart zooms into the segment and lower levels. To return to a higher level click on the center of the sunburst chart. This is done at the item level such that hovering over any segment shows the number of the items in the collection within the group (family, genera, species etc).

```{r, Create taxonomic diversity, echo = FALSE, message = FALSE}
report = enriched_report[enriched_report$ItemStatusType == 'Existing',]
report = report[!grepl('5',report$taxon_type), ]

#No families.
# = Use POWO family if available if not use the original.
families = data.frame(original = report$Family, POWO = report$POWO_family)
use_family = families$POWO
use_family[is.na(use_family)] = families$original[is.na(use_family)]
report$use_family = use_family
no_families <- length(unique(use_family))

#No genus
# = Use POWO genus if available if not use the original.
genus = data.frame(original = report$Genus, POWO = report$POWO_genus)
use_genus = genus$POWO
use_genus[is.na(use_genus)] = genus$original[is.na(use_genus)]
report$use_genus = use_genus
no_genus <- length(unique(use_genus))


#No species
POWO_GenusSpecies = rep(NA, nrow(report))
POWO_GenusSpecies[!is.na(report$POWO_plant_name_id)] = paste0(report$POWO_genus[!is.na(report$POWO_plant_name_id)],
                                                              ' ',
                                                              report$POWO_species[!is.na(report$POWO_plant_name_id)])
species_data = data.frame(original = report$GenusSpecies, POWO = POWO_GenusSpecies, infra = report$taxon_type)
use_genus_species = species_data$POWO
use_genus_species[is.na(use_genus_species)] = species_data$original[is.na(use_genus_species)]
report$use_genus_species= use_genus_species

report_div  = report
#restrict to only matched to POWO.
report_div = report_div[!is.na(report_div$POWO_plant_name_id),]
report_div = report_div[report_div$ItemStatusType == 'Existing',]


Diversity_class = BGSmartR::Diversity_classification
Classification <- as.data.frame(Diversity_class$Classification)
synomym_families <- as.data.frame(Diversity_class$synomym_families)

fam = report_div$POWO_family

# Convert from conserved family name to family name where applicable.
AA = apply(synomym_families, 2, function(x){
  fam[fam == as.character(x[2])] = as.character(x[1])
})
report_div$family = fam

matched_families = match(fam, Classification$family)
order = Classification$order[matched_families]
major_Eudicot_lineage = Classification$`major Eudicot lineage`[matched_families]
major_Angiosperm_lineage = Classification$`major Angiosperm lineage`[matched_families]
major_Land_Plants_lineage = Classification$`major Land Plants lineage`[matched_families]


report_div$order = order
report_div$major_Eudicot_lineage = major_Eudicot_lineage
report_div$major_Angiosperm_lineage = major_Angiosperm_lineage
report_div$major_Land_Plants_lineage = major_Land_Plants_lineage

use_species = report_div$use_genus_species |> stringr::str_split(' ')
use_species = unlist(lapply(use_species, function(x)x[2]))
report_div$use_species = use_species

report_cur = report_div

combined_taxo = paste0(report_cur$use_species,'---',
                       report_cur$use_genus,'---',
                       report_cur$use_family,'---',
                       report_cur$order,'---',
                       report_cur$major_Eudicot_lineage,'---',
                       report_cur$major_Angiosperm_lineage,'---',
                       report_cur$major_Land_Plants_lineage)

with_issue = sum(which(grepl('---NA$',combined_taxo)))

#remove those without major land plants lineage. (i.e ends in ---NA).
if(with_issue > 0){
  combined_taxo = combined_taxo[-which(grepl('---NA$',combined_taxo))]
}
# Convert NA in species to Indet.
combined_taxo[which(grepl('^NA---|^---',combined_taxo))] = stringr::str_replace(combined_taxo[which(grepl('^NA---|^---',combined_taxo))], '^NA---|^---', 'Indet.---')

table_species = table(combined_taxo)
data = data.frame(ID = names(table_species), count = as.numeric(table_species))
non_combined  = data.frame(t(data.frame(stringr::str_split(data$ID,pattern = '---'))))
names(non_combined) = c('species', 'genus', 'family', 'order', 'major_Eudicot_lineage',
                        'major_Angiosperm_lineage', 'major_Land_Plants_lineage')
rownames(non_combined) = 1:nrow(non_combined)

data = data.frame(data, non_combined)

# push species names to genus species (otherwise issues with repeated species names with different genera)
data$species = paste0(data$species,'---',data$genus)

labels = c(unique(data$major_Land_Plants_lineage), unique(data$major_Angiosperm_lineage), unique(data$major_Eudicot_lineage),
           unique(data$order), unique(data$family), unique(data$genus), unique(data$species))
major_Land_Plants_lineage_index = 1:length(unique(data$major_Land_Plants_lineage))
major_Angiosperm_lineage_index = (max(major_Land_Plants_lineage_index)+1):(max(major_Land_Plants_lineage_index)+length(unique(data$major_Angiosperm_lineage)))
major_Eudicot_lineage_index = (max(major_Angiosperm_lineage_index)+1):(max(major_Angiosperm_lineage_index)+length(unique(data$major_Eudicot_lineage)))
order_index = (max(major_Eudicot_lineage_index)+1):(max(major_Eudicot_lineage_index)+length(unique(data$order)))
family_index = (max(order_index)+1):(max(order_index)+length(unique(data$family)))
genus_index = (max(family_index)+1):(max(family_index)+length(unique(data$genus)))
species_index = (max(genus_index)+1):(max(genus_index)+length(unique(data$species)))

parents = rep('', length(labels))
parents[major_Angiosperm_lineage_index] = data$major_Land_Plants_lineage[match(labels[major_Angiosperm_lineage_index], data$major_Angiosperm_lineage)]
parents[major_Eudicot_lineage_index] = data$major_Angiosperm_lineage[match(labels[major_Eudicot_lineage_index], data$major_Eudicot_lineage)]
parents[order_index] = data$major_Eudicot_lineage[match(labels[order_index], data$order)]
parents[family_index] = data$order[match(labels[family_index], data$family)]
parents[genus_index] = data$family[match(labels[genus_index], data$genus)]
parents[species_index] = data$genus[match(labels[species_index], data$species)]

values = rep(NA, length(labels))
values[species_index] = data$count[match(labels[species_index], data$species)]
total_for_genus <-  aggregate(. ~genus, data[,c(4,2)], sum, na.rm = TRUE)
values[genus_index] = total_for_genus$count[match(labels[genus_index], total_for_genus$genus)]
total_for_families <-  aggregate(. ~family, data[,c(5,2)], sum, na.rm = TRUE)
values[family_index] = total_for_families$count[match(labels[family_index], total_for_families$family)]
total_for_order <-  aggregate(. ~order, data[,c(6,2)], sum, na.rm = TRUE)
values[order_index] = total_for_order$count[match(labels[order_index], total_for_order$order)]
total_for_major_Eudicot_lineage <-  aggregate(. ~major_Eudicot_lineage, data[,c(7,2)], sum, na.rm = TRUE)
values[major_Eudicot_lineage_index] = total_for_major_Eudicot_lineage$count[match(labels[major_Eudicot_lineage_index], total_for_major_Eudicot_lineage$major_Eudicot_lineage)]
total_for_major_Angiosperm_lineage <-  aggregate(. ~major_Angiosperm_lineage, data[,c(8,2)], sum, na.rm = TRUE)
values[major_Angiosperm_lineage_index] = total_for_major_Angiosperm_lineage$count[match(labels[major_Angiosperm_lineage_index], total_for_major_Angiosperm_lineage$major_Angiosperm_lineage)]
total_for_major_Land_Plants_lineage <-  aggregate(. ~major_Land_Plants_lineage, data[,c(9,2)], sum, na.rm = TRUE)
values[major_Land_Plants_lineage_index] = total_for_major_Land_Plants_lineage$count[match(labels[major_Land_Plants_lineage_index], total_for_major_Land_Plants_lineage$major_Land_Plants_lineage)]


data_formatted = data.frame(ID = labels, labels=labels, parents = parents, values = values)

#Go back to just species names.
data_formatted$labels[grepl('---', data_formatted$labels)] = unlist(lapply(stringr::str_split(data_formatted$labels[grepl('---', data_formatted$labels)], pattern = '---'), function(x){x[1]}))
data_formatted$ID[grepl('---', data_formatted$ID)] = unlist(lapply(stringr::str_split(data_formatted$ID[grepl('---', data_formatted$ID)], pattern = '---'), function(x){x[1]}))
# data_formatted$labels=unlist(lapply(stringr::str_split(data_formatted$labels, ' '),function(x){x[length(x)]}))
data_formatted$ID = paste0(data_formatted$labels, '---', data_formatted$parents)

data_formatted$parents = paste0(data_formatted$parents,'---',data_formatted$parents[match(data_formatted$parents, data_formatted$labels)])
data_formatted$parents[data_formatted$parents == "---NA"] =''

# Collapse levels.
data_formatted$labels[data_formatted$labels == 'None_Eudicots'] = 'Other'
data_formatted$labels[data_formatted$labels == 'None_Angiosperms'] = 'Other'

# Remove Intermediate levels.
remove_nodes = c('None_Monocots', 'None_Ferns', 'None_Ferns_Eudicot',"None_Gymnosperms", 'None_Lycophytes',   'None_Liverworts', 'None_Hornworts', 'None_Gymnosperms_Eudicot', 'None_Lycophytes_Eudicot', 'None_Liverworts_Eudicot', 'None_Hornworts_Eudicot', 'No_Mosses_Angiosperm_lineage', 'No_Mosses_Eudicot_lineage', 'None_Angiosperms_Eudicot_lineage')
AA = lapply(remove_nodes, function(node){
  # Select the row to remove (begining with "*node*---")
  to_remove = which(grepl(paste0('^',node,'---'), data_formatted$ID))
  if(length(to_remove)> 0 ){
    #Get new parent id and new label from the node to remove.
    new_parent = data_formatted[to_remove,]$parents
    new_label =  unlist(stringr::str_split(new_parent,'---'))[1]
    # Remove the row.
    data_formatted = data_formatted[-to_remove,]
    # Update End of the ID for the new parent
    data_formatted$ID[grepl(paste0(node,'$'),data_formatted$ID)] = unlist(stringr::str_replace(data_formatted$ID[grepl(paste0(node,'$'),data_formatted$ID)],paste0('---',node), paste0('---',new_label)))
    # Update the parents for each node who originally has 'node' as the value.
    data_formatted$parents[grepl(paste0('^',node, '---'),data_formatted$parents)] = new_parent
    # Update the parents for each node who originally has 'node' as the parent.
    data_formatted$parents[grepl(paste0(node,'$'),data_formatted$parents)] = unlist(stringr::str_replace(data_formatted$parents[grepl(paste0(node,'$'),data_formatted$parents)],paste0('---',node), paste0('---',new_label)))
    data_formatted <<- data_formatted # This is needed don't remove.
  }

  return()
})


# Add header of 'Collection'
data_formatted$ID[grepl('---$', data_formatted$ID)] = paste0(data_formatted$ID[grepl('---$', data_formatted$ID)] , 'Collection')
data_formatted$parents[grepl('---$', data_formatted$parents)] = paste0(data_formatted$parents[grepl('---$', data_formatted$parents)] , 'Collection')
data_formatted$parents[data_formatted$parents == ''] = 'Collection'

data_formatted[nrow(data_formatted)+1,] = c('Collection', 'Collection', '', sum(data_formatted$values[data_formatted$parents == 'Collection']))


### Add subfamily info to data_formatted
{
  #############################################################################
  ## Add subfamilies (All)
  #############################################################################
  subfamily_genus_simp = BGSmartR::subfamily_genus_simp

  for(i in 1:nrow(subfamily_genus_simp)){
    subfamily_info = subfamily_genus_simp[i,]
    subfamily_genera = unlist(stringr::str_split(subfamily_info$all_genera ,', '))
    subfamily_genera = subfamily_genera[subfamily_genera !=  ""]
    if(length(subfamily_genera) == 0){
      next
    }
    in_formatted = which(grepl(paste0(subfamily_info$family, '$'),data_formatted$ID) &
                           data_formatted$labels %in% subfamily_genera)
    if(length(in_formatted) == 0){
      next
    }
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(subfamily_info$sub_family,'---', subfamily_info$family)
    new = c(new_ID, subfamily_info$sub_family, data_want$parents[1], sum(as.numeric(data_want$values)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = subfamily_info$family, replacement = subfamily_info$sub_family)
    data_want$parents = new_ID

    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new

    # Need to also update the parents of the next tier.
    index = grepl(paste0(subfamily_info$family,'$'),data_formatted$parents) &
      grepl(paste0(paste(subfamily_genera,'$', sep =''),collapse = '|'),data_formatted$ID)
    data_formatted$parents[index] = stringr::str_replace( data_formatted$parents[index],
                                                          pattern = subfamily_info$family,
                                                          replacement = subfamily_info$sub_family)
  }
  ####### Deal with genera with no subfamily (when others in the family have a sub-family.)
  # Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
  families_with_subfamilies = unique(subfamily_genus_simp$family)
  all_subfamilies = unique(subfamily_genus_simp$sub_family)
  # Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
  for(i in 1:length(families_with_subfamilies)){
    family = families_with_subfamilies[i]
    # Fine records whose parent is the familiy in question and extract the data.

    in_formatted = which(grepl(paste0(family,'$'),data_formatted$ID))
    data_want = data_formatted[in_formatted,]

    # Check if we have any records where we have genus---family (i.e no  subfamily)
    without_subfamily = which(!data_want$labels %in% all_subfamilies)

    #If we have at least one genus-family we need to group these into no subfamily.
    if(length(without_subfamily) == 0){
      next
    }
    data_without_subfam = data_want[without_subfamily,]
    original_IDs = data_without_subfam$ID
    new_ID = paste0('No Subfamily','---', family)

    new_node = c(new_ID, 'No Subfamily', data_want$parents[1], sum(as.numeric(data_without_subfam$values)))

    data_without_subfam$ID = stringr::str_replace(data_without_subfam$ID,pattern = family, replacement = 'No Subfamily')
    data_without_subfam$parents = new_ID
    new_IDs = data_without_subfam$ID

    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted[without_subfamily],] = data_without_subfam

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new_node

    # Change lower tier information
    data_want = data_formatted$parents[data_formatted$parents %in% original_IDs]
    data_want = stringr::str_replace(data_want,
                                     pattern = family,
                                     replacement = 'No Subfamily')
    data_formatted$parents[data_formatted$parents %in% original_IDs] = data_want

  }


  #############################################################################
  ## Add tribes (All)
  #############################################################################
  tribe_genus_simp = BGSmartR::tribe_genus_simp

  for(i in 1:nrow(tribe_genus_simp)){
    tribe_info = tribe_genus_simp[i,]
    tribe_genera = unlist(stringr::str_split(tribe_info$all_genera ,', '))
    tribe_genera = tribe_genera[tribe_genera !=  ""]
    if(length(tribe_genera) == 0){
      next
    }
    in_formatted = which(grepl(paste0('--',tribe_info$sub_family, '$'),data_formatted$ID) &
                           grepl(paste0(paste('^',tribe_genera,'--',sep =''), collapse = '|'),data_formatted$ID))
    if(length(in_formatted) ==0){
      next
    }
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(tribe_info$tribe,'---', tribe_info$sub_family)
    new = c(new_ID, tribe_info$tribe, data_want$parents[1], sum(as.numeric(data_want$values)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = tribe_info$sub_family, replacement = tribe_info$tribe)
    data_want$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new

    # Need to also update the parents of the next tier.
    index = grepl(paste0(tribe_info$sub_family,'$'),data_formatted$parents) &
      grepl(paste0(paste('^',tribe_genera,'--', sep =''),collapse = '|'),data_formatted$parents)
    data_child = data_formatted[index,]
    data_child$parents = stringr::str_replace( data_child$parents,
                                               pattern = paste0(tribe_info$sub_family,'$'),
                                               replacement = tribe_info$tribe)
    data_formatted[index,] = data_child

  }

  ####### Deal with genera with no subfamily (when others in the family have a sub-family.)
  # Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
  subfamilies_with_tribes = unique(tribe_genus_simp$sub_family)
  all_tribes = unique(tribe_genus_simp$tribe)
  # ggg = data_formatted =ggg
  # Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
  for(i in 1:length(subfamilies_with_tribes)){
    # for(i in 1:19){
    subfamily = subfamilies_with_tribes[i]

    # Fine records whose parent is the family in question and extract the data.
    in_formatted = which(grepl(paste0('--',subfamily,'$'),data_formatted$ID))
    data_want = data_formatted[in_formatted,]

    # Check if we have any records where we have genus---subfamily (i.e no  subfamily)
    without_tribe = which(!data_want$labels %in% all_tribes)
    # print(i)
    # print(without_tribe)}
    #If we have at least one genus-subfamily we need to group these into no subfamily.
    if(length(without_tribe) %in% c(0,nrow(data_want)) ){
      next
    }
    data_without_tribe = data_want[without_tribe,]
    original_IDs = data_without_tribe$ID

    new_ID = paste0('No Tribe','---', subfamily)

    new_node = new = c(new_ID, 'No Tribe', data_want$parents[1], sum(as.numeric(data_without_tribe$values)))

    data_without_tribe$ID = stringr::str_replace(data_without_tribe$ID,pattern = subfamily, replacement = 'No Tribe')
    data_without_tribe$parents = new_ID
    new_IDs = data_without_tribe$ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted[without_tribe],] = data_without_tribe

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new_node

    # Change lower tier information
    data_child = data_formatted[data_formatted$parents %in% original_IDs,]
    data_child$parents = stringr::str_replace(data_child$parents,
                                              pattern = subfamily,
                                              replacement = 'No Tribe')
    data_formatted[data_formatted$parents %in% original_IDs,] = data_child

  }


  #############################################################################
  ## Add Subtribes (All)
  #############################################################################
 subtribe_genus_simp = BGSmartR::subtribe_genus_simp
  for(i in 1:nrow(subtribe_genus_simp)){
    # for(i in 1:30){
    subtribe_info = subtribe_genus_simp[i,]
    subtribe_genera = unlist(stringr::str_split(subtribe_info$all_genera ,', '))
    subtribe_genera = subtribe_genera[subtribe_genera !=  ""]
    if(length(subtribe_genera) == 0){
      next
    }
    in_formatted = which(grepl(paste0(subtribe_info$tribe, '$'),data_formatted$ID) &
                           grepl(paste0(paste('^',subtribe_info,'--',sep =''), collapse = '|'),data_formatted$ID))
    if(length(in_formatted) == 0){
      next
    }
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(subtribe_info$subtribe,'---', subtribe_info$tribe)
    new = c(new_ID, subtribe_info$subtribe, data_want$parents[1], sum(as.numeric(data_want$values)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = subtribe_info$tribe, replacement = subtribe_info$subtribe)
    data_want$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new

    # Need to also update the parents of the next tier.
    index = grepl(paste0(subtribe_info$tribe,'$'),data_formatted$parents) &
      grepl(paste0(paste('^',subtribe_genera,'--', sep =''),collapse = '|'),data_formatted$parents)
    data_child = data_formatted[index,]
    data_child$parents = stringr::str_replace( data_child$parents,
                                               pattern = paste0(subtribe_info$tribe,'$'),
                                               replacement = subtribe_info$subtribe)
    data_formatted[index,] = data_child
  }

  ####### Deal with genera with no subfamily (when others in the family have a sub-family.)
  # Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
  tribes_with_subtribes = unique(subtribe_genus_simp$tribe)
  all_subtribes = unique(subtribe_genus_simp$subtribe)
  # Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
  for(i in 1:length(tribes_with_subtribes)){
    tribe = tribes_with_subtribes[i]
    # Fine records whose parent is the familiy in question and extract the data.

    in_formatted = which(grepl(paste0('--',tribe,'$'),data_formatted$ID))
    data_want = data_formatted[in_formatted,]

    # Check if we have any records where we have genus---tribe (i.e no  tribe)
    without_subtribe = which(!data_want$labels %in% all_subtribes)

    #If we have at least one genus-tribe we need to group these into no tribe
    if(length(without_subtribe) %in% c(0,nrow(data_want))){
      next
    }

    data_without_tribe = data_want[without_subtribe,]
    original_IDs = data_without_tribe$ID

    new_ID = paste0('No Subtribe','---', tribe)

    new_node = new = c(new_ID, 'No Subtribe', data_want$parents[1], sum(as.numeric(data_without_tribe$values)))

    data_without_tribe$ID = stringr::str_replace(data_without_tribe$ID,pattern = tribe, replacement = 'No Subtribe')
    data_without_tribe$parents = new_ID
    new_IDs = data_without_tribe$ID


    # Replace original genus-family with the new genus-tribe
    data_formatted[in_formatted[without_subtribe],] = data_without_tribe

    # Add the new node for the tribe
    data_formatted[nrow(data_formatted)+1,] = new_node

    # Change lower tier information
    data_child = data_formatted[data_formatted$parents %in% original_IDs,]
    data_child$parents = stringr::str_replace(data_child$parents,
                                              pattern = tribe,
                                              replacement = 'No Subtribe')
    data_formatted[data_formatted$parents %in% original_IDs,] = data_child


  }


  #############################################################################


}


```

```{r, Create interactive taxonomic diversity figure, echo = F}
if(report_kind == 'interactive'){

  # Colour the segments depending on the highest level group they belong to.
  colours = rep('white', nrow(data_formatted))
  first_level_index = grep('--Collection$',data_formatted$ID)
  colo = scales::brewer_pal(palette = palette, direction = 1)(length(first_level_index)) |> rev()
  colours[first_level_index] = colo
  for(i in 1:length(colo)){
    col = colo[i]
    parents = data_formatted$ID[first_level_index[i]]
    while(length(parents) > 0){
      child_index = which(data_formatted$parents %in% parents)
      colours[child_index] =  col
      parents = data_formatted$ID[child_index]
    }
  }

  data_formatted$values = as.numeric(data_formatted$values)
  fig <- plotly::plot_ly(data_formatted,
                         ids = ~ID,
                         labels = ~labels,
                         parents =~parents,
                         values = ~values,
                         type = 'sunburst',
                         insidetextorientation='radial',
                         branchvalues = 'total',
                         marker=list(colors=colours, line = list(color = 'white')),
                         maxdepth = 4)

  fig2 <- plotly::plot_ly(data_formatted,
                          ids = ~ID,
                          labels = ~labels,
                          parents =~parents,
                          values = ~values,
                          type = 'treemap',
                          branchvalues = 'total',
                          marker=list(colors=colours, line = list(color = 'white')),
                          maxdepth = 4)

  if(separate_figure_folder){
    htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','sunburst:taxonomic_diversity.html'))
    htmlwidgets::saveWidget(fig2, file = paste0(figures_dir, '/','treemap:taxonomic_diversity.html'))
  }

}
```

`r if(report_kind == 'interactive'){"#####  Taxonomic Diversity {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Sunburst"}`
```{r  Sunburst, fig.fullwidth=TRUE, fig.dim = c(10, 8), eval = report_kind == 'interactive'}
fig
```

`r if(report_kind == 'interactive'){"###### Treemap"}`
```{r  tree map, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
fig2
```

`r if(report_kind == 'interactive'){"##### {-}"}`

***


## Taxonomic diversity by proportion of accepted WCVP genera held


```{r, Create taxonomic diversity genus level, echo = FALSE, message = FALSE}
report = wcvp$wcvp_names
report = report[report$taxon_status == 'Accepted',]
collection_report = enriched_report[enriched_report$ItemStatusType == 'Existing',]
LC_in_WCVP = match(unique(collection_report$POWO_plant_name_id) ,report$plant_name_id)
LC_in_WCVP = LC_in_WCVP[!is.na(LC_in_WCVP)]
in_LC = rep(F, nrow(report))
in_LC[LC_in_WCVP] = TRUE
report$in_LC = in_LC
report = report[c('family', 'genus', 'in_LC')]
report$fam_gen = paste0(report$family,' ',report$genus)
report <-  report |>
  dplyr::group_by(fam_gen) |>
  dplyr::summarise(family = family[1],
                   genus = genus[1],
                   in_LC = any(in_LC)) |>
  dplyr::ungroup()



#No families.
# = Use POWO family if available if not use the original.
no_families <- length(unique(report$family))

#No genus
# = Use POWO genus if available if not use the original.
no_genus <- length(unique(report$fam_gen))


report_div  = report

Diversity_class = BGSmartR::Diversity_classification
Classification <- as.data.frame(Diversity_class$Classification)
synomym_families <- as.data.frame(Diversity_class$synomym_families)

fam = report_div$family

# Convert from conserved family name to family name where applicable.
AA = apply(synomym_families, 2, function(x){
  fam[fam == as.character(x[2])] = as.character(x[1])
})
report_div$family = fam

matched_families = match(fam, Classification$family)
order = Classification$order[matched_families]
major_Eudicot_lineage = Classification$`major Eudicot lineage`[matched_families]
major_Angiosperm_lineage = Classification$`major Angiosperm lineage`[matched_families]
major_Land_Plants_lineage = Classification$`major Land Plants lineage`[matched_families]


report_div$order = order
report_div$major_Eudicot_lineage = major_Eudicot_lineage
report_div$major_Angiosperm_lineage = major_Angiosperm_lineage
report_div$major_Land_Plants_lineage = major_Land_Plants_lineage

report_cur = report_div

combined_taxo = paste0(report_cur$genus,'---',
                       report_cur$family,'---',
                       report_cur$order,'---',
                       report_cur$major_Eudicot_lineage,'---',
                       report_cur$major_Angiosperm_lineage,'---',
                       report_cur$major_Land_Plants_lineage)

with_issue = length(which(grepl('---NA$',combined_taxo)))
combined_taxo_count = as.numeric(report_cur$in_LC)
#remove those without major land plants lineage. (i.e ends in ---NA).
if(with_issue > 0){
  index_remove = which(grepl('---NA$',combined_taxo))
  combined_taxo = combined_taxo[-index_remove]
  combined_taxo_count = combined_taxo_count[-index_remove]
}
# Convert NA in species to Indet.
combined_taxo[which(grepl('^NA---|^---',combined_taxo))] = stringr::str_replace(combined_taxo[which(grepl('^NA---|^---',combined_taxo))], '^NA---|^---', 'Indet.---')


data = data.frame(ID = combined_taxo, count = combined_taxo_count, count_all = 1)
non_combined  = data.frame(t(data.frame(stringr::str_split(data$ID,pattern = '---'))))
names(non_combined) = c('genus', 'family', 'order', 'major_Eudicot_lineage',
                        'major_Angiosperm_lineage', 'major_Land_Plants_lineage')
rownames(non_combined) = 1:nrow(non_combined)

data = data.frame(data, non_combined)

# push species names to genus species (otherwise issues with repeated species names with different genera)

labels = c(unique(data$major_Land_Plants_lineage), unique(data$major_Angiosperm_lineage), unique(data$major_Eudicot_lineage),
           unique(data$order), unique(data$family), unique(data$genus))
major_Land_Plants_lineage_index = 1:length(unique(data$major_Land_Plants_lineage))
major_Angiosperm_lineage_index = (max(major_Land_Plants_lineage_index)+1):(max(major_Land_Plants_lineage_index)+length(unique(data$major_Angiosperm_lineage)))
major_Eudicot_lineage_index = (max(major_Angiosperm_lineage_index)+1):(max(major_Angiosperm_lineage_index)+length(unique(data$major_Eudicot_lineage)))
order_index = (max(major_Eudicot_lineage_index)+1):(max(major_Eudicot_lineage_index)+length(unique(data$order)))
family_index = (max(order_index)+1):(max(order_index)+length(unique(data$family)))
genus_index = (max(family_index)+1):(max(family_index)+length(unique(data$genus)))

parents = rep('', length(labels))
parents[major_Angiosperm_lineage_index] = data$major_Land_Plants_lineage[match(labels[major_Angiosperm_lineage_index], data$major_Angiosperm_lineage)]
parents[major_Eudicot_lineage_index] = data$major_Angiosperm_lineage[match(labels[major_Eudicot_lineage_index], data$major_Eudicot_lineage)]
parents[order_index] = data$major_Eudicot_lineage[match(labels[order_index], data$order)]
parents[family_index] = data$order[match(labels[family_index], data$family)]
parents[genus_index] = data$family[match(labels[genus_index], data$genus)]

values = rep(NA, length(labels))
values[genus_index] = data$count[match(labels[genus_index], data$genus)]
total_for_families <-  aggregate(. ~family, data[,c(5,2)], sum, na.rm = TRUE)
values[family_index] = total_for_families$count[match(labels[family_index], total_for_families$family)]
total_for_order <-  aggregate(. ~order, data[,c(6,2)], sum, na.rm = TRUE)
values[order_index] = total_for_order$count[match(labels[order_index], total_for_order$order)]
total_for_major_Eudicot_lineage <-  aggregate(. ~major_Eudicot_lineage, data[,c(7,2)], sum, na.rm = TRUE)
values[major_Eudicot_lineage_index] = total_for_major_Eudicot_lineage$count[match(labels[major_Eudicot_lineage_index], total_for_major_Eudicot_lineage$major_Eudicot_lineage)]
total_for_major_Angiosperm_lineage <-  aggregate(. ~major_Angiosperm_lineage, data[,c(8,2)], sum, na.rm = TRUE)
values[major_Angiosperm_lineage_index] = total_for_major_Angiosperm_lineage$count[match(labels[major_Angiosperm_lineage_index], total_for_major_Angiosperm_lineage$major_Angiosperm_lineage)]
total_for_major_Land_Plants_lineage <-  aggregate(. ~major_Land_Plants_lineage, data[,c(9,2)], sum, na.rm = TRUE)
values[major_Land_Plants_lineage_index] = total_for_major_Land_Plants_lineage$count[match(labels[major_Land_Plants_lineage_index], total_for_major_Land_Plants_lineage$major_Land_Plants_lineage)]
in_collection = values

values = rep(NA, length(labels))
values[genus_index] = data$count_all[match(labels[genus_index], data$genus)]
total_for_families <-  aggregate(. ~family, data[,c(5,3)], sum, na.rm = TRUE)
values[family_index] = total_for_families$count[match(labels[family_index], total_for_families$family)]
total_for_order <-  aggregate(. ~order, data[,c(6,3)], sum, na.rm = TRUE)
values[order_index] = total_for_order$count[match(labels[order_index], total_for_order$order)]
total_for_major_Eudicot_lineage <-  aggregate(. ~major_Eudicot_lineage, data[,c(7,3)], sum, na.rm = TRUE)
values[major_Eudicot_lineage_index] = total_for_major_Eudicot_lineage$count[match(labels[major_Eudicot_lineage_index], total_for_major_Eudicot_lineage$major_Eudicot_lineage)]
total_for_major_Angiosperm_lineage <-  aggregate(. ~major_Angiosperm_lineage, data[,c(8,3)], sum, na.rm = TRUE)
values[major_Angiosperm_lineage_index] = total_for_major_Angiosperm_lineage$count[match(labels[major_Angiosperm_lineage_index], total_for_major_Angiosperm_lineage$major_Angiosperm_lineage)]
total_for_major_Land_Plants_lineage <-  aggregate(. ~major_Land_Plants_lineage, data[,c(9,3)], sum, na.rm = TRUE)
values[major_Land_Plants_lineage_index] = total_for_major_Land_Plants_lineage$count[match(labels[major_Land_Plants_lineage_index], total_for_major_Land_Plants_lineage$major_Land_Plants_lineage)]
total_wcvp = values


data_formatted = data.frame(ID = labels, labels=labels, parents = parents, values = total_wcvp,  in_LC = in_collection)

#Go back to just species names.
data_formatted$labels[grepl('---', data_formatted$labels)] = unlist(lapply(stringr::str_split(data_formatted$labels[grepl('---', data_formatted$labels)], pattern = '---'), function(x){x[1]}))
data_formatted$ID[grepl('---', data_formatted$ID)] = unlist(lapply(stringr::str_split(data_formatted$ID[grepl('---', data_formatted$ID)], pattern = '---'), function(x){x[1]}))
# data_formatted$labels=unlist(lapply(stringr::str_split(data_formatted$labels, ' '),function(x){x[length(x)]}))
data_formatted$ID = paste0(data_formatted$labels, '---', data_formatted$parents)

data_formatted$parents = paste0(data_formatted$parents,'---',data_formatted$parents[match(data_formatted$parents, data_formatted$labels)])
data_formatted$parents[data_formatted$parents == "---NA"] =''

# Collapse levels.
data_formatted$labels[data_formatted$labels == 'None_Eudicots'] = 'Other'
data_formatted$labels[data_formatted$labels == 'None_Angiosperms'] = 'Other'

# Remove Intermediate levels.
remove_nodes = c('None_Monocots', 'None_Ferns', 'None_Ferns_Eudicot',"None_Gymnosperms", 'None_Lycophytes',   'None_Liverworts', 'None_Hornworts', 'None_Gymnosperms_Eudicot', 'None_Lycophytes_Eudicot', 'None_Liverworts_Eudicot', 'None_Hornworts_Eudicot', 'No_Mosses_Angiosperm_lineage', 'No_Mosses_Eudicot_lineage', 'None_Angiosperms_Eudicot_lineage')
AA = lapply(remove_nodes, function(node){
  # Select the row to remove (begining with "*node*---")
  to_remove = which(grepl(paste0('^',node,'---'), data_formatted$ID))
  if(length(to_remove)> 0 ){
    #Get new parent id and new label from the node to remove.
    new_parent = data_formatted[to_remove,]$parents
    new_label =  unlist(stringr::str_split(new_parent,'---'))[1]
    # Remove the row.
    data_formatted = data_formatted[-to_remove,]
    # Update End of the ID for the new parent
    data_formatted$ID[grepl(paste0(node,'$'),data_formatted$ID)] = unlist(stringr::str_replace(data_formatted$ID[grepl(paste0(node,'$'),data_formatted$ID)],paste0('---',node), paste0('---',new_label)))
    # Update the parents for each node who originally has 'node' as the value.
    data_formatted$parents[grepl(paste0('^',node, '---'),data_formatted$parents)] = new_parent
    # Update the parents for each node who originally has 'node' as the parent.
    data_formatted$parents[grepl(paste0(node,'$'),data_formatted$parents)] = unlist(stringr::str_replace(data_formatted$parents[grepl(paste0(node,'$'),data_formatted$parents)],paste0('---',node), paste0('---',new_label)))
    data_formatted <<- data_formatted #This is needed don't remove
  }

  return()
})


# Add header of 'Collection'
data_formatted$ID[grepl('---$', data_formatted$ID)] = paste0(data_formatted$ID[grepl('---$', data_formatted$ID)] , 'WCVP')
data_formatted$parents[grepl('---$', data_formatted$parents)] = paste0(data_formatted$parents[grepl('---$', data_formatted$parents)] , 'WCVP')
data_formatted$parents[data_formatted$parents == ''] = 'WCVP'

data_formatted[nrow(data_formatted)+1,] = c('WCVP', 'WCVP', '', sum(data_formatted$values[data_formatted$parents == 'WCVP']), sum(data_formatted$in_LC[data_formatted$parents == 'WCVP']) )




### Add subfamily info to data_formatted
{
  #############################################################################
  ## Add subfamilies (All)
  #############################################################################
  subfamily_genus_simp = BGSmartR::subfamily_genus_simp

  for(i in 1:nrow(subfamily_genus_simp)){
    # for(i in 1:30){
    subfamily_info = subfamily_genus_simp[i,]
    subfamily_genera = unlist(stringr::str_split(subfamily_info$all_genera ,', '))
    subfamily_genera = subfamily_genera[subfamily_genera !=  ""]
    if(length(subfamily_genera) == 0){
      next
    }
    in_formatted = which(grepl(paste0(subfamily_info$family, '$'),data_formatted$ID) &
                           data_formatted$labels %in% subfamily_genera)
    if(length(in_formatted) >0){
      data_want = data_formatted[in_formatted,]
      new_ID = paste0(subfamily_info$sub_family,'---', subfamily_info$family)
      new = c(new_ID, subfamily_info$sub_family, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
      data_want$ID = stringr::str_replace(data_want$ID,pattern = subfamily_info$family, replacement = subfamily_info$sub_family)
      data_want$parents = new_ID


      # Replace original genus-family with the new genus-subfamily.
      data_formatted[in_formatted,] = data_want

      # Add the new node for the subfamily.
      data_formatted[nrow(data_formatted)+1,] = new
    }
  }

  ####### Deal with genera with no subfamily (when others in the family have a sub-family.)
  # Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
  families_with_subfamilies = unique(subfamily_genus_simp$family)
  all_subfamilies = unique(subfamily_genus_simp$sub_family)
  # Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
  for(i in 1:length(families_with_subfamilies)){
    family = families_with_subfamilies[i]
    # Fine records whose parent is the familiy in question and extract the data.

    in_formatted = which(grepl(paste0(family,'$'),data_formatted$ID))
    data_want = data_formatted[in_formatted,]

    # Check if we have any records where we have genus---family (i.e no  subfamily)
    without_subfamily = which(!data_want$labels %in% all_subfamilies)

    #If we have at least one genus-family we need to group these into no subfamily.
    if(length(without_subfamily) > 0){
      data_without_subfam = data_want[without_subfamily,]

      new_ID = paste0('No Subfamily','---', family)

      new_node = new = c(new_ID, 'No Subfamily', data_want$parents[1], sum(as.numeric(data_without_subfam$values)), sum(as.numeric(data_without_subfam$in_LC)))

      data_without_subfam$ID = stringr::str_replace(data_without_subfam$ID,pattern = family, replacement = 'No Subfamily')
      data_without_subfam$parents = new_ID


      # Replace original genus-family with the new genus-subfamily.
      data_formatted[in_formatted[without_subfamily],] = data_without_subfam

      # Add the new node for the subfamily.
      data_formatted[nrow(data_formatted)+1,] = new_node
    }

  }

  #############################################################################
  ## Add tribes (All)
  #############################################################################
 tribe_genus_simp = BGSmartR::tribe_genus_simp
  for(i in 1:nrow(tribe_genus_simp)){
    # for(i in 1:30){
    tribe_info = tribe_genus_simp[i,]
    tribe_genera = unlist(stringr::str_split(tribe_info$all_genera ,', '))
    tribe_genera = tribe_genera[tribe_genera !=  ""]
    if(length(tribe_genera) == 0){
      next
    }
    in_formatted = which(grepl(paste0(tribe_info$sub_family, '$'),data_formatted$ID) &
                           data_formatted$labels %in% tribe_genera)
    if(length(in_formatted) >0){
      data_want = data_formatted[in_formatted,]
      new_ID = paste0(tribe_info$tribe,'---', tribe_info$sub_family)
      new = c(new_ID, tribe_info$tribe, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
      data_want$ID = stringr::str_replace(data_want$ID,pattern = tribe_info$sub_family, replacement = tribe_info$tribe)
      data_want$parents = new_ID


      # Replace original genus-family with the new genus-subfamily.
      data_formatted[in_formatted,] = data_want

      # Add the new node for the subfamily.
      data_formatted[nrow(data_formatted)+1,] = new
    }
  }

  ####### Deal with genera with no subfamily (when others in the family have a sub-family.)
  # Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
  subfamilies_with_tribes = unique(tribe_genus_simp$sub_family)
  all_tribes = unique(tribe_genus_simp$tribe)
  # Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
  for(i in 1:length(subfamilies_with_tribes)){
    subfamily = subfamilies_with_tribes[i]
    # Fine records whose parent is the familiy in question and extract the data.

    in_formatted = which(grepl(paste0(subfamily,'$'),data_formatted$ID))
    data_want = data_formatted[in_formatted,]

    # Check if we have any records where we have genus---subfamily (i.e no  subfamily)
    without_tribe = which(!data_want$labels %in% all_tribes)

    #If we have at least one genus-subfamily we need to group these into no subfamily.
    if(length(without_tribe) > 0){
      data_without_tribe = data_want[without_tribe,]

      new_ID = paste0('No Tribe','---', subfamily)

      new_node = new = c(new_ID, 'No Tribe', data_want$parents[1], sum(as.numeric(data_without_tribe$values)), sum(as.numeric(data_without_tribe$in_LC)))

      data_without_tribe$ID = stringr::str_replace(data_without_tribe$ID,pattern = subfamily, replacement = 'No Tribe')
      data_without_tribe$parents = new_ID


      # Replace original genus-family with the new genus-subfamily.
      data_formatted[in_formatted[without_tribe],] = data_without_tribe

      # Add the new node for the subfamily.
      data_formatted[nrow(data_formatted)+1,] = new_node
    }

  }


  #############################################################################
  ## Add Subtribes (All)
  #############################################################################
 subtribe_genus_simp = BGSmartR::subtribe_genus_simp

  for(i in 1:nrow(subtribe_genus_simp)){
    # for(i in 1:30){
    subtribe_info = subtribe_genus_simp[i,]
    subtribe_genera = unlist(stringr::str_split(subtribe_info$all_genera ,', '))
    subtribe_genera = subtribe_genera[subtribe_genera !=  ""]
    if(length(subtribe_genera) == 0){
      next
    }
    in_formatted = which(grepl(paste0(subtribe_info$tribe, '$'),data_formatted$ID) &
                           data_formatted$labels %in% subtribe_genera)
    if(length(in_formatted) == 0){
      next
    }
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(subtribe_info$subtribe,'---', subtribe_info$tribe)
    new = c(new_ID, subtribe_info$subtribe, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = subtribe_info$tribe, replacement = subtribe_info$subtribe)
    data_want$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new
  }

  ####### Deal with genera with no subfamily (when others in the family have a sub-family.)
  # Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
  tribes_with_subtribes = unique(subtribe_genus_simp$tribe)
  all_subtribes = unique(subtribe_genus_simp$subtribe)
  # Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
  for(i in 1:length(tribes_with_subtribes)){
    tribe = tribes_with_subtribes[i]
    # Fine records whose parent is the familiy in question and extract the data.

    in_formatted = which(grepl(paste0(tribe,'$'),data_formatted$ID))
    data_want = data_formatted[in_formatted,]

    # Check if we have any records where we have genus---tribe (i.e no  tribe)
    without_subtribe = which(!data_want$labels %in% all_subtribes)

    #If we have at least one genus-tribe we need to group these into no tribe
    if(length(without_subtribe) > 0){
      data_without_tribe = data_want[without_subtribe,]

      new_ID = paste0('No Subtribe','---', tribe)

      new_node = new = c(new_ID, 'No Subtribe', data_want$parents[1], sum(as.numeric(data_without_tribe$values)), sum(as.numeric(data_without_tribe$in_LC)))

      data_without_tribe$ID = stringr::str_replace(data_without_tribe$ID,pattern = tribe, replacement = 'No Subtribe')
      data_without_tribe$parents = new_ID


      # Replace original genus-family with the new genus-tribe
      data_formatted[in_formatted[without_subtribe],] = data_without_tribe

      # Add the new node for the tribe
      data_formatted[nrow(data_formatted)+1,] = new_node
    }

  }


  #############################################################################

}


data_formatted$percentage = as.numeric(data_formatted$in_LC) / as.numeric(data_formatted$values)
rbPal <- colorRampPalette(c("#FEEDDE", "#FDD0A2", "#FDAE6B", "#FD8D3C", "#F16913", "#D94801", "#8C2D04"))
data_formatted$Col <- rbPal(100)[as.numeric(cut(data_formatted$percentage,breaks = 100))]

data_formatted$hover = paste0(round(data_formatted$percentage*100,digits = 2),'% of ', data_formatted$labels, ' genera found within the LC (',data_formatted$in_LC,'/',data_formatted$values,')')
```

```{r, Create  taxonomic diversity at genus with contained/missing, echo = F}
if(report_kind == 'interactive'){
  data_formatted$values = as.numeric(data_formatted$values)
  fig <- plotly::plot_ly(data_formatted,
                         ids = ~ID,
                         labels = ~labels,
                         parents =~parents,
                         values = ~values,
                         type = 'sunburst',
                         insidetextorientation='radial',
                         branchvalues = 'total',
                         maxdepth = 3,
                         marker=list(colors=data_formatted$Col, line = list(color = 'white')),
                         hoverinfo = "text",  hovertext = data_formatted$hover
  )

  fig2 <- plotly::plot_ly(data_formatted,
                          ids = ~ID,
                          labels = ~labels,
                          parents =~parents,
                          values = ~values,
                          type = 'treemap',
                          branchvalues = 'total',
                          maxdepth = 4,
                          marker=list(colors=data_formatted$Col, line = list(color = 'white')),
                          hoverinfo = "text",  hovertext = data_formatted$hover)

  if(separate_figure_folder){
    htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','sunburst:taxonomic_diversity.html'))
    htmlwidgets::saveWidget(fig2, file = paste0(figures_dir, '/','treemap:taxonomic_diversity.html'))
  }

}
```

In this section we create sunburst and treemap charts showing all the (accepted) genera within WCVP, where the genera are grouped into families, order and higher level lineages. The charts are shaded between light and darker shades of orange depending on the proportion of the lineage's genera found in the collection.

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Sunburst"}`
```{r  Sunburst genera, fig.fullwidth=TRUE, fig.dim = c(10, 8), eval = report_kind == 'interactive'}
fig
```

`r if(report_kind == 'interactive'){"###### Treemap"}`
```{r  tree map genera, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
fig2
```

`r if(report_kind == 'interactive'){"##### {-}"}`

***


## Representation of plant lineages

```{r ,What proportion of the plants linearage is represented in a LC, echo = F}
# Get the families contained in each group.
major_groups = c("Lycophytes", "Ferns", "Gymnosperms", "Angiosperms" 
                 # "Bryophytes", "Hornworts", "Liverworts", "Mosses"
)
Angiosperm_groups = c('Eudicots', 'Monocots')
Eudicot_groups = c('Asterids', 'Rosids')
fam_major_groups = lapply(major_groups, function(group){
  PlantClassification$family[PlantClassification$`major Land Plants lineage` == group]
})
names(fam_major_groups) = major_groups

fam_Angiosperm_groups = lapply(Angiosperm_groups, function(group){
  PlantClassification$family[PlantClassification$`major Angiosperm lineage` == group]
})
names(fam_Angiosperm_groups) = Angiosperm_groups

fam_Eudicot_groups = lapply(Eudicot_groups, function(group){
  PlantClassification$family[PlantClassification$`major Eudicot lineage` == group]
})
names(fam_Eudicot_groups) = Eudicot_groups

families_of_groups = c(fam_major_groups, fam_Angiosperm_groups, fam_Eudicot_groups)

# total from accepted WCVP records
wcvp_new = wcvp$wcvp_names
wcvp_new = wcvp_new[which(wcvp_new$taxon_status == 'Accepted'),]
wcvp_species = wcvp_new[which(wcvp_new$taxon_rank == 'Species'),]
wcvp_genera = wcvp_new[which(wcvp_new$taxon_rank == 'Genus'),]
rm(wcvp_new)
no_species_genera_wcvp = data.frame(t(data.frame(lapply(families_of_groups, function(group){
  c(length(which(wcvp_species$family %in% group)),
    length(which(wcvp_genera$family %in% group)))
}))))
no_species_genera_wcvp$group = row.names(no_species_genera_wcvp)
names(no_species_genera_wcvp) = c('Number of Species', 'Number of Genera', 'Group')
no_species_genera_wcvp = no_species_genera_wcvp[,c(3,1,2)]

# since we are matching to group counts to WCVP only consider records that we managed to match to WCVP.
report_existing = enriched_report[enriched_report$ItemStatusType == 'Existing',]
items_orig = nrow(report_existing)
report_existing = report_existing[which(!is.na(report_existing$POWO_plant_name_id)),]
items_in_wcvp = nrow(report_existing)

GenusSpecies = paste0(report_existing$POWO_genus, ' ', report_existing$POWO_species)
report_existing$GenusSpecies_new = GenusSpecies

report_existing_species = report_existing[match(unique(GenusSpecies), report_existing$GenusSpecies_new ),]
unique_species = nrow(report_existing_species)

report_existing_genus = report_existing[match(unique(report_existing$POWO_genus), report_existing$POWO_genus ),]
unique_genera = nrow(report_existing_genus)

no_species_genera_collection = data.frame(t(data.frame(lapply(families_of_groups, function(group){
  c(length(which(report_existing_species$POWO_family %in% group)),
    length(which(report_existing_genus$POWO_family %in% group)))
}))))
no_species_genera_collection$group = row.names(no_species_genera_collection)
names(no_species_genera_collection) = c('Number of Species', 'Number of Genera', 'Group')
no_species_genera_collection = no_species_genera_collection[,c(3,1,2)]
# DT::datatable(no_species_genera_collection, rownames = FALSE, options = list(scrollX =  TRUE, pageLength =  min(nrow(no_species_genera_collection),200)), escape = FALSE)

# As proportion of group.
prop = no_species_genera_collection
prop$`Number of Species` = paste0(round(no_species_genera_collection$`Number of Species` / no_species_genera_wcvp$`Number of Species` *100, digits = 3),'%')
prop$`Number of Genera` = paste0(round(no_species_genera_collection$`Number of Genera` / no_species_genera_wcvp$`Number of Genera` *100, digits = 3),'%')

# DT::datatable(prop, rownames = FALSE, options = list(scrollX =  TRUE, pageLength =  min(nrow(prop),200)), escape = FALSE)

to_show = no_species_genera_collection
to_show$`Number of Species` = paste0(to_show$`Number of Species`, '/',no_species_genera_wcvp$`Number of Species`)
to_show$`Number of Genera` = paste0(to_show$`Number of Genera`, '/',no_species_genera_wcvp$`Number of Genera`)
to_show$percent_species  = paste0(round(no_species_genera_collection$`Number of Species` / no_species_genera_wcvp$`Number of Species` *100, digits = 2),'%')
to_show$percent_genera  = paste0(round(no_species_genera_collection$`Number of Genera` / no_species_genera_wcvp$`Number of Genera` *100, digits = 2),'%')
to_show = to_show[,c(1,2,4,3,5)]
names(to_show) = c('Group', 'Number of species', 'Percentage of species', 'Number of genera', 'Percentage of genera')

groups = no_species_genera_collection$Group
prop_species = round(no_species_genera_collection$`Number of Species` / no_species_genera_wcvp$`Number of Species` *100, digits = 3)

plot_data_species = data.frame(groups =groups, 
                               prop_species = prop_species,
                               prop_species_NO = 100-prop_species)
plot_data_species = plot_data_species[!is.nan(plot_data_species$prop_species),]
plot_data_species$groups = factor(plot_data_species$groups,
                                  levels = c('Lycophytes', 'Ferns', 'Gymnosperms', 'Angiosperms', 'Monocots', 'Eudicots', 'Rosids', 'Asterids'))
fig <- plot_ly(plot_data_species, x = ~groups, y = ~prop_species, type = 'bar', name = 'Represented in collection', marker = list(color = color_binary[2]),
               hovertemplate = paste('%{y:.2f}%'))
fig <- fig %>% add_trace(y = ~prop_species_NO, name = 'Not represented in collection', marker = list(color = color_binary[1]))
fig <- fig %>% layout(yaxis = list(title = 'Percentage of Species in Group'),
                      xaxis = list(title = 'Lineage'), barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified')

fig_species = fig


groups = no_species_genera_collection$Group
prop_genera = round(no_species_genera_collection$`Number of Genera` / no_species_genera_wcvp$`Number of Genera` *100, digits = 3)

plot_data_species = data.frame(groups =groups, 
                               prop_genera = prop_genera,
                               prop_genera_NO = 100-prop_genera)
plot_data_species = plot_data_species[!is.nan(plot_data_species$prop_genera),]
plot_data_species$groups = factor(plot_data_species$groups,
                                  levels = c('Lycophytes', 'Ferns', 'Gymnosperms', 'Angiosperms', 'Monocots', 'Eudicots', 'Rosids', 'Asterids'))
fig <- plot_ly(plot_data_species, x = ~groups, y = ~prop_genera, type = 'bar', name = 'Represented in collection', marker = list(color = color_binary[2]), hovertemplate = paste('%{y:.2f}%'))
fig <- fig %>% add_trace(y = ~prop_genera_NO, name = 'Not represented in collection', marker = list(color = color_binary[1]))
fig <- fig %>% layout(yaxis = list(title = 'Percentage of genera in group'),
                      xaxis = list(title = 'Lineage'), barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified')

fig_genera = fig
```

In this section we explore the proportion of plant lineages represented in the living collection by species or genus. We use WCVP to find the total number of plants within each lineage .In the collection we have `r format(items_orig, big.mark =',')` existing items of which `r format(items_in_wcvp, big.mark =',')` were found to be in WCVP Of these items there are `r format(unique_species, big.mark =',')` unique taxa which is composed of `r format(unique_genera, big.mark =',')` genera. 

`r if(report_kind == 'interactive'){"#####   {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Table"}`
```{r  table of species + genera representation, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'}
# DT::datatable(to_show,  options = list(dom = 't'), rownames = FALSE)

to_show |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(to_show), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=F,
                                 ordering=F))
```

`r if(report_kind == 'interactive'){"###### Genera"}`
```{r  representation of genera figure, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'}
fig_genera
```

`r if(report_kind == 'interactive'){"###### Species"}`
```{r  representation of species figure, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'}
fig_species
```

`r if(report_kind == 'interactive'){"##### {-}"}`

***


## Representation of plant lineages over time

In this section we look at how the coverage of plant lineages have changed over time in the living collection. 

```{r, echo = FALSE}
report = enriched_report

# The current year.
year_cur = as.numeric(format(Sys.Date(),'%Y'))

# Get which items are existing each year in the collection.
years = min_year:year_cur
date = paste0(years, '-12-31')

# Add Genus species columns from WCVP.
GenusSpecies = paste0(report$POWO_genus, ' ', report$POWO_species)
report$GenusSpecies_new = GenusSpecies

if(!is.null(old_accession_year_codes)){
  has_old_accessions_code = which(report$AccYear %in% old_accession_year_codes)
  no_old_accessions = length(has_old_accessions_code)
  report$AccYear[has_old_accessions_code] = earliest_allowable_record
}

# Get the species/genera that are existing
plant_existing = BGSmartR::exist_at_date(date, AccessionYear = report$AccYear,
                                         ItemStatusDate = report$ItemStatusDate,
                                         ItemStatusType = report$ItemStatusType,
                                         post_date = '3000-01-01')

# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing, function(x){
  garden_current = report[x,]
  
  # Reduce garden_current to unique species and genera.
  report_species = garden_current[match(unique(garden_current$GenusSpecies_new), garden_current$GenusSpecies_new ),]
  report_genus = garden_current[match(unique(garden_current$POWO_genus), garden_current$POWO_genus ),]
  
  no_species_group = unlist(lapply(families_of_groups, function(group){
    length(which(report_species$POWO_family %in% group))
  }))
  
  no_genera_group = unlist(lapply(families_of_groups, function(group){
    length(which(report_genus$POWO_family %in% group))
  }))
  
  return(list(species = no_species_group, genera = no_genera_group))
})

# Separate out genera and speceis into two data frames.
species_over_time = data.frame(t(data.frame(lapply(over_time_info, function(x){x$species}))))
genera_over_time = data.frame(t(data.frame(lapply(over_time_info, function(x){x$genera}))))
species_over_time = data.frame(date = date, species_over_time)
genera_over_time = data.frame(date = date, genera_over_time)

# DT::datatable(species_over_time, rownames = FALSE, options = list(scrollY = '70vh', scrollX =  TRUE, pageLength =  min(nrow(species_over_time),200)), escape = FALSE)
# 
# DT::datatable(genera_over_time, rownames = FALSE, options = list(scrollY = '70vh', scrollX =  TRUE, pageLength =  min(nrow(genera_over_time),200)), escape = FALSE)

```

```{r, plots for representation over time}
to_do = c("Lycophytes", "Ferns", "Gymnosperms", "Angiosperms", 'Monocots', 'Eudicots', 'Rosids','Asterids')
# Species percentage.
figs = list()
# for(i in 1:length(to_do)){
#   species_count = species_over_time[match(to_do[i], names(species_over_time))]
#   species_percent = round(species_count/no_species_genera_wcvp$`Number of Species`[which(no_species_genera_wcvp$Group == to_do[i])]*100, digits = 3)
# 
#   plot_data_species = data.frame(date =date,
#                                  species_percent = species_percent,
#                                  prop_species_NO = 100-species_percent)
#   names(plot_data_species) = c('dates', 'percent_in', 'percent_not_in')
#   plot_data_species$year = stringr::str_extract(plot_data_species$dates, pattern = '[0-9]{4}')
#   fig <- plot_ly(plot_data_species, x = ~year, y = ~percent_in, type = 'bar', showlegend = FALSE, marker = list(color = color_binary[2]), hovertemplate = paste('%{y:.2f}%'), name = 'Represented In Collection')
#   fig <- fig |> add_trace(y = ~percent_not_in, showlegend = FALSE, name = 'Not Represented In Collection', marker = list(color = color_binary[1]))
#   fig <- fig |> layout(yaxis = list(title = 'Percentage of species'),
#                        xaxis = list(title = 'Year'),
#                        barmode = 'stack')
#   fig <- fig |> layout(title = paste0('Taxonomic coverage of ', to_do[i]))
#   fig <- fig |> layout(legend = list(orientation = 'h', x = 0, y = 1.2))
#   fig <- fig |>layout(
#     margin = list(
#       l = 50,
#       r = 50,
#       b = 100,
#       t = 77,
#       pad = 1
#     ))
#   fig <- fig |> layout(hovermode = 'x unified')
#   fig1= fig
# 
# 
#   genera_count = genera_over_time[match(to_do[i], names(genera_over_time))]
#   genera_percent = round(genera_count/no_species_genera_wcvp$`Number of Genera`[which(no_species_genera_wcvp$Group == to_do[i])]*100, digits = 3)
# 
#   plot_data_genera = data.frame(date =date,
#                                 species_percent = genera_percent,
#                                 prop_species_NO = 100-genera_percent)
#   names(plot_data_genera) = c('dates', 'percent_in', 'percent_not_in')
#   plot_data_genera$year = stringr::str_extract(plot_data_genera$dates, pattern = '[0-9]{4}')
#   fig <- plot_ly(plot_data_genera, x = ~year, y = ~percent_in, type = 'bar', name = 'Represented In Collection', marker = list(color = color_binary[2]), hovertemplate = paste('%{y:.2f}%'))
#   fig <- fig |> add_trace(y = ~percent_not_in, name = 'Not Represented In Collection', marker = list(color = color_binary[1]))
#   fig <- fig |> layout(yaxis = list(title = 'Percentage of genera'),
#                        xaxis = list(title = 'Year'),
#                        barmode = 'stack')
#   fig <- fig |> layout(legend = list(orientation = 'h', x = 0, y = 1.2))
#   fig <- fig |>layout(
#     margin = list(
#       l = 50,
#       r = 50,
#       b = 100,
#       t = 50,
#       pad = 1
#     ))
#   fig <- fig |> layout(hovermode = 'x unified')
# 
#   fig2 =fig
# 
# 
#   fig = manipulateWidget::combineWidgets(fig1, fig2, nrow = 1)
#   figs[[i]] = fig
# }
# names(figs) = to_do

#  Fig 1 for genera.
fig_genera = plot_ly(type = 'scatter', mode = 'lines')
fig_species = plot_ly(type = 'scatter', mode = 'lines')
colours_cont = scales::brewer_pal(palette = palette, direction = 1)(6)
ramp <- scales::colour_ramp(colours_cont)
colours = ramp(seq(0, 1, length = length(to_do)+2))[-c(1,2)]

for(i in 1:length(to_do)){
   genera_count = genera_over_time[match(to_do[i], names(genera_over_time))]
  genera_percent = round(genera_count/no_species_genera_wcvp$`Number of Genera`[which(no_species_genera_wcvp$Group == to_do[i])]*100, digits = 2)

  plot_data_genera = data.frame(date =date,
                                species_percent = genera_percent,
                                prop_species_NO = 100-genera_percent)
  names(plot_data_genera) = c('dates', 'percent_in', 'percent_not_in')
    # plot_data_genera$percent_in =  plot_data_genera$percent_in |> round(2)

  plot_data_genera$year = stringr::str_extract(plot_data_genera$dates, pattern = '[0-9]{4}') |> as.numeric()
  fig_genera = fig_genera |> add_trace(y = ~percent_in,
                                       x = ~year,
                                       line = list(color = colours[i]),
                                       name = to_do[i],
                                       type = 'scatter',
                                       mode = 'lines',
                                       inherit = F,
                                       data = plot_data_genera)
  
  
  species_count = species_over_time[match(to_do[i], names(species_over_time))]
  species_percent = round(species_count/no_species_genera_wcvp$`Number of Species`[which(no_species_genera_wcvp$Group == to_do[i])]*100, digits = 2)

  plot_data_species = data.frame(date =date,
                                 species_percent = species_percent,
                                 prop_species_NO = 100-species_percent)
  names(plot_data_species) = c('dates', 'percent_in', 'percent_not_in')
  # plot_data_species$percent_in =  plot_data_species$percent_in |> digits(2)
  
  plot_data_species$year = stringr::str_extract(plot_data_species$dates, pattern = '[0-9]{4}') |> as.numeric()
  fig_species = fig_species |> add_trace(y = ~percent_in,
                                       x = ~year,
                                       line = list(color = colours[i]),
                                       name = to_do[i],
                                       type = 'scatter',
                                       mode = 'lines',
                                       inherit = F,
                                       data = plot_data_species)
  

}
fig_genera <- fig_genera |> layout(yaxis = list(title = 'Percentage of genera',
                                                ticksuffix =  '%',
                                                yhoverformat = '.2%'),
                                   xaxis = list(title = 'Year'),
                                   hovermode = 'x unified')
fig_species <- fig_species |> layout(yaxis = list(title = 'Percentage of species', ticksuffix =  '%'),
                  xaxis = list(title = 'Year'),
                  hovermode = 'x unified')

```


`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Species"}`
```{r  representation over time Gymnosperms, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
fig_species
```

`r if(report_kind == 'interactive'){"###### Genera"}`
```{r  representation over time Eudicots, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
fig_genera
```

`r if(report_kind == 'interactive'){"##### {-}"}`

***

## Trends in plant lineages

```{r, echo = F, fig.fullwidth=TRUE, fig.dim = c(10, 6)}
report = enriched_report
report = report[!is.na(report$POWO_plant_name_id),]

# The current year.
year_cur = as.numeric(format(Sys.Date(),'%Y'))

# Get which items are existing each year in the collection.
years = min_year:year_cur
date = paste0(years, '-01-01')

# Add Genus species columns from WCVP.
GenusSpecies = paste0(report$POWO_genus, ' ', report$POWO_species)
report$GenusSpecies_new = GenusSpecies

if(!is.null(old_accession_year_codes)){
  has_old_accessions_code = which(report$AccYear %in% old_accession_year_codes)
  no_old_accessions = length(has_old_accessions_code)
  report$AccYear[has_old_accessions_code] = earliest_allowable_record
}

# Get the species/genera that are existing
plant_existing = BGSmartR::exist_at_date(date, AccessionYear = report$AccYear,
                                         ItemStatusDate = report$ItemStatusDate,
                                         ItemStatusType = report$ItemStatusType)


# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing, function(x){
  garden_current = report[x,]
  
  # Reduce garden_current to unique species and genera.
  report_species = garden_current[match(unique(garden_current$GenusSpecies_new), garden_current$GenusSpecies_new ),]
  report_accessions = garden_current[match(unique(garden_current$AccNoFull), garden_current$AccNoFull ),]
  
  total_taxa = nrow(report_species)
  total_accessions = nrow(report_accessions)
  # to_do = c("Bryophytes", "Ferns", "Gymnosperms", "Lycophytes", 'Eudicots', 'Monocots')
  to_do = c("Lycophytes", "Ferns", "Gymnosperms", "Angiosperms", 'Monocots', 'Eudicots', 'Rosids','Asterids')

  # For accessions first.
  grouped = rep('', nrow(report_accessions))
  for(i in 1:length(to_do)){
    index = which(report_accessions$POWO_family %in% families_of_groups[[to_do[i]]])
    grouped[index] = paste0(grouped[index], ', ', to_do[i])
  }
  grouped = stringr::str_remove(grouped, '^, ')
  grouped[grouped == ''] = 'Other'
  
  count = rep(NA, length(to_do))
for(i in 1:length(to_do)){
  count[i] = sum(grepl(to_do[i], grouped))
}
accessions = data.frame(grouped = to_do, Freq = count)
  
  accessions$prop = round(accessions$Freq/total_accessions*100,digits = 3)
  # For taxa next
  grouped = rep('', nrow(report_species))
  for(i in 1:length(to_do)){
    index = which(report_species$POWO_family %in% families_of_groups[[to_do[i]]])
    grouped[index] = paste0(grouped[index], ', ', to_do[i])
  }
  grouped = stringr::str_remove(grouped, '^, ')
  grouped[grouped == ''] = 'Other'
  
    count = rep(NA, length(to_do))
for(i in 1:length(to_do)){
  count[i] = sum(grepl(to_do[i], grouped))
}
taxa = data.frame(grouped = to_do, Freq = count)
  
  
  # taxa = data.frame(table(grouped))
  taxa$prop = round(taxa$Freq/total_taxa*100,digits = 3)
  
  return(list(taxa = taxa, accessions = accessions))
})

# Get the proportions for each year (taxa).
taxa_data = NULL
for(i in 1:length(over_time_info)){
  taxa_data = rbind(taxa_data, data.frame(year = rep(names(over_time_info)[i],nrow(over_time_info[[i]]$taxa)),over_time_info[[i]]$taxa))
}
```


```{r, echo = F,fig.fullwidth=TRUE, fig.dim = c(10, 5)}
to_do = c("Lycophytes", "Ferns", "Gymnosperms", "Angiosperms", 'Monocots', 'Eudicots', 'Rosids','Asterids')
taxa_data$grouped = factor(taxa_data$grouped, levels = to_do)
taxa_data$year = stringr::str_extract(taxa_data$year, pattern = '[0-9]{4}')

colours_cont = scales::brewer_pal(palette = palette, direction = 1)(6)
ramp <- scales::colour_ramp(colours_cont)
colours = ramp(seq(0, 1, length = length(to_do)+2))[-c(1,2)]

fig = plot_ly(taxa_data, x = ~year, y = ~Freq, type = 'scatter', mode = 'lines', colors =  colours,
name = ~grouped, color = ~grouped) %>%
layout(yaxis = list(title = 'Number of taxa'))
fig <- fig |> layout(hovermode = 'x unified')
fig <- fig |> layout(title = '', 
xaxis = list(title = 'Year'))

fig
```

***


## Taxonomic composition of the living collection 

In this section we partition the taxa and accessions in the collection into: Bryophytes, Ferns, Gymnosperms, Lycophytes, Eudicots, Monocots and Other (Angiosperms). Using the partition, we create pie charts showing the composition of the collection with respect to accessions and taxa.

```{r, echo = F}
#Repeat some code from the first section.
# since we are matching to group counts to WCVP only consider records that we managed to match to WCVP.
report_existing = enriched_report[enriched_report$ItemStatusType == 'Existing',]
items_orig = nrow(report_existing)
report_existing = report_existing[which(!is.na(report_existing$POWO_plant_name_id)),]
items_in_wcvp = nrow(report_existing)

GenusSpecies = paste0(report_existing$POWO_genus, ' ', report_existing$POWO_species)
report_existing$GenusSpecies_new = GenusSpecies

report_existing_species = report_existing[match(unique(GenusSpecies), report_existing$GenusSpecies_new ),]
no_taxa = nrow(report_existing_species)

report_exisiting_accessions = report_existing[match(unique(report_existing$AccNoFull), report_existing$AccNoFull),]
no_accessions = nrow(report_exisiting_accessions)
```

```{r, echo = F,  fig.fullwidth=TRUE, fig.dim = c(10, 5)}

### For the table use all groups.  ------

to_do = c("Lycophytes", "Ferns", "Gymnosperms", "Angiosperms", 'Monocots', 'Eudicots', 'Rosids','Asterids')
# For accessions first.
grouped = rep('', nrow(report_exisiting_accessions))
for(i in 1:length(to_do)){
  index = which(report_exisiting_accessions$POWO_family %in% families_of_groups[[to_do[i]]])
  grouped[index] = paste0(grouped[index], ', ', to_do[i])
}
grouped = stringr::str_remove(grouped, '^, ')
grouped[grouped == ''] = 'Other (Angiosperms)'

count = rep(NA, length(to_do))
for(i in 1:length(to_do)){
  count[i] = sum(grepl(to_do[i], grouped))
}
accessions = data.frame(group = to_do, count = count)

# For taxa next
grouped = rep('', nrow(report_existing_species))
for(i in 1:length(to_do)){
  index = which(report_existing_species$POWO_family %in% families_of_groups[[to_do[i]]])
  grouped[index] = paste0(grouped[index], ', ', to_do[i])
}
grouped = stringr::str_remove(grouped, '^, ')
grouped[grouped == ''] = 'Other (Angiosperms)'

count = rep(NA, length(to_do))
for(i in 1:length(to_do)){
  count[i] = sum(grepl(to_do[i], grouped))
}
taxa = data.frame(group = to_do, count = count)


table_composition = data.frame(accessions,
                               paste0(round(accessions$count /no_accessions*100,digits = 2),'%'),
                               taxa$count,
                               paste0(round(taxa$count /no_taxa*100,digits = 2),'%')
)
names(table_composition) = c('Group', 'Number of accessions', 'Percentage of accessions',
                             'Number of taxa', 'Percentage of taxa')
### (END) For the table use all groups.  ------

### For the chart just use lowest level.  ------
to_do_full = c("Lycophytes", "Ferns", "Gymnosperms", "Angiosperms", 'Monocots', 'Eudicots', 'Rosids','Asterids')
to_do = c("Lycophytes", "Ferns", "Gymnosperms", 'Monocots', 'Eudicots')
colours_cont = scales::brewer_pal(palette = palette, direction = 1)(6)
ramp <- scales::colour_ramp(colours_cont)
colours = ramp(seq(0, 1, length = length(to_do_full)+2))[-c(1,2)]
names(colours) = to_do_full
colours['Other (Angiosperms)'] = '#808080'

plot_data = data.frame(group = to_do,
                       accession = table_composition$`Number of accessions`[match(to_do, table_composition$Group)],
                       taxa = table_composition$`Number of taxa`[match(to_do, table_composition$Group)])
plot_data[nrow(plot_data)+1,] = c('Other (Angiosperms)', 
                                   no_accessions - sum(plot_data$accession,na.rm = T),
                                   no_taxa - sum(plot_data$taxa,na.rm = T) )
plot_data = plot_data[!is.na(plot_data$accession),]
plot_data$group = factor(plot_data$group, levels = plot_data$group)
plot_data$accession = plot_data$accession |> as.numeric()
plot_data$taxa = plot_data$taxa |> as.numeric()


# # For accessions first.
# grouped = rep('', nrow(report_exisiting_accessions))
# for(i in 1:length(to_do)){
#   index = which(report_exisiting_accessions$POWO_family %in% families_of_groups[[to_do[i]]])
#   grouped[index] = paste0(grouped[index], ', ', to_do[i])
# }
# grouped = stringr::str_remove(grouped, '^, ')
# grouped[grouped == ''] = 'Other'
# 
# accessions = data.frame(table(grouped))
# order_index= match(c(to_do,'Other'), accessions$grouped)
# order_index= order_index[!(order_index |> is.na())]
# accessions = accessions[order_index,]
# levels(accessions$grouped) = accessions$grouped |> as.character()
# # accessions$grouped = factor(accessions$grouped, levels = c('Other',to_do))
# # For taxa next
# grouped = rep('', nrow(report_existing_species))
# for(i in 1:length(to_do)){
#   index = which(report_existing_species$POWO_family %in% families_of_groups[[to_do[i]]])
#   grouped[index] = paste0(grouped[index], ', ', to_do[i])
# }
# grouped = stringr::str_remove(grouped, '^, ')
# grouped[grouped == ''] = 'Other'
# 
# taxa = data.frame(table(grouped))
# order_index= match(c(to_do,'Other'), taxa$grouped)
# order_index= order_index[!(order_index |> is.na())]
# taxa = taxa[order_index,]
# levels(taxa$grouped) = taxa$grouped |> as.character()

# table_composition = data.frame(accessions,
#                                paste0(round(accessions$Freq /sum(accessions$Freq)*100,digits = 2),'%'),
#                                taxa$Freq,
#                                paste0(round(taxa$Freq /sum(taxa$Freq)*100,digits = 2),'%')
# )
# names(table_composition) = c('Group', 'Number of accessions', 'Percentage of accessions',
#                              'Number of taxa', 'Percentage of taxa')



# Together
plot_data$colour = colours[match(plot_data$group, names(colours))]
p <- plot_ly() |>
  add_pie(data = plot_data, labels = ~group, values = ~accession, hole = 0.6,
          title = "Accessions", name ='', sort = FALSE, marker = list(
            colors =  ~colour),
          domain = list(row = 0, column = 0)) |>
  add_pie(labels = ~group, values = ~taxa, hole = 0.6,
          title = "Taxa", name ='', sort = FALSE, marker = list(
            colors = ~colour),
          domain = list(row = 0, column = 1))  |>
  layout(title = "", showlegend = TRUE,
         grid=list(rows=1, columns=2),
         plot_bgcolor="#f0f0f0",
         legend = list(orientation = 'h', xanchor = "center", x = 0.5),
         xaxis = list(title=paste0('Accessions', 'Taxa'), showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         margin = c(0,0,0,0))



```

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Chart"}`

For full composition, including supergroups and subgroups, see the table tab.

```{r  Composition on LC , fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
p
```

`r if(report_kind == 'interactive'){"###### Table"}`
```{r  Composition on LC - Table, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'}

table_composition |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(table_composition), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=F,
                                 ordering=F))
```

`r if(report_kind == 'interactive'){"##### {-}"}`


***

## Taxonomic composition of the living collection over time 

In this section we explore how the taxonomic composition of the collection has varied over time.

```{r, echo = F, fig.fullwidth=TRUE, fig.dim = c(10, 6)}
report = enriched_report
report = report[!is.na(report$POWO_plant_name_id),]

# The current year.
year_cur = as.numeric(format(Sys.Date(),'%Y'))

# Get which items are existing each year in the collection.
years = min_year:year_cur
date = paste0(years, '-12-31')

# Add Genus species columns from WCVP.
GenusSpecies = paste0(report$POWO_genus, ' ', report$POWO_species)
report$GenusSpecies_new = GenusSpecies


# Get the species/genera that are existing
plant_existing = BGSmartR::exist_at_date(date, AccessionYear = report$AccYear,
                                         ItemStatusDate = report$ItemStatusDate,
                                         ItemStatusType = report$ItemStatusType,
                                         post_date = '3000-01-01')


# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing, function(x){
  garden_current = report[x,]
  
  # Reduce garden_current to unique species and genera.
  report_species = garden_current[match(unique(garden_current$GenusSpecies_new), garden_current$GenusSpecies_new ),]
  report_accessions = garden_current[match(unique(garden_current$AccNoFull), garden_current$AccNoFull ),]
  
  total_taxa = nrow(report_species)
  total_accessions = nrow(report_accessions)
  to_do = c("Lycophytes", "Ferns", "Gymnosperms", 'Monocots', 'Eudicots')
  
  # For accessions first.
  grouped = rep('', nrow(report_accessions))
  for(i in 1:length(to_do)){
    index = which(report_accessions$POWO_family %in% families_of_groups[[to_do[i]]])
    grouped[index] = paste0(grouped[index], ', ', to_do[i])
  }
  grouped = stringr::str_remove(grouped, '^, ')
  grouped[grouped == ''] = 'Other (Angiosperms)'
  
  accessions = data.frame(table(grouped))
  accessions$prop = round(accessions$Freq/total_accessions*100,digits = 3)
  # For taxa next
  grouped = rep('', nrow(report_species))
  for(i in 1:length(to_do)){
    index = which(report_species$POWO_family %in% families_of_groups[[to_do[i]]])
    grouped[index] = paste0(grouped[index], ', ', to_do[i])
  }
  grouped = stringr::str_remove(grouped, '^, ')
  grouped[grouped == ''] = 'Other (Angiosperms)'
  
  taxa = data.frame(table(grouped))
  taxa$prop = round(taxa$Freq/total_taxa*100,digits = 3)
  
  return(list(taxa = taxa, accessions = accessions))
})

# Get the proportions for each year (taxa).
taxa_data = NULL
for(i in 1:length(over_time_info)){
  taxa_data = rbind(taxa_data, data.frame(year = rep(names(over_time_info)[i],nrow(over_time_info[[i]]$taxa)),over_time_info[[i]]$taxa))
}


to_do_full = c("Lycophytes", "Ferns", "Gymnosperms", "Angiosperms", 'Monocots', 'Eudicots', 'Rosids','Asterids')
colours_cont = scales::brewer_pal(palette = palette, direction = 1)(6)
ramp <- scales::colour_ramp(colours_cont)
colours = ramp(seq(0, 1, length = length(to_do_full)+2))[-c(1,2)]
names(colours) = to_do_full
colours['Other (Angiosperms)'] = '#808080'

figs = c()
taxa_data$grouped = factor(taxa_data$grouped, levels = c(to_do, 'Other (Angiosperms)'))
taxa_data$year = stringr::str_extract(taxa_data$year, pattern = '[0-9]{4}')
taxa_data$color =colours[match(taxa_data$grouped, names(colours))]
fig = plot_ly(taxa_data, x = ~year, y = ~prop, type = 'bar', colors =  ~colours,
              name = ~grouped, color = ~grouped, hovertemplate = paste('%{y:.2f}%')) %>%
  layout(yaxis = list(title = 'Proportion of taxa'),
         xaxis = list(title = 'Year'),barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified')
fig <- fig |> layout(title = paste0('Taxonomic composition of the collection over time (taxa)'))
fig <- fig |> layout(hovermode = 'x unified')

figs$taxa = fig

# Get the proportions for each year (accessions).
accessions_data = NULL
for(i in 1:length(over_time_info)){
  accessions_data = rbind(accessions_data, data.frame(year = rep(names(over_time_info)[i],nrow(over_time_info[[i]]$accessions)),over_time_info[[i]]$accessions))
}
accessions_data$year = stringr::str_extract(accessions_data$year, pattern = '[0-9]{4}')

accessions_data$grouped = factor(accessions_data$grouped, levels = c(to_do, 'Other (Angiosperms)'))

fig = plot_ly(accessions_data, x = ~year, y = ~prop, type = 'bar',colors = colours, name = ~grouped, color = ~grouped, hovertemplate = paste('%{y:.2f}%')) %>%
  layout(yaxis = list(title = 'Proportion of accessions'),
         xaxis = list(title = 'Year'), barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified')
fig <- fig |> layout(title = paste0('Taxonomic composition of the collection over time (accessions)'))
fig <- fig |> layout(hovermode = 'x unified')

figs$accessions = fig
```

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Taxa"}`
```{r  Composition over time taxa, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
figs$taxa
```

`r if(report_kind == 'interactive'){"###### Accessions"}`
```{r  Composition over time accessions, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
figs$accessions
```

`r if(report_kind == 'interactive'){"##### {-}"}`



***

