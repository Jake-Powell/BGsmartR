---
title: "Sustainability and longevity at the collection"
output: html_document
---

###### {-} 

```{r, add logo, eval = report_kind == 'interactive'}
htmltools::img(src = knitr::image_uri(paste0(system.file(package = "BGSmartR"), "/logo.png")), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; width:100px; height:100px')
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(plotly)
library(htmltools)
library(sf)
library(here)
library(flextable)
library(ggrepel)
library(downloadthis)

interactive_colour <- function(n){
  color = c('#f46d43', '#50c1dc', '#848484', '#e6e6e6')
  if(n==2){
    return(color[c(1,4)])
  }
  color[1:n]
}

color_binary <- rev(c('#f46d43', '#848484'))
palette = 'Oranges'
```

```{r, imported parameters}
# Inputs
# As an input we get 
# - Enriched report
# # - collection the name to be printed in the report.
# load("/Users/jakepowell/Cambridge/Enriched_reports_Jake/CUBG_May2024_enriched_report.rda")
# # coordinates = c(52.19375565279363, 0.1277770504441467)
# collection = 'CUBG'
# 
# separate_figure_folder = FALSE
# output_dir = getwd()
# load('/Users/jakepowell/Cambridge/Geography Module/wgsrpd3.rda')
# # load('/Users/jakepowell/Cambridge/Modules/Basic Stats/wgsrpd3.rda)
# report_kind = 'interactive'
# native = 'Naturally occurring only'
# extinct = TRUE
# doubtful_locations = FALSE
# ggtheme = NULL
# value_on_fig = TRUE
```

```{css, echo = FALSE}
/* from https://ianlunn.github.io/Hover/ */
.hvr-sweep-to-left {
  display: inline-block;
  vertical-align: middle;
  -webkit-transform: perspective(1px) translateZ(0);
  transform: perspective(1px) translateZ(0);
  box-shadow: 0 0 1px rgba(0, 0, 0, 0);
  position: relative;
  -webkit-transition-property: color;
  transition-property: color;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
}
.hvr-sweep-to-left:before {
  content: "";
  position: absolute;
  z-index: -1;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #2098D1;
  -webkit-transform: scaleX(0);
  transform: scaleX(0);
  -webkit-transform-origin: 100% 50%;
  transform-origin: 100% 50%;
  -webkit-transition-property: transform;
  transition-property: transform;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
  -webkit-transition-timing-function: ease-out;
  transition-timing-function: ease-out;
}
.hvr-sweep-to-left:hover, .hvr-sweep-to-left:focus, .hvr-sweep-to-left:active {
  color: white;
}
.hvr-sweep-to-left:hover:before, .hvr-sweep-to-left:focus:before, .hvr-sweep-to-left:active:before {
  -webkit-transform: scaleX(1);
  transform: scaleX(1);
}
```

```{r theme_ggplot2}
library(ggplot2)
# Changing the default theme
if(is.null(ggtheme)){
   ggtheme <- function(base_size = 16) {
      ggplot2::theme_bw(base_size = base_size) %+replace%
        ggplot2::theme(
          plot.title = ggplot2::element_text(size = rel(1), face = "bold", margin = margin(0,0,5,0), hjust = 0),
          panel.grid.minor = ggplot2::element_blank(),
          panel.background = element_rect(fill = 'transparent', color = NA),
          panel.border = ggplot2::element_blank(),
          axis.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
          axis.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
          axis.line = ggplot2::element_line(color = "black"),
          legend.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
          legend.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
          legend.key = ggplot2::element_rect(fill = "transparent", colour = NA),
          legend.key.size = ggplot2::unit(1.5, "lines"),
          legend.background = ggplot2::element_rect(fill = "transparent", colour = NA),
          strip.background = ggplot2::element_rect(fill = "#17252D", color = "#17252D"),
          strip.text = ggplot2::element_text(size = rel(0.85), face = "bold", color = "white", margin = margin(5,0,5,0))
        )
    }
}
theme_set(ggtheme())
update_geom_defaults("line", list(size = 2))

# Set the colour scale for the plots
scale_colour_continuous <- scale_colour_continuous
scale_colour_discrete   <- scale_colour_discrete
scale_colour_binned     <- scale_colour_binned
scale_fill_continuous <- scale_fill_continuous
scale_fill_discrete <- scale_fill_discrete
scale_fill_binned <- scale_fill_binned
```

```{r, onRender text}
bar_col = interactive_colour(1) ; bar_col_alpha = BGSmartR::add_alpha(bar_col, 0.7)

render_barplot = paste0("
    function(el) { 
    console.log(el)
      el.on('plotly_hover', function(data){
  var pn='',
      tn='',
      colors=[];
  for(var i=0; i < data.points.length; i++){
    pn = data.points[i].pointNumber;
    tn = data.points[i].curveNumber;
    colors = data.points[i].data.marker.color;
  };
  colors[pn] = '", bar_col ,"';
    
  var update = {'marker':{color: colors}};
  Plotly.restyle(el.id, update, [tn]);
});
      el.on('plotly_unhover', function(data){
  var pn='',
      tn='',
      colors=[];
  for(var i=0; i < data.points.length; i++){
    pn = data.points[i].pointNumber;
    tn = data.points[i].curveNumber;
    colors = data.points[i].data.marker.color;
  };
  colors[pn] = '", bar_col_alpha ,"';
  var update = {'marker':{color: colors}};
  Plotly.restyle(el.id, update, [tn]);
});
    }
  ")

icon_svg_path = "M15.608,6.262h-2.338v0.935h2.338c0.516,0,0.934,0.418,0.934,0.935v8.879c0,0.517-0.418,0.935-0.934,0.935H4.392c-0.516,0-0.935-0.418-0.935-0.935V8.131c0-0.516,0.419-0.935,0.935-0.935h2.336V6.262H4.392c-1.032,0-1.869,0.837-1.869,1.869v8.879c0,1.031,0.837,1.869,1.869,1.869h11.216c1.031,0,1.869-0.838,1.869-1.869V8.131C17.478,7.099,16.64,6.262,15.608,6.262z M9.513,11.973c0.017,0.082,0.047,0.162,0.109,0.226c0.104,0.106,0.243,0.143,0.378,0.126c0.135,0.017,0.274-0.02,0.377-0.126c0.064-0.065,0.097-0.147,0.115-0.231l1.708-1.751c0.178-0.183,0.178-0.479,0-0.662c-0.178-0.182-0.467-0.182-0.645,0l-1.101,1.129V1.588c0-0.258-0.204-0.467-0.456-0.467c-0.252,0-0.456,0.209-0.456,0.467v9.094L8.443,9.553c-0.178-0.182-0.467-0.182-0.645,0c-0.178,0.184-0.178,0.479,0,0.662L9.513,11.973z"

dl_button <- list(
    name = "Download data",
    icon = list(
        path = icon_svg_path,
        transform = "scale(0.84) translate(-1, -1)"
        ),
    click = htmlwidgets::JS("
          function(gd) {
            var text = '';
            for(var i = 0; i < gd.data.length; i++){
              text += gd.layout.xaxis.title.text + gd.data[i].name + ',' + gd.data[i].x + '\\n';
              text += gd.layout.yaxis.title.text + gd.data[i].name + ',' + gd.data[i].y + '\\n';
            };
            var blob = new Blob([text], {type: 'text/plain'});
            var a = document.createElement('a');
            const object_URL = URL.createObjectURL(blob);
            a.href = object_URL;
            a.download = 'data.csv';
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(object_URL);
          }
   ")
)

dl_button_map <- list(
    name = "Download data",
    icon = list(
        path = icon_svg_path,
        transform = "scale(0.84) translate(-1, -1)"
        ),
    click = htmlwidgets::JS("
          function(gd) {
            var text = '';
            for(var i = 0; i < gd.data.length; i++){
              text += gd.layout.xaxis.title.text + gd.data[i].name + ',' + gd.data[i].z + '\\n';
              text += gd.layout.yaxis.title.text + gd.data[i].name + ',' + gd.data[i].hovertext + '\\n';
            };
            var blob = new Blob([text], {type: 'text/plain'});
            var a = document.createElement('a');
            const object_URL = URL.createObjectURL(blob);
            a.href = object_URL;
            a.download = 'data.csv';
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(object_URL);
          }
   ")
)
```

```{r, Add combined geography column to enriched report}
geography_data = enriched_report[,grepl('_area_code_l3', names(enriched_report))]
want = c('000','010','001','011','100','110','101')

#Depending on the values of the options reduce `want` to only the satisfactory values.
##A) introduced / naturally occurring only.
if(native == 'Introduced only'){
 want = want[grepl('^1',want)]
}else if(native == 'Naturally occurring only'){
 want = want[grepl('^0',want)]
}
## B) Extinct
if(!extinct){
 want = want[!grepl('010|011|110',want)]
}
## C) Doubtful
if(!doubtful_locations){
 want = want[!grepl('001|011|101',want)]
}
# Get the columns in wanted info that contain the geography information we want.
geography_data = geography_data[,grepl(paste0(want,collapse='|'), names(geography_data))]

if(length(want) > 1){
 level3codes =do.call("paste", c(geography_data, sep = ", "))
 level3codes = stringr::str_remove(level3codes, ', NA$')
 level3codes = stringr::str_remove(level3codes, 'NA, ')
}else{
 level3codes = geography_data
}
level3codes[level3codes == "NA"] = NA

enriched_report$geography_codes = level3codes
```

`r if(any(!c('AccNoFull', 'Family', 'Genus', 'GenusSpecies', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"*** \n **Warning!**\n\n This enriched report contains missing 'original' columns needed to perform the analyses in this report. Default values have been created. In particular, the following were missing "}`

`r if(!'AccNoFull' %in% names(enriched_report)){"- AccNoFull: Each item is assumed to be a unique accession.\n"}`
`r if(!'Family' %in% names(enriched_report)){"- Family: Only families found by matching to POWO will be used (No non-vascular families). \n"}`
`r if(!'Genus' %in% names(enriched_report)){"- Genus: Only genera found by matching to POWO will be used."}`
`r if(!'GenusSpecies' %in% names(enriched_report)){"- GenusSpecies: Only species found in POWO will be used."}`
`r if(!'AccYear' %in% names(enriched_report)){"- AccYear: All Accession years set to missing. \n"}`
`r if(!'ItemStatusDate' %in% names(enriched_report)){"- ItemStatusDate: All set to missing. \n"}`
`r if(!'ItemStatusType' %in% names(enriched_report)){"- ItemStatusType: All set to exisiting. \n"}`

`r if(any(!c('AccNoFull', 'Family', 'Genus', 'GenusSpecies', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"***"}`

```{r, Get location_type_text}
location_type_text = ''
if(native == 'Naturally occurring only'){
 location_type_text = paste0(location_type_text, 'naturally occuring only,', collapse = ' ')  
}else if(native == 'Introduced only'){
  location_type_text = paste0(location_type_text, 'introduced only,', collapse = ' ')  
 
}else{
  location_type_text = paste0(location_type_text, 'Either naturally occurring or introduced,', collapse = ' ')  
}
if(extinct){
   location_type_text = paste0(location_type_text, ' allowing extinct regions and', collapse = ' ')  
}else{
  location_type_text = paste0(location_type_text, ' not including extinct regions and', collapse = ' ')  
}
if(doubtful_locations){
   location_type_text = paste0(location_type_text, ' allowing doubtful regions.', collapse = ' ')  
 
}else{
  location_type_text = paste0(location_type_text, ' not allowing doubtful regions.', collapse = ' ')  
}
```

```{r, Find LC location}
coord_contained = TRUE
# Extract the location of the collection.
pnts <- data.frame( x = coordinates[2], y = coordinates[1])

# create a points collection
pnts_sf <- do.call("st_sfc",c(lapply(1:nrow(pnts), 
                                     function(i) {sf::st_point(as.numeric(pnts[i, ]))}), list("crs" = 4326))) 

pnts_trans <- st_transform(pnts_sf, 2163) # apply transformation to pnts sf
tt1_trans <- st_transform(wgsrpd3, 2163)      # apply transformation to polygons sf

intersect = as.vector(st_intersects(tt1_trans, pnts_trans, sparse = FALSE))
collection_geog_details = wgsrpd3[which(intersect),-5]
location_name = collection_geog_details$LEVEL3_NAM
location_code = collection_geog_details$LEVEL3_COD

if(length(location_name) == 0){
  coord_contained = FALSE
  # Try and find the nearest polygon.
  collection_geog_details  =  wgsrpd3[which.min(as.vector(sf::st_distance(tt1_trans, pnts_trans))),-5]
  location_name = collection_geog_details$LEVEL3_NAM
  location_code = collection_geog_details$LEVEL3_COD
}
 collection_geog_details_og = collection_geog_details
```

```{r, Extracting information from enriched report}
# Add required columns if missing.
needed_columns = c('AccNoFull', 'Family', 'Genus', 'GenusSpecies', 'AccYear', 'ItemStatusDate', 'ItemStatusType')
if(!'AccNoFull' %in% names(enriched_report)){
  enriched_report$AccNoFull = 1:nrow(enriched_report)
}
if(!'Family' %in% names(enriched_report)){
  enriched_report$Family =rep(NA, nrow(enriched_report))
}
if(!'Genus' %in% names(enriched_report)){
  enriched_report$Genus = rep(NA, nrow(enriched_report))
}
if(!'GenusSpecies' %in% names(enriched_report)){
  enriched_report$GenusSpecies = rep(NA, nrow(enriched_report))
}
if(!'AccYear' %in% names(enriched_report)){
  enriched_report$AccYear = rep(0, nrow(enriched_report))
}
if(!'ItemStatusDate' %in% names(enriched_report)){
  enriched_report$ItemStatusDate = rep(0, nrow(enriched_report))
}
if(!'ItemStatusType' %in% names(enriched_report)){
  enriched_report$ItemStatusType = rep('Existing', nrow(enriched_report))
}

do_coord = !is.na(coordinates[1])
# Set report to only the existing items.
# report = enriched_report[enriched_report$ItemStatusType == 'Existing',]
report = enriched_report

#Extract endemic information from report
endemic = rep('Not Endemic', nrow(report))
endemic_index = which(stringr::str_length(report$geography_codes) == 3)
endemic[endemic_index] = 'Endemic'
report$endemic = endemic
rm(endemic)

#Extract endemic information from report
tree = rep('Not Tree', nrow(report))
tree_index = which(report$Enrich_is_tree)
tree[tree_index] = 'Tree'
report$tree = tree
rm(tree)

# Add native column.
nativeo = rep('Non-native', nrow(report))
native_index = which(grepl(location_code, report$geography_codes))
nativeo[native_index] = 'Native'
report$native = nativeo
rm(nativeo)

# Extract threatened. 
threat_cat = c('VU','EN','CR','EW','EX')
threatened = rep('Not Threatened', nrow(report))
threatened[which(report$redList_category %in% threat_cat)] = 'Threatened'
threatened[which(report$POWO_Red_category %in% threat_cat)] = 'Threatened'
report$threatened = threatened
rm(threatened)

# Extract threatened category. 
threatened_category = rep(NA, nrow(report))
for(i in 1:length(threat_cat)){
 threatened_category[which(report$redList_category == threat_cat[i])] = threat_cat[i]
 threatened_category[which(report$POWO_Red_category == threat_cat[i])] = threat_cat[i]
}
report$threatened_category = threatened_category
rm(threatened_category)

# Convert Provenance code to text.
report$ProvenanceCode[report$ProvenanceCode == 'G'] = 'Garden'
report$ProvenanceCode[report$ProvenanceCode == 'U'] = 'Unknown'
report$ProvenanceCode[report$ProvenanceCode == 'W'] = 'Wild'
report$ProvenanceCode[report$ProvenanceCode == 'Z'] = 'Wild-derived'

# Create a sanitised taxonomic name.
report$good_name = paste0(report$sanitised_taxon, ' ', report$extracted_author)

best_name = paste0(report$POWO_taxon_name, ' ', report$POWO_taxon_authors)
best_name[which(best_name == 'NA NA')] = report$good_name[which(best_name == 'NA NA')]
report$best_name = best_name
report$good_name = paste0(report$sanitised_taxon, ' ', report$extracted_author)

# Get the best family (use powo match o/w original)
family = report$POWO_family
family[is.na(family)] = report$Family[is.na(family)]
report$family_use = family
rm(family)

# Combine powo genus and original genus
genera = report$POWO_genus
genera[is.na(genera)] = report$Genus[is.na(genera)]
report$genera_use = genera
rm(genera)

# Get genus species pair.
POWO_GenusSpecies = rep(NA, nrow(report))
POWO_GenusSpecies[!is.na(report$POWO_plant_name_id)] = paste0(report$POWO_genus[!is.na(report$POWO_plant_name_id)],
                                                              ' ',
                                                              report$POWO_species[!is.na(report$POWO_plant_name_id)])
species_data = data.frame(original = report$GenusSpecies, POWO = POWO_GenusSpecies, infra = report$taxon_type)
use_genus_species = species_data$POWO
use_genus_species[is.na(use_genus_species)] = species_data$original[is.na(use_genus_species)]
report$genus_species_use= use_genus_species

# Get best taxonomic name.
taxon_name_auth = paste0(report$sanitised_taxon, ' ', report$extracted_author)
taxon_name_auth[!is.na(report$POWO_plant_name_id)] = (paste0(report$POWO_taxon_name, ' ', report$POWO_taxon_authors))[!is.na(report$POWO_plant_name_id)]
report$taxa_use = taxon_name_auth
rm(taxon_name_auth)


major_groups = c("Angiosperms", "Ferns", "Gymnosperms", "Lycophytes",
                                  "Bryophytes", "Hornworts", "Liverworts", "Mosses"
)
Angiosperm_groups = c('Eudicots', 'Monocots')
Eudicot_groups = c('Asterids', 'Rosids')
fam_major_groups = lapply(major_groups, function(group){
 PlantClassification$family[PlantClassification$`major Land Plants lineage` == group]
})
names(fam_major_groups) = major_groups
fam_Angiosperm_groups = lapply(Angiosperm_groups, function(group){
PlantClassification$family[PlantClassification$`major Angiosperm lineage` == group]
})
names(fam_Angiosperm_groups) = Angiosperm_groups
fam_Eudicot_groups = lapply(Eudicot_groups, function(group){
PlantClassification$family[PlantClassification$`major Eudicot lineage` == group]
})
names(fam_Eudicot_groups) = Eudicot_groups
families_of_groups = c(fam_major_groups, fam_Angiosperm_groups, fam_Eudicot_groups)

to_do = c("Bryophytes", "Ferns", "Gymnosperms", "Lycophytes", 'Eudicots', 'Monocots')
taxo_group = rep('Other',nrow(report))
for(i in 1:length(to_do)){
  taxo_group[report$family_use %in% families_of_groups[[to_do[i] ]] ] = to_do[i]
}
report$taxo_group = taxo_group


report_original = report

if(separate_figure_folder){
  figures_dir = paste0(output_dir,'/',collection,'_Figures')
  dir.create(figures_dir,showWarnings = FALSE)
}

```


This report provides an overview of analyses of the collection further detail can be found by running other reports (such as Geography, Endemic, trends, etc... reports).



***


### Age of accessions

```{r, age of accessions}
interest = report[report$ItemStatusType == 'Existing',]
interest = interest[match(unique(interest$AccNoFull), interest$AccNoFull),]


```

***
