---
title: "Endemic species in the living collection"
output: html_document
---
  
###### {-} 
<!-- This section is for loading/setting up the data and writing the intro -->
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(plotly)
library(htmltools)
library(sf)
library(here)
library(flextable)
library(ggrepel)
library(downloadthis)

interactive_colour <- function(n){
  color = c('#f46d43', "#FDAE6B", '#848484', '#e6e6e6')
  if(n==2){
    return(color[c(1,4)])
  }
  color[1:n]
}
color_binary <- c('#f46d43', '#e6e6e6')
palette = 'Oranges'
```

```{css, echo = FALSE}
/* from https://ianlunn.github.io/Hover/ */
.hvr-sweep-to-left {
  display: inline-block;
  vertical-align: middle;
  -webkit-transform: perspective(1px) translateZ(0);
  transform: perspective(1px) translateZ(0);
  box-shadow: 0 0 1px rgba(0, 0, 0, 0);
  position: relative;
  -webkit-transition-property: color;
  transition-property: color;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
}
.hvr-sweep-to-left:before {
  content: "";
  position: absolute;
  z-index: -1;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #f46d43;
  -webkit-transform: scaleX(0);
  transform: scaleX(0);
  -webkit-transform-origin: 100% 50%;
  transform-origin: 100% 50%;
  -webkit-transition-property: transform;
  transition-property: transform;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
  -webkit-transition-timing-function: ease-out;
  transition-timing-function: ease-out;
}
.hvr-sweep-to-left:hover, .hvr-sweep-to-left:focus, .hvr-sweep-to-left:active {
  color: white;
}
.hvr-sweep-to-left:hover:before, .hvr-sweep-to-left:focus:before, .hvr-sweep-to-left:active:before {
  -webkit-transform: scaleX(1);
  transform: scaleX(1);
}

.blackbox {
  padding: 1em;
  background: #FDAE6B;
  border: 2px solid #e6e6e6;
  border-radius: 10px;
}
.center {
  text-align: center;
}
```

```{r, imported parameters}
# 
# collection = 'CUBG'
# load('/Users/jakepowell/Cambridge/Enriched_reports_Jake/CUBG_June2023_enriched_report.rda')
# coordinates = c(52.19378853629289,0.1277234065606053)
# # 
# # 
# # load('/Users/jakepowell/Cambridge/Geography Module/wgsrpd3.rda')
# # load('/Users/jakepowell/Cambridge/WCVP/Version 11/wcvp_with_redlistcategory.rda')
# 
# native = 'Naturally occurring only'
# extinct = TRUE
# doubtful_locations = FALSE
# min_year = 1970
# export_data = F
# table_font_size = 14
# ggtheme = NULL
# separate_figure_folder = FALSE
# value_on_fig = TRUE
# report_kind = 'static'
# color_binary = c('darkgray','darkgreen')
# palette = 'Greens'
# recent_year = 2020
# endemic_species_per_region = NULL
```

```{r, add logo, eval = report_kind == 'interactive'}
htmltools::img(src = knitr::image_uri(paste0(system.file(package = "BGSmartR"), "/logo.png")), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; width:100px; height:100px')
```

```{r, functions for turnover}
turnover_items <- function(report){
  report = report[(report$LossYear >= min_year & report$LossYear <= max_year) | is.na(report$LossYear),]
  combined = data.frame(Year = years)
  
  # Items
  gain = data.frame(table(report$AccYear))
  if(nrow(gain) == 0){
    gained = rep(0,nrow(combined))
    combined$gain_items = gained
  }else{
    names(gain) = c('Year', 'Items')
    gain$Year = as.numeric(as.character(gain$Year))
    gain = gain[gain$Year >=min_year & gain$Year <= max_year,]
    gained = rep(0,nrow(combined))
    gained[match(gain$Year, combined$Year)] = gain$Items
    combined$gain_items = gained
  }
  
  
  loss = data.frame(table(report$LossYear))
  if(nrow(loss) == 0){
    lost = rep(0,nrow(combined))
    combined$loss_items = lost
  }else{
    names(loss) = c('Year', 'Items')
    loss$Year = as.numeric(as.character(loss$Year))
    loss = loss[loss$Year >=min_year & loss$Year <= max_year,]
    lost = rep(0,nrow(combined))
    lost[match(loss$Year, combined$Year)] = loss$Items
    combined$loss_items = lost
  }
  
  
  combined$net_items = combined$gain_items - combined$loss_items
  return(combined)
}

plots_turnover <- function(turnover, trend, report_kind, text = '', separate_figure_folder, data_type = 'items'){
    dataA = data.frame(turnover[,c(1,3)], rep('Lost', nrow(turnover)))
    names(dataA) = LETTERS[1:3]
    dataB = data.frame(turnover[,c(1,2)], rep('Gain', nrow(turnover)))
    names(dataB) = LETTERS[1:3]
    items_data = rbind(dataA, dataB)
  if(report_kind == 'static'){

    p = ggplot(data=items_data, aes(x=A, y=B, group=C)) +
      geom_line(aes(color=C)) +
      # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
      labs(title=paste0("Turnover of ",text," in the LC (By ",data_type,")"),
           x ="Year",
           y = paste0('Number of ',data_type,'')) +
      guides(color=guide_legend(title=paste0('Gain/Loss'))) +
      # theme(text = element_text(size=table_font_size)) +
      scale_color_manual(values=c("blue", "red"))+
      theme(legend.direction = "horizontal", legend.position = "top", legend.justification = "right")
    
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','turnover_',stringr::str_replace_all(text, ' ', '_'),'_gain_loss_',data_type,'.pdf'),device = 'pdf', scale = 1, width = 20, height = 12, limitsize = FALSE)
    }
    p1=p
    
    # Color based on value
    color <- ifelse(turnover$net_items < 0, "pink", "lightblue")
    p = ggplot(turnover, aes(x = Year, y = net_items)) +
      geom_bar(stat = "identity",
               show.legend = FALSE,
               fill = color,      # Background color
               color = "white") + # Border color
      # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
      labs(title=paste0("Net turnover of ",text," in the LC (By ",data_type,")"),
           x ="Year",
           y = paste0('Number of ',data_type,''))
    # theme(text = element_text(size=table_font_size))
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Net_turnover_',stringr::str_replace_all(text, ' ', '_'),'_',data_type,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
    p2=p
    
    
    # Trend plot.
    trend_data = data.frame(year = turnover$Year, trend = trend)
    p = ggplot(trend_data, aes(x = year, y = trend)) +
      geom_line(width = 1.1) +
      labs(title="",
           x ="Year",
           y = paste0('Number of ',data_type,''))
    p3 = p
    return(list(gain_loss = p1, net = p2, trend = p3))
  }
  if(report_kind == 'interactive'){
    # gain_loss plot
    colors = color_binary |> rev()
    fig <- plot_ly(items_data, x = ~A, y = ~B, color = ~C, colors = colors, type = 'scatter', mode = 'lines+markers')
    fig <- fig |> layout(yaxis = list(title = paste0("Number of ",data_type |> tolower(),"")),
                         xaxis = list(title = "Year"))
    fig <- fig |> layout(hovermode = 'x unified')
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','line-turnover_',stringr::str_replace_all(text, ' ', '_'),'_gain_loss_',data_type,'.html'))
    }
    fig1 = fig
    
    # net plot
    colors = color_binary |> rev()
    color <- ifelse(turnover$net_items < 0, colors[1], colors[2])
    texto = paste0('Net: ', turnover$net_items, '<br>',
                   'Gain: ', turnover$gain_items, '<br>',
                   'Loss: ', turnover$loss_items, '<br>'
    )
    fig = plot_ly(turnover, x = ~Year, y = ~net_items, type = 'bar', hoverinfo = "x+text",  hovertext = texto, color = color, colors = rev(colors), showlegend = FALSE)
    fig <- fig |> layout(yaxis = list(title = paste0("Net number of ",data_type |> tolower(),"")),
                         xaxis = list(title = "Year"))
    fig <- fig |> layout(hovermode = 'x unified')
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Bar-Net_',stringr::str_replace_all(text, ' ', '_'),'turnover_of_',data_type,'.html'))
    }
    fig2 = fig
    
    # Trend plot.
    trend_data = data.frame(year = turnover$Year, trend = trend)
    fig = plot_ly(trend_data, x = ~year, y = ~trend, type = 'scatter', mode = 'line', hoverinfo = "x+text", hovertext = trend)
    fig <- fig |> layout(yaxis = list(title = paste0("Number of ",data_type |> tolower(),"")),
                         xaxis = list(title = "Year"))
    fig <- fig |> layout(hovermode = 'x unified')
    fig3= fig
    
    # Combined trend and net.
    fig <- plot_ly()
    # Add traces
    ay <- list(
      tickfont = list(color = "black"),
      overlaying = "y",
      side = "right",
      title = paste0("Total ", tolower(data_type)))
    
      fig <- fig %>% add_trace(x = years, y = turnover$net_items, name = "Net", type = 'bar', hoverinfo = "x+text",  hovertext = texto, color = color, colors = rev(colors), showlegend = FALSE)
     
    fig <- fig %>% add_trace(x = years, y = trend, name = "Total", mode = "lines+markers", type = "scatter", line = list(color = 'black'), marker = list(color = 'black'),yaxis = "y2")
    
  
    # Set figure title, x and y-axes titles
    fig <- fig |> layout(
      title = "", yaxis2 = ay,
      xaxis = list(title="Year"),
      yaxis = list(title = paste0("Net turnover of ", tolower(data_type)))
    ) |>
      layout(plot_bgcolor='white',
             xaxis = list(
               zerolinecolor = '#ffff',
               zerolinewidth = 2,
               gridcolor = 'ffff'),
             yaxis2 = list(
               zeroline = TRUE,
               zerolinecolor = 'ffff',
               zerolinewidth = 2,
               gridcolor = 'ffff',
               showgrid = FALSE),
              yaxis = list(
                zeroline = TRUE,
                zerolinecolor = '#f0f0f0',
                zerolinewidth = 1,
                gridcolor = '#f0f0f0',
                griddash = 'solid',
                gridwidth = 1,showgrid = T),
             margin = list(t = 10, l = 20, r = 70, b = 20, pad = 4),
             autosize = T
      )
    fig <- fig |> layout(hovermode = 'x unified')
    fig4 = fig
    
    return(list(gain_loss = fig1, net = fig2, trend = fig3, trend_and_net = fig4))
    
  }
}

proportional_plots_turnover <- function(turnover,
                                        overall_turnover,
                                        collection_proportion,
                                        separate_figure_folder, 
                                        report_kind,
                                        text = '',
                                        data_type = 'items',
                                        quantity = ''){
  if(report_kind == 'static'){
    # Gain
    plot_data = data.frame(year = turnover[,1],
                           specific = turnover[,2], 
                           all = overall_turnover[,2])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_gain = plot_data
    p = ggplot(plot_data, aes(y=prop_specific, x=year)) + 
      geom_bar(stat="identity", width = 1, fill = 'lightblue', col = 'black') +
      geom_point(aes(x = year, y = prop_specific_collection))+
      labs(title=paste0("Proportion of gained ",data_type," that are ",text," in the LC"),
           x ="Year",
           y = "Percentage (%)") +
      # theme(text = element_text(size=table_font_size)) +
      labs(caption = paste0("Black points are proportion of ",data_type," in the LC that are ",text," each year."))
    p1 = p
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/',stringr::str_replace_all(text,' ','_'),'_gain_',data_type,'_proportion.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
    
    ### Plot of proportion of lost items being native.
    
    plot_data = data.frame(year =  turnover[,1],
                           specific = turnover[,3], 
                           all = overall_turnover[,3])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_loss = plot_data
    
    p = ggplot(plot_data, aes(y=prop_specific, x=year)) + 
      geom_bar(stat="identity", width = 1, fill = 'pink', col = 'black') +
      geom_point(aes(x = year, y = prop_specific_collection))+
      # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
      labs(title=paste0("Proportion of lost ",data_type," that are ",text," in the LC"),
           x ="Year",
           y = "Percentage (%)") +
      # theme(text = element_text(size=table_font_size)) +
      labs(caption = paste0("Black points are proportion of ",data_type," in the LC that are ",text," each year."))
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/',stringr::str_replace_all(text,' ','_'),'_loss_',data_type,'_proportion.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
    
    return(list(gain = p1, loss = p, data_gain = plot_data_gain, data_loss = plot_data_loss))
  }
  if(report_kind =='interactive'){
    # Gain
    plot_data = data.frame(year = turnover[,1],
                           specific = turnover[,2], 
                           all = overall_turnover[,2])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_gain = plot_data
    fig = plot_ly(plot_data, x = ~year, y = ~prop_specific, type = 'bar',
                  name = paste0('New accessions'),
                  marker = list(color = color_binary[2]),
                  hovertemplate = paste("%{y:.2f}% of new accessions <extra></extra>")
                  )
                  
    fig <- fig |> layout(yaxis = list(title = paste0("Percentage")),
                         xaxis = list(title = "Year"))
    fig <- fig |> add_trace(x = ~year, y = ~prop_specific_collection, type = 'scatter', mode = 'lines+markers',
                            name = paste0('Collection'),
                            marker = list(color = 'black'),
                            line = list(color = 'black'),
                             hovertemplate = paste("%{y:.2f}% of the collection <extra></extra>")
                            )
    fig <- fig |> layout(hovermode = 'x unified',
                         yaxis = list(ticksuffix = '%'),
                         xaxis = list(hoverformat = paste0('fvf')),
                         legend=list(title=list(text=paste0('<b>',text |> stringr::str_to_sentence(), '</b>'))))
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Line_Bar-Proportion_of_gained_',stringr::str_replace_all(text, ' ', '_'),'_',data_type,'.html'))
    }
    
    fig1 = fig
    
    ### Plot of proportion of lost items being native.
    
    plot_data = data.frame(year =  turnover[,1],
                           specific = turnover[,3], 
                           all = overall_turnover[,3])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_loss = plot_data
    
    fig = plot_ly(plot_data, x = ~year,
                  y = ~prop_specific,
                  type = 'bar',
                  name = paste0('Lost accessions'),
                  marker = list(color = color_binary[1]),
                  hovertemplate = paste("%{y:.2f}% of lost accessions <extra></extra>"))
    fig <- fig |> layout(yaxis = list(title = paste0("Percentage")),
                         xaxis = list(title = "Year"))
    fig <- fig |> add_trace(x = ~year,
                            y = ~prop_specific_collection,
                            type = 'scatter',
                            mode = 'lines+markers',
                            name = paste0('Collection'),
                            marker = list(color = 'black'),
                            line = list(color = 'black'),
                            hovertemplate = paste("%{y:.2f}% of the collection<extra></extra>"))
    fig <- fig |> layout(hovermode = 'x unified',
                         yaxis = list(ticksuffix = '%'),
                         legend=list(title=list(text=paste0('<b>',text |> stringr::str_to_sentence(), '</b>'))))
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Line_Bar-Proportion_of_lost_',stringr::str_replace_all(text, ' ', '_'),'_',data_type,'.html'))
    }
    
    return(list(gain = fig1, loss = fig,  data_gain = plot_data_gain, data_loss = plot_data_loss))
    
  }
}
```

```{r, region names}

level_2 = c("10, 11, 12, 13, 14, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 50, 51, 60, 61, 62, 63, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 90, 91, Northern Europe, Middle Europe, Southwestern Europe, Southeastern Europe, Eastern Europe, Northern Africa, Macaronesia, West Tropical Africa, West-Central Tropical Africa, Northeast Tropical Africa, East Tropical Africa, South Tropical Africa, Southern Africa, Middle Atlantic Ocean, Western Indian Ocean, Siberia, Russian Far East, Middle Asia, Caucasus, Western Asia, Arabian Peninsula, China, Mongolia, Eastern Asia, Indian Subcontinent, Indo-China, Malesia, Papuasia, Australia, New Zealand, Southwestern Pacific, South-Central Pacific, Northwestern Pacific, North-Central Pacific, Subarctic America, Western Canada, Eastern Canada, Northwestern U.S.A., North-Central U.S.A., Northeastern U.S.A., Southwestern U.S.A., South-Central U.S.A., Southeastern U.S.A., Mexico, Central America, Caribbean, Northern South America, Western South America, Brazil, Southern South America, Subantarctic Islands, Antarctic Continent")
level_1 = c("1, 2, 3, 4, 5, 6, 7, 8, 9, Europe, Africa, Asia-Temperate, Asia-Tropical, Australasia, Pacific, Northern America, Southern America, Antarctic")

level_2 = data.frame(matrix(unlist(stringr::str_split(level_2, ', ')), ncol = 2))
names(level_2) = c('code', 'name') ; level_2$code = as.numeric(level_2$code)

level_1 = data.frame(matrix(unlist(stringr::str_split(level_1, ', ')), ncol = 2))
names(level_1) = c('code', 'name') ; level_1$code = as.numeric(level_1$code)

```

```{r theme_ggplot2}
library(ggplot2)

# Changing the default theme
if(is.null(ggtheme)){
  ggtheme <- function(base_size = 16) {
    ggplot2::theme_bw(base_size = base_size) %+replace%
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = rel(1), face = "bold", margin = margin(0,0,5,0), hjust = 0),
        panel.grid.minor = ggplot2::element_blank(),
        panel.border = ggplot2::element_blank(),
        axis.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
        axis.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
        axis.line = ggplot2::element_line(color = "black"),
        legend.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
        legend.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
        legend.key = ggplot2::element_rect(fill = "transparent", colour = NA),
        legend.key.size = ggplot2::unit(1.5, "lines"),
        legend.background = ggplot2::element_rect(fill = "transparent", colour = NA),
        strip.background = ggplot2::element_rect(fill = "#17252D", color = "#17252D"),
        strip.text = ggplot2::element_text(size = rel(0.85), face = "bold", color = "white", margin = margin(5,0,5,0))
      )
  }
}
theme_set(ggtheme())
update_geom_defaults("line", list(size = 2))

# Set the colour scale for the plots
scale_colour_continuous <- scale_colour_continuous
scale_colour_discrete   <- scale_colour_discrete
scale_colour_binned     <- scale_colour_binned
scale_fill_continuous <- scale_fill_continuous
scale_fill_discrete <- scale_fill_discrete
scale_fill_binned <- scale_fill_binned
```

```{r, Add combined geography column to enriched report}
geography_data = enriched_report[,grepl('_area_code_l3', names(enriched_report))]
want = c('000','010','001','011','100','110','101')

#Depending on the values of the options reduce `want` to only the satisfactory values.
##A) introduced / naturally occurring only.
if(native == 'Introduced only'){
  want = want[grepl('^1',want)]
}else if(native == 'Naturally occurring only'){
  want = want[grepl('^0',want)]
}
## B) Extinct
if(!extinct){
  want = want[!grepl('010|011|110',want)]
}
## C) Doubtful
if(!doubtful_locations){
  want = want[!grepl('001|011|101',want)]
}
geog_want_values = want
# Get the columns in wanted info that contain the geography information we want.
geography_data = geography_data[,grepl(paste0(want,collapse='|'), names(geography_data))]

if(length(want) > 1){
  level3codes =do.call("paste", c(geography_data, sep = ", "))
  level3codes = stringr::str_remove(level3codes, ', NA$')
  level3codes = stringr::str_remove(level3codes, 'NA, ')
}else{
  level3codes = geography_data
}
level3codes[level3codes == "NA"] = NA

enriched_report$geography_codes = level3codes
```

```{r, Get location_type_text}
location_type_text = ''
if(native == 'Naturally occurring only'){
  location_type_text = paste0(location_type_text, 'naturally occurring only,', collapse = ' ')  
}else if(native == 'Introduced only'){
  location_type_text = paste0(location_type_text, 'introduced only,', collapse = ' ')  
  
}else{
  location_type_text = paste0(location_type_text, 'Either naturally occurring or introduced,', collapse = ' ')  
}
if(extinct){
  location_type_text = paste0(location_type_text, ' allowing extinct regions and', collapse = ' ')  
}else{
  location_type_text = paste0(location_type_text, ' not including extinct regions and', collapse = ' ')  
}
if(doubtful_locations){
  location_type_text = paste0(location_type_text, ' allowing doubtful regions.', collapse = ' ')  
  
}else{
  location_type_text = paste0(location_type_text, ' not allowing doubtful regions.', collapse = ' ')  
}
```

`r if(any(! c('AccNoFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"*** \n **Warning!**\n\n This enriched report contains missing 'original' columns needed to perform the analyses in this report. Default values have been created. In particular, the following were missing "}`

`r if(!'AccNoFull' %in% names(enriched_report)){"- AccNoFull: assume each item is its own accession.\n"}`
`r if(!'AccYear' %in% names(enriched_report)){"- AccYear: Cannot do analyses over time.\n"}`
`r if(!'ItemStatusDate' %in% names(enriched_report)){"- AccNoFull: Cannot do analyses over time.\n"}`
`r if(!'ItemStatusType' %in% names(enriched_report)){"- AccNoFull: Cannot do analyses over time.\n"}`

`r if(any(! c('AccNoFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"***"}`

```{r, Find LC location}
coord_contained = TRUE
# Extract the location of the collection.
pnts <- data.frame( x = coordinates[2], y = coordinates[1])

# create a points collection
pnts_sf <- do.call("st_sfc",c(lapply(1:nrow(pnts), 
                                     function(i) {sf::st_point(as.numeric(pnts[i, ]))}), list("crs" = 4326))) 

pnts_trans <- st_transform(pnts_sf, 2163) # apply transformation to pnts sf
tt1_trans <- st_transform(wgsrpd3, 2163)      # apply transformation to polygons sf

intersect = as.vector(st_intersects(tt1_trans, pnts_trans, sparse = FALSE))
collection_geog_details = wgsrpd3[which(intersect),-5]
location_name = collection_geog_details$LEVEL3_NAM
location_code = collection_geog_details$LEVEL3_COD

if(length(location_name) == 0){
  coord_contained = FALSE
  # Try and find the nearest polygon.
  collection_geog_details  =  wgsrpd3[which.min(as.vector(sf::st_distance(tt1_trans, pnts_trans))),-5]
  location_name = collection_geog_details$LEVEL3_NAM
  location_code = collection_geog_details$LEVEL3_COD
}
```


```{r, Extracting information from enriched report, echo = F}
# Add required columns if missing.
do_over_time = TRUE
needed_columns = c('AccNoFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType')
if(!'AccNoFull' %in% names(enriched_report)){
  enriched_report$AccNoFull = 1:nrow(enriched_report)
}
if(!'AccYear' %in% names(enriched_report)){
  do_over_time = FALSE
  enriched_report$AccYear = rep(0, nrow(enriched_report))
}
if(!'ItemStatusDate' %in% names(enriched_report)){
  do_over_time = FALSE
  enriched_report$ItemStatusDate = rep(NA, nrow(enriched_report))
}
if(!'ItemStatusType' %in% names(enriched_report)){
  do_over_time = FALSE
  enriched_report$ItemStatusType = rep('Existing', nrow(enriched_report))
}
if(all(is.na(enriched_report$ItemStatusDate))){
  do_over_time = FALSE
}
if(all(is.na(enriched_report$ItemStatusType))){
  do_over_time = FALSE
}
if(all(is.na(enriched_report$AccYear))){
  do_over_time = FALSE
}

#Extract endemic information from enriched_report
endemic = rep('Widespread', nrow(enriched_report))
endemic_index = which(stringr::str_length(enriched_report$geography_codes) == 3)
endemic[endemic_index] = 'Endemic'
enriched_report$endemic = endemic
rm(endemic)

# Extract threatened. 
threat_cat = c('VU','EN','CR','EW','EX')
threatened = rep('Not Threatened', nrow(enriched_report))
threatened[which(enriched_report$redList_category %in% threat_cat)] = 'Threatened'
threatened[which(enriched_report$POWO_Red_category %in% threat_cat)] = 'Threatened'
enriched_report$threatened = threatened
rm(threatened)

# Extract threatened category. 
threatened_category = rep(NA, nrow(enriched_report))
for(i in 1:length(threat_cat)){
  threatened_category[which(enriched_report$redList_category == threat_cat[i])] = threat_cat[i]
  threatened_category[which(enriched_report$POWO_Red_category == threat_cat[i])] = threat_cat[i]
}
enriched_report$threatened_category = threatened_category
rm(threatened_category)

# Convert Provenance code to text.
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'G'] = 'Garden'
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'U'] = 'Unknown'
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'W'] = 'Wild'
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'Z'] = 'Wild-derived'

# Add native column.
nativeo = rep('Non-native', nrow(enriched_report))
native_index = which(grepl(location_code, enriched_report$geography_codes))
nativeo[native_index] = 'Native'
enriched_report$native = nativeo
rm(nativeo)

LossYear = rep(NA,nrow(enriched_report))
ItemStatusYear = as.numeric(stringr::str_extract(enriched_report$ItemStatusDate,pattern = '[0-9]{4}'))
LossYear[enriched_report$ItemStatusType == 'NotExisting'] = ItemStatusYear[enriched_report$ItemStatusType == 'NotExisting']
enriched_report$LossYear = LossYear

# Create a sanitised taxonomic name.
enriched_report$good_name = paste0(enriched_report$sanitised_taxon, ' ', enriched_report$extracted_author)

best_name = paste0(enriched_report$POWO_taxon_name, ' ', enriched_report$POWO_taxon_authors)
best_name[which(best_name == 'NA NA')] = enriched_report$good_name[which(best_name == 'NA NA')]
enriched_report$best_name = best_name
report_original = enriched_report

if(separate_figure_folder){
  figures_dir = paste0(output_dir,'/',collection,'_Figures')
  dir.create(figures_dir,showWarnings = FALSE)
}

exporting_data_store = list()
```

This report explores endemic species in **`r collection`**, and how the number of endemic species has varied over time.

A taxa in the collection is classed as **endemic** if it is native to a single BRU level 3 area. Note that the area does not have to be the one the collection belongs to. Therefore, we need geographic information to quantify if a taxa is endemic.  To determine the geographic distribution of items in the LC we enrich with information from [Plants of the World Online](https://powo.science.kew.org), by matching taxonomic names. POWO uses [TDWG geographical codes](https://www.tdwg.org/standards/wgsrpd/) (Brummitt, 2001) expressed to that system's third level. This splits the world into 369 regions. Thus, each accepted name in POWO is associated with a list of geographic regions. POWO splits the geographic regions associated with a taxa by three conditions:

- Native / introduced,
- Extinct / Not extinct,
- Location is doubtful / otherwise.

This document considers locations that are: `r location_type_text` 
 
```{r get endemic only information}
endemic = enriched_report[enriched_report$endemic == 'Endemic',]

# Endemic must match to POWO so no naming issues.
endemic_existing = endemic[endemic$ItemStatusType == 'Existing',] 
no_endemic_items_existing = nrow(endemic_existing)
no_endemic_accessions_existing = length(unique(endemic_existing$AccNoFull))
no_endemic_species_existing = length(unique(paste0(endemic_existing$POWO_genus, ' ', endemic_existing$POWO_species)))
no_endemic_taxa_existing = length(unique(paste0(endemic_existing$POWO_taxon_name, ' ', endemic_existing$POWO_taxon_authors)))

# For all items we need to be more careful. Items and accessions are fine. 
# For species and taxa only consider those that have matched to POWO. 
LC_existing = enriched_report[enriched_report$ItemStatusType == 'Existing',]
no_LC_items_existing = nrow(LC_existing)
no_LC_accessions_existing = length(unique(LC_existing$AccNoFull))
no_LC_species_existing = length(unique(paste0(LC_existing$POWO_genus, ' ', LC_existing$POWO_species)))
no_LC_species_existing = no_LC_species_existing - sum(any(is.na(LC_existing$POWO_genus)))
no_LC_taxa_existing = length(unique(paste0(LC_existing$POWO_taxon_name, ' ', LC_existing$POWO_taxon_authors)))
no_LC_taxa_existing = no_LC_taxa_existing - sum(any(is.na(LC_existing$POWO_genus)))


category = c('Items', 'Accessions', 'Species', 'Taxa')
endemic_values = c(no_endemic_items_existing, no_endemic_accessions_existing, no_endemic_species_existing, no_endemic_taxa_existing)
LC_values  = c(no_LC_items_existing, no_LC_accessions_existing, no_LC_species_existing, no_LC_taxa_existing)
proportion = paste0(round(endemic_values/LC_values*100, digits = 2),'%')

endemic_count_table = data.frame(category, LC_values, endemic_values, proportion)
names(endemic_count_table) = c('Kind', 'All', 'Endemic', 'Proportion')
if(export_data){
  exporting_data_store$endemic_count_table = endemic_count_table
}

### Over time information
### A) Endemic
year_cur = as.numeric(format(Sys.Date(), '%Y'))
years = max(min_year, min(enriched_report$AccYear[enriched_report$AccYear > 1650],na.rm = T)) :year_cur
dates = paste0(years,'-01-01')
endemic_existing_each_year = BGSmartR::exist_at_date(date = dates,
                                                     AccessionYear = as.character(endemic$AccYear),
                                                     ItemStatusDate = as.character(endemic$ItemStatusDate),
                                                     ItemStatusType = as.character(endemic$ItemStatusType))

# Get the number of items accession taxa species for endemic plants in the LC.
over_time_info = lapply(endemic_existing_each_year, function(x){
  garden_current = endemic[x,]
  
  # Get the values of interest.
  no_items = nrow(garden_current)
  no_accessions = length(unique(garden_current$AccNoFull))
  no_taxa = length(unique(garden_current$TaxonNameFull))
  no_species = length(unique(paste0(garden_current$POWO_taxon_name, garden_current$POWO_taxon_authors)[!is.na(garden_current$POWO_plant_name_id)]))
  
  return(c(no_items, no_accessions, no_taxa, no_species))
}) |>
  data.frame() |>
  t() |> 
  data.frame()
names(over_time_info) = c('Items', 'Accessions', 'Taxa', 'Species')
over_time_info = data.frame(Date = dates, over_time_info)
row.names(over_time_info) = 1:nrow(over_time_info)
endemic_over_time = over_time_info

if(export_data){
  exporting_data_store$Number_of_endemic_species_in_LC_over_time = endemic_over_time
}

### B) Whole LC.
# Do the same for the whole collection.
report = enriched_report
report = report[report$AccYear > 1650 & report$AccYear<=year_cur,]
report = report[!is.na(report$ItemStatusDate),]
plant_existing = BGSmartR::exist_at_date(dates, AccessionYear = as.character(report$AccYear),
                                         ItemStatusDate = as.character(report$ItemStatusDate),
                                         ItemStatusType = as.character(report$ItemStatusType))

# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing, function(x){
  garden_current = report[x,]
  
  # Get the values of interest.
  no_items = nrow(garden_current)
  no_accessions = length(unique(garden_current$AccNoFull))
  no_taxa = length(unique(garden_current$TaxonNameFull))
  no_species = length(unique(paste0(garden_current$POWO_taxon_name, garden_current$POWO_taxon_authors)[!is.na(garden_current$POWO_plant_name_id)]))
  
  return(c(no_items, no_accessions, no_taxa, no_species))
}) |>
  data.frame() |>
  t() |> 
  data.frame()
names(over_time_info) = c('Items', 'Accessions', 'Taxa', 'Species')
over_time_info = data.frame(Date = dates, over_time_info)
row.names(over_time_info) = 1:nrow(over_time_info)
LC_data = over_time_info

if(export_data){
  exporting_data_store$Total_counts_of_LC_over_time = LC_data
}

### MANAGEMENT SHEET: All existing endemic accessions.
endemic_accessions = endemic_existing
endemic_accessions = endemic_accessions[match(unique(endemic_accessions$AccNoFull),endemic_accessions$AccNoFull),]
powo_name = paste0(endemic_accessions$POWO_taxon_name, ' ', endemic_accessions$POWO_taxon_authors)
powo_name[powo_name == 'NA NA'] = NA
endemic_accessions$powo_name = powo_name
endemic_accessions = endemic_accessions[,match(c('AccNoFull', 'TaxonNameFull', 'powo_name', 'threatened', 'endemic', 'geography_codes', 'ProvenanceCode'), names(endemic_accessions))]
names(endemic_accessions) = c('Accession Number', 'Original Taxonomic Name and Author', 'POWO Taxonomic Name and Author', 'Threatened', 'Endemic', 'Endemic to..', 'Provenance')
endemic_accessions$`Endemic to..` = wgsrpd3$LEVEL3_NAM[match(endemic_accessions$`Endemic to..`, wgsrpd3$LEVEL3_COD)]
endemic_accessions$`Endemic to..` = stringr::str_replace_all(endemic_accessions$`Endemic to..`, 'Is.', 'Islands')
endemic_accessions$`Endemic to..` = stringr::str_replace_all(endemic_accessions$`Endemic to..`, 'I.', 'Island')
writexl::write_xlsx(endemic_accessions, path =paste0(output_dir,'/',collection,'_endemic_accessions_list.xlsx'))


```

### Endemic collection size

In the living collection there are `r format(no_endemic_items_existing, big.mark=',')` items corresponding to  `r format(no_endemic_accessions_existing, big.mark=',')` accessions of existing endemic plants. The number of endemic species existing in the living collection is summarised below. Note that here species is defined as the genus species pair and taxa is the taxonomic name and author (thus including subspecies, variety, forma).

```{r, How many native species are in the LC - table}
if(report_kind == 'static'){
  endemic_count_table |>
    flextable() |>
    set_caption(caption = "Endemic plants in the LC") |> 
    font(fontname = "Calibri (Body)", part = "all") |> 
    fontsize(size = table_font_size, part = "body") |> 
    # add footer if you want
    # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
    #                colwidths = 4) |> 
    theme_booktabs() |> # default theme
    autofit()
}
if(report_kind == 'interactive'){
  endemic_count_table |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(endemic_count_table), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=F,
                                 ordering=F))
  
  # DT::datatable(endemic_count_table,
  #               rownames = FALSE,
  #               # caption = paste0('Native plants in the LC (',paste0(location_name, collapse = ', '),')'),
  #               options = list(dom = 't'))
}

```

***

### Change of endemic over time

In this section we explore how the number of endemic species in the collection has varied over time. For each year we use the accession year and item status date to determine which items in the collection are existing on the 1st of January each year.

```{r, What proportion of the LC at `r collection` is endemic and how has this varied over time - static number figures, eval = report_kind == 'static' & do_over_time,  fig.fullwidth=TRUE, fig.dim = c(10, 6)}
to_do = c('Items', 'Accessions', 'Taxa', 'Species')
titles = c('items', 'accessions', 'taxa', 'species')
for(i in 1:length(to_do)){
  counts = endemic_over_time[,match(to_do[i], names(endemic_over_time))]
  plot_data = data.frame(date = years, counts = counts)
  
  p = ggplot(data=plot_data, aes(x=date, y=counts)) +
    geom_line()+
    geom_point() +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title=paste0("Number of endemic ", titles[i] , " over time"),
         x ="Year",
         y = paste0("Number of ",titles[i])) #+
  # guides(fill=guide_legend(title=paste0("", titles[i]))) +
  # theme(text = element_text(size=table_font_size))
  
  if(separate_figure_folder){
    ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','number_endemic_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
  }
  
  print(p)
}
```

`r if(report_kind == 'interactive' & do_over_time){"##### Number of endemic over time  {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Items"}`
```{r  Number of endemic items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
number_over_time <- function(data, type, title){
counts = data[,match(type, names(data))]
plot_data = data.frame(date = years, counts = counts)

fig <- plot_ly(plot_data, x = ~date, y = ~counts, type = 'scatter', mode = 'lines+markers', line = list(color = interactive_colour(1)), marker = list(color = interactive_colour(1)))

fig <- fig |> layout(yaxis = list(title = paste0("Number of ",title)),
                   xaxis = list(title = "Year"))
fig <- fig |> layout(hovermode = 'x unified')
return(fig)
}
fig = number_over_time(data = endemic_over_time, type = 'Items', title = 'items')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','number_of_endemic_items_over_time.html'))
}

fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Accessions"}`
```{r  Number of endemic accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = number_over_time(data = endemic_over_time, type = 'Accessions', title = 'accessions')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','number_of_endemic_accessions_over_time.html'))
}

fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Taxa"}`
```{r  Number of endemic taxa over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = number_over_time(data = endemic_over_time, type = 'Taxa', title = 'taxa')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','number_of_endemic_taxa_over_time.html'))
}

fig

```

`r if(report_kind == 'interactive' & do_over_time){"###### Species"}`
```{r  Number of endemic species over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = number_over_time(data = endemic_over_time, type = 'Species', title = 'species')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','number_of_endemic_species_over_time.html'))
}

fig
```

`r if(report_kind == 'interactive' & do_over_time){"##### {-}"}`

`r if(do_over_time){"Next we view endemic plants in the living collection as a percentage of all plants in the collection over time."}`

```{r, What proportion of the LC at `r collection` is endemic and how has this varied over time - percentage data, eval = do_over_time}
# Do the same for the whole collection.
report = report_original
report = report[report$AccYear > 1650 & report$AccYear<=year_cur,]
report = report[!is.na(report$ItemStatusDate),]
date = paste0(years,'-01-01')
plant_existing = BGSmartR::exist_at_date(date, AccessionYear = as.character(report$AccYear),
                       ItemStatusDate = as.character(report$ItemStatusDate),
                       ItemStatusType = as.character(report$ItemStatusType))

# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing, function(x){
    garden_current = report[x,]
    
    # Get the values of interest.

    no_items = nrow(garden_current)
    no_accessions = length(unique(garden_current$AccNoFull))
    no_taxa = length(unique(garden_current$TaxonNameFull))
    no_species = length(unique(paste0(garden_current$POWO_taxon_name, garden_current$POWO_taxon_authors)[!is.na(garden_current$POWO_plant_name_id)]))

    return(c(no_items, no_accessions, no_taxa, no_species))
}) |>
                  data.frame() |>
                  t() |> 
                  data.frame()
names(over_time_info) = c('Items', 'Accessions', 'Taxa', 'Species')
over_time_info = data.frame(Date = date, over_time_info)
row.names(over_time_info) = 1:nrow(over_time_info)
LC_data = over_time_info

if(export_data){
  exporting_data_store$Total_species_in_LC_over_time = LC_data
}
```

```{r, What proportion of the LC at `r collection` is endemic and how has this varied over time - static percentage figures, eval = report_kind == 'static' & do_over_time, fig.fullwidth=TRUE, fig.dim = c(10, 6)}
to_do =  c('Items', 'Accessions', 'Taxa', 'Species')
titles = c('items', 'accessions', 'taxa', 'species')

# Loop over to_do.
for(i in 1:length(to_do)){
  endemic_counts = endemic_over_time[,match(to_do[i], names(endemic_over_time))]
  total_counts = LC_data[,match(paste0(to_do[i]), names(LC_data))]
  
  percent = round(endemic_counts/total_counts*100, digits = 3)
  
  plot_dataA = data.frame(date =years, 
                          percent = percent,
                          represented = rep('Endemic', length(date)))
  plot_dataB = data.frame(date =years, 
                          percent = 100-percent,
                          represented = rep('Widespread', length(date)))
  
  plot_data = rbind(plot_dataA, plot_dataB)
  plot_data$represented = factor(plot_data$represented,levels = c('Widespread','Endemic'))
  
  names(plot_data) = c('dates', 'percentage', 'represented')
  
  p = ggplot(plot_data, aes(fill=represented, y=percentage, x=dates)) + 
    geom_bar(position="stack", stat="identity", width = 1) +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title=paste0("Proportion of ", titles[i] , " that are endemic in the LC over time"),
         x ="Year",
         y = "Percentage (%)") +
    guides(fill=guide_legend(title=paste0("", titles[i]))) +
    scale_fill_discrete() # +
  # theme(text = element_text(size=table_font_size))
  
  if(separate_figure_folder){
    ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','proportion_endemic_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
  }
  
  print(p)
}


```

`r if(report_kind == 'interactive' & do_over_time){"#####  Proportion of endemic over time {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Items"}`
```{r  Proportion of endemic items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
proportion_plot <- function(data, LC_data, type, title){
  native_counts = data[,match(type, names(data))]
  total_counts = LC_data[,match(paste0(type), names(LC_data))]

  percent = round(native_counts/total_counts*100, digits = 3)
  

  # Line graph of only the native plants. 
  plot_data = data.frame(date =years, 
                               percent = percent
                               )
  fig <- plot_ly(plot_data, x = ~date, y = ~percent, type = 'scatter', mode = 'lines+markers', line = list(color = interactive_colour(1)), marker = list(color = interactive_colour(1)))

fig <- fig |> layout(yaxis = list(title = paste0("Percentage of ",title)),
                   xaxis = list(title = "Year"))
fig <- fig |> layout(hovermode = 'x unified',
                     yaxis = list(ticksuffix  ='%', hoverformat = '.1f'))
  

  # Stacked Bar version. 
   # plot_dataA = data.frame(date =years, 
   #                             percent = percent,
   #                             represented = rep('Native', length(date)))
   # 
  # plot_dataB = data.frame(date =years, 
  #                            percent = 100-percent,
  #                             represented = rep('Non-Native', length(date)))
  
  # plot_data = rbind(plot_dataA, plot_dataB)
  # plot_data$represented = factor(plot_data$represented, levels = c('Native', 'Non-Native'))
  # fig <- plot_ly(plot_data, x = ~date, y = ~percent, color = ~represented, type = 'bar', colors = interactive_colour(2))
  # fig <- fig |> layout(yaxis = list(title = paste0('Percentage of ',title)),
  #                      xaxis = list(title = "Year"),
  #                      legend=list(title=list(text=paste0("Native ", title))),
  #                      barmode = 'stack',
  #                      hoverlabel = list(namelength = -1))
  # fig <- fig |> layout(hovermode = 'x unified',
  #                      bargap =0,
  #                      yaxis = list(ticksuffix  ='%', hoverformat = '.1f')
                       
return(fig)
}

fig = proportion_plot(data = endemic_over_time, LC_data = LC_data, type = 'Items', title = 'items')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','percentage_of_endemic_items_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Accessions"}`
```{r  Proportion of endemic accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = proportion_plot(data = endemic_over_time, LC_data = LC_data, type = 'Accessions', title = 'accessions')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','percentage_of_endemic_accessions_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Taxa"}`
```{r  Proportion of endemic taxa over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = proportion_plot(data = endemic_over_time, LC_data = LC_data, type = 'Taxa', title = 'taxa')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','percentage_of_endemic_taxa_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Species"}`
```{r  Proportion of endemic species over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = proportion_plot(data = endemic_over_time, LC_data = LC_data, type = 'Species', title = 'species')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','percentage_of_endemic_species_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"##### {-}"}`

***
  
### Geographic distribution

```{r Endemic Species map -  data}
# Get all BRU level 3 location codes.
All_locations = wgsrpd3$LEVEL3_COD

wanted_info = endemic_existing
wanted_info_species = wanted_info[match(unique(wanted_info$best_name), wanted_info$best_name),]

#Get the number of speices for each location.
no_endemic_items = unlist(lapply(All_locations, function(x){
  sum(grepl(x, wanted_info$geography_codes))
}))
#Get the number of speices for each location.
no_endemic_species = unlist(lapply(All_locations, function(x){
  sum(grepl(x, wanted_info_species$geography_codes))
}))


# Combine the wanted information into location data.
location_data = data.frame(code =  wgsrpd3$LEVEL3_COD,
                           name = wgsrpd3$LEVEL3_NAM,
                           rep_endemic = no_endemic_items > 0,
                           no_endemic_items = no_endemic_items,
                           no_endemic_species = no_endemic_species
)

location_data$name = stringr::str_replace(location_data$name, 'Is\\.', 'Islands')
location_data$name = stringr::str_replace(location_data$name, 'I\\.', 'Island')

# If we are given wcvp calculate the number of endemic species that each geographic area contains.
# if(!is.null(wcvp) & is.null(endemic_species_per_region)){
  #Geography data from wcvp
  geography_data = wcvp$geography[,grepl('_area_code_l3', names(wcvp$geography))]
  # Get the columns in wanted info that contain the geography information we want.
  geography_data = geography_data[,grepl(paste0(geog_want_values,collapse='|'), names(geography_data))]
  
  # If multiple columns join the strings such that each contains only a single list of regions.
  if(length(geog_want_values) > 1){
    level3codes =do.call("paste", c(geography_data, sep = ", "))
    level3codes = stringr::str_remove(level3codes, ', NA$')
    level3codes = stringr::str_remove(level3codes, 'NA, ')
  }else{
    level3codes = geography_data
  }
  level3codes[level3codes == "NA"] = NA
  
  wcvp_geography = data.frame(id = wcvp$geography$plant_name_id,
                              codes = level3codes)
  
  #Next we need to extract all the plant name ids from wcvp that are  accepted
  plant_ids = wcvp$wcvp_names$plant_name_id[wcvp$wcvp_names$taxon_status %in% c('Accepted')]
  
  # reduce wcvp_geography to only accepted plant name ids. (Note that usually only accepted plants have geography so this won't actually remove many records)
  wcvp_geography = wcvp_geography[wcvp_geography$id %in% plant_ids,]
  
  # Reduce to only endemic plants.
  wcvp_geography = wcvp_geography[stringr::str_length(wcvp_geography$codes) == 3,] 
  
  no_endemic_accepted_species_wcvp = unlist(lapply(All_locations, function(x){
    sum(grepl(x, wcvp_geography$codes))
    
  }))
  
  location_data$no_endemic_accepted_wcvp_species = no_endemic_accepted_species_wcvp

# }
if(!is.null((endemic_species_per_region))){
  no_endemic_accepted_species_wcvp = endemic_species_per_region[,2][match(location_data$code,endemic_species_per_region[,1])]
  location_data$no_endemic_accepted_wcvp_species = no_endemic_accepted_species_wcvp
}

if(!is.null(wcvp)){
  
  ## Which regions do we have 0 endemic items (when species exist in wcvp)
  missing_regions = location_data[which(location_data$no_endemic_items == 0 & location_data$no_endemic_accepted_wcvp_species !=0), match(c('name', 'code', 'no_endemic_accepted_wcvp_species'), names(location_data))]
  wgsrpd3$LEVEL1_COD[match(missing_regions$code,wgsrpd3$LEVEL3_COD)]
  level_1_names = level_1$name[match(wgsrpd3$LEVEL1_COD[match(missing_regions$code,wgsrpd3$LEVEL3_COD)], level_1$code)]
  level_2_names = level_2$name[match(wgsrpd3$LEVEL2_COD[match(missing_regions$code,wgsrpd3$LEVEL3_COD)], level_2$code)]
  missing_regions = data.frame(missing_regions$name, level_2_names, level_1_names, missing_regions$no_endemic_accepted_wcvp_species)
  
  
  names(missing_regions) = c('Region', 'Level 2 region','Level 1 region', 'Number of Endemic Species')
  missing_regions = missing_regions[order(missing_regions$`Number of Endemic Species`, decreasing = T),]
  ids = wcvp_geography$id[wcvp_geography$codes %in% location_data[which(location_data$no_endemic_items == 0 & location_data$no_endemic_accepted_wcvp_species !=0), match(c('code'), names(location_data))]]

  wcvp_wanted = wcvp$wcvp_names[wcvp$wcvp_names$plant_name_id %in% ids,]
  wcvp_wanted$geography = location_data$name[match(wcvp_geography$codes[match(wcvp_wanted$plant_name_id, wcvp_geography$id)],location_data$code)]
  wcvp_wanted$web_link = paste0("https://powo.science.kew.org/taxon/urn:lsid:ipni.org:names:",wcvp_wanted$powo_id)
  wcvp_wanted = wcvp_wanted[c('taxon_name', 'web_link', 'geography', 'powo_id', 'ipni_id', "family", "genus", "species_hybrid", "species",              "infraspecific_rank", "infraspecies", "parenthetical_author", "primary_author", "publication_author", "nomenclatural_remarks", "geographic_area", "lifeform_description", "climate_description")]
  
  wcvp_wanted = wcvp_wanted[order(wcvp_wanted$geography),]
}

plot_info <- wgsrpd3 |>
  #add the location data to the geometry data
  dplyr::left_join(location_data, by=c("LEVEL3_COD"="code"))

# Do we want to export the data into an excel spreadsheet and r data file.
if(export_data){
  l = location_data
  if(!is.null(wcvp) | !is.null(endemic_species_per_region)){
    names(l) = c('BRU level 3 code',
                 'BRU level 3 name',
                 'Has Endemic Species in LC',
                 'Number of Endemic Items',
                 'Number of Endemic Species')
  }else{
    names(l) = c('BRU level 3 code',
                 'BRU level 3 name',
                 'Has Endemic Species in LC',
                 'Number of Endemic Items',
                 'Number of Endemic Accepted Species in WCVP')
  }
  
  exporting_data_store$map_of_endemic_species = location_data
  rm(l)
}
all_endemic = sum(plot_info$no_endemic_accepted_wcvp_species != 0 )
percent_rep = round(sum(plot_info$rep_endemic) / all_endemic *100,digits = 2)
no_rep = plot_info$LEVEL3_NAM[!plot_info$rep_endemic & plot_info$no_endemic_accepted_wcvp_species != 0 ]
```

Next we produce maps showing where in the world the endemic plants in the living collection are from. 

Note that not every region has endemic species. In particular, within WCVP there are `r sum(location_data$no_endemic_accepted_wcvp_species == 0)` regions that have no endemic species. For example: `r paste0(location_data$name[location_data$no_endemic_accepted_wcvp_species == 0][1:5], collapse = ', ')`. Therefore, those regions are removed prior to creating the maps.

```{r, Number Endemic Species in the LC - figure, fig.fullwidth=FALSE, fig.dim = c(10, 6), eval = report_kind == 'static'}
top10_name = plot_info$LEVEL3_NAM[order(plot_info$no_endemic_species, decreasing = TRUE)][1:10]
top10_value = plot_info$no_endemic_species[order(plot_info$no_endemic_species, decreasing = TRUE)][1:10]
top10 = data.frame(region = top10_name, no_endemic = top10_value)

plot_info = plot_info[!plot_info$no_endemic_accepted_wcvp_species ==0,]
###################################################################
# Plot of the representation of endemic species in each geographic region.
# Regions that have no endemic plants are set to NA.
plot_info$rep_endemic[plot_info$rep_endemic == TRUE] = 'Yes'
plot_info$rep_endemic[plot_info$rep_endemic == FALSE] = 'No'

if('no_endemic_accepted_wcvp_species' %in% names(plot_info)){
  plot_info$rep_endemic[plot_info$no_endemic_accepted_wcvp_species == 0] = 'No Endemic'
}
plot_info$Represented = plot_info$rep_endemic

p = ggplot(plot_info)+
  geom_sf(aes(fill=Represented),  col="transparent")+
  stat_sf_coordinates(aes(col=Represented), show.legend = FALSE)+
  coord_sf(expand=FALSE) + 
  ggtitle("Endemic Species represented in the LC")

if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Map_representation_of_endemic_species.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}

p
###################################################################
###################################################################
# Plot of the number of endemic species in each geographic region.
plot_info$no_endemic_species[plot_info$no_endemic_species == 0] = NA
p = ggplot(plot_info)+
  geom_sf(aes(fill=no_endemic_species),  col="transparent")+
  stat_sf_coordinates(aes(col=no_endemic_species))+
  scale_colour_distiller(direction=1, 
                         name="Number\nof Species", na.value = 'black') +
  scale_fill_distiller(direction=1,
                       name="Number\nof Species", na.value = 'black')+
  coord_sf(expand=FALSE) + 
  ggtitle("Number of Endemic Species")

if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Map_number_of_endemic_species.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}

p
###################################################################
# Plot of the proportion of endemic species represented by each area in the LC 
if('no_endemic_accepted_wcvp_species' %in% names(plot_info)){
  plot_info$prop_endemic_species = plot_info$no_endemic_species / plot_info$no_endemic_accepted_wcvp_species
  plot_info$prop_endemic_species[plot_info$no_endemic_accepted_wcvp_species == 0] = NA
  
  p = ggplot(plot_info)+
    geom_sf(aes(fill=prop_endemic_species),  col="transparent")+
    stat_sf_coordinates(aes(col=prop_endemic_species)) + 
    scale_colour_distiller(direction=1, 
                           name="Percentage of\n Endemic Species\n in LC", na.value = 'black', labels = scales::label_percent()) +
    scale_fill_distiller(direction=1,
                         name="Percentage of\n Endemic Species\n in LC", na.value = 'black', labels = scales::label_percent())+
    coord_sf(expand=FALSE)+ 
    ggtitle("Percentage of Accepted Endemic Species \n in WCVP found in the LC for each region")
  
  if(separate_figure_folder){
    ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Map_proportion_of_endemic_species_from_area_in_LC.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
  }
  
  p
}


###################################################################
```

```{r, interactive map data setup, eval = report_kind == 'interactive'}
# Due to the high level of detail in wgsrpd3 we need to go to a simplified geometry for the interactive geometry plots. 
# load all geo areas
wgsrpd3_level3_simp = BGSmartR::wgsrpd3_level3_simp

# Reduce to only regions that have endemic species.
plot_int_info <- wgsrpd3_level3_simp |>
  dplyr::left_join(location_data, by=c("code"="code"))
plot_int_info$name = plot_int_info$name.x
regions_to_remove = plot_int_info$code[plot_int_info$no_endemic_accepted_wcvp_species == 0]

plot_int_info = plot_int_info[!plot_int_info$no_endemic_accepted_wcvp_species == 0,]
locations = wgsrpd3_level3_simp
locations = locations[!locations$code %in% regions_to_remove, drop = TRUE]

data_g = st_geometry(plot_int_info)
centers = st_centroid(data_g)
AA = unlist(centers)
center_df = data.frame(long = AA[seq(1,length(AA),2)], lat = AA[seq(2,length(AA),2)])

# Convert geometry into a format accepted by plotly
mapp = sf::st_cast(wgsrpd3_level3_simp, "MULTIPOLYGON")
geo_sf = geojsonsf::sf_geojson(mapp)
data = rjson::fromJSON(geo_sf)
feat = data$features
for(i in 1:length(feat)){
  feat[[i]]$id = feat[[i]]$properties$code
}
data$features = feat

data$features = data$features[-c(which(location_data$code %in% regions_to_remove))]

index = seq(0,1,0.01)
col_rep = color_binary
colours = c(rep(col_rep[1],51), rep(col_rep[2],50))
counter = 1:length(index)
col_scale_rep = lapply(counter, function(i){return(c(index[i], colours[i]))})

colours_cont = scales::brewer_pal(palette = palette, direction = 1)(7)
ramp <- scales::colour_ramp(colours_cont)
colos = ramp(seq(0, 1, length = 1001))


index = seq(0,1,0.001)
colours_cont = c( "#e6e6e6","#e6e6e6",colos)
counter = 1:length(index)
col_scale = lapply(counter, function(i){return(c(index[i], colours_cont[i]))})

plot_int_info$name = stringr::str_replace(plot_int_info$name, 'Is\\.', 'Islands')
plot_int_info$name = stringr::str_replace(plot_int_info$name, 'I\\.', 'Island')
```

`r if(report_kind == 'interactive'){"##### Maps of Endemic species held in the LC {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Representation"}`
```{r  Map of the representation of Endemic species - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'interactive'}
rep_endemic = rep('No', nrow(plot_int_info))
rep_endemic[plot_int_info$rep_endemic] = 'Yes'
plot_int_info$rep_endemic_yes_no = rep_endemic
text = paste0('Region: ', plot_int_info$name, '<br />', 
              'Represented: ', rep_endemic, '<br />',
              '# Species in LC: ', plot_int_info$no_endemic_species, '/',plot_int_info$no_endemic_accepted_wcvp_species,'<br />',
              '# Items in LC: ', plot_int_info$no_endemic_items, '<br />',
              'Endemic from region in LC: ', round(plot_int_info$no_endemic_species*100/plot_int_info$no_endemic_accepted_wcvp_species,digits = 2),
              '%', '<br />')
plot_int_info$hover = text

fig = plot_ly(plot_int_info,  text = ~hover, hoverinfo = 'text') |>
  add_trace(type="choroplethmapbox",
            geojson=data,
            locations=locations$code,
            z=as.numeric(plot_int_info$rep_endemic),
            colorscale=col_scale_rep,
            reversescale = FALSE,
            marker=list(line=list(
              width=0.01,color ='black'),
              text = plot_int_info$hover,
              hoverinfo = 'text'
            )) |>
  layout(
    mapbox=list(
      style="white-bg",
      center = list(lon = 0 ,lat= 60),
      zoom =0.46, 
      lataxis = list(range = c(-59, 90)))
  ) |>
  hide_colorbar()
# colorbar(title = "Species <br> Represented <br> in LC")  
fig = fig |>  add_trace(type="scattermapbox",
                        mode = 'markers',
                        data = center_df,
                        lon = center_df$long,
                        lat = center_df$lat,
                        text = plot_int_info$hover,
                        color = I(col_rep[as.numeric(plot_int_info$rep_endemic)+1]), 
                        hoverinfo = 'text',
                        inherit = FALSE, showlegend = FALSE) 

fig <- fig   |> config(modeBarButtonsToRemove = c("select2d", "lasso2d"))

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Geography-Representation_of_Endemic_Species.html'))
}
suppressWarnings(fig)

```

`r if(report_kind == 'interactive'){"###### By number of endemic held"}`
```{r  Map of the number of Endemic species - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'interactive'}
rep_endemic = rep('No', nrow(plot_int_info))
rep_endemic[plot_int_info$rep_endemic] = 'Yes'

  plot_int_info$no_endemic_species_use = plot_int_info$no_endemic_species
  plot_int_info$no_endemic_species_use[plot_int_info$no_endemic_species == 0] = -1
  
  colscale_0_1 = as.numeric(unlist(lapply(col_scale, function(x){x[[1]]})))
  point_value = (plot_int_info$no_endemic_species_use+1)/max(plot_int_info$no_endemic_species_use+1)
  color_index = unlist(lapply(point_value, function(x){which.min(abs(x - colscale_0_1))}))
  fillcolor = unlist(lapply(color_index, function(x){col_scale[[x]][2]}))
  
  
  # fig = fig |>  add_trace(type="scattermapbox",
  #                         mode = 'markers',
  #                         data = center_df,
  #                         lon = center_df$long,
  #                         lat = center_df$lat,
  #                         text = plot_int_info$hover,
  #                         # fill = plot_int_info$no_endemic_species+1,
  #                         # fillcolor=col_scale,
  #                         hoverinfo = 'skip',
  #                         inherit = FALSE,
  #                         showlegend = FALSE,
  #                         marker = list(color = fillcolor, line = list(width = 0)))


  
  fig = plot_ly(plot_int_info,  text = plot_int_info$hover, hoverinfo = 'text') |>
      add_trace(type="scattermapbox",
                          mode = 'markers',
                          data = center_df,
                          lon = center_df$long,
                          lat = center_df$lat,
                          text = plot_int_info$hover,
                          # fill = plot_int_info$no_endemic_species+1,
                          # fillcolor=col_scale,
                          hoverinfo = 'text',
                          inherit = FALSE,
                          showlegend = FALSE,
                          marker = list(color = fillcolor, line = list(width = 0)),
                          hoverlabel = list(bgcolor = fillcolor)) |>
    add_trace(type="choroplethmapbox",
     geojson=data,
     locations=locations$code,
     z=plot_int_info$no_endemic_species_use+1,
     zmin = 0, zmax = max(plot_int_info$no_endemic_species_use),
     colorscale=col_scale,
     reversescale = FALSE,
     marker=list(line=list(
     width=0.01,color ='black')),
     text = plot_int_info$hover,
     hoverinfo = 'text',
     hoverlabel = list(bgcolor = fillcolor)
    ) |>
    layout(
    mapbox=list(
      style="white-bg",
      center = list(lon = 0 ,lat= 60),
      zoom =0.46,
      lataxis = list(range = c(-59, 90)))
  ) |>
    colorbar(title = "Number of <br> taxa")


  fig <- fig   |> config(modeBarButtonsToRemove = c("select2d", "lasso2d"))

  if(separate_figure_folder){
    htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Geography-Number_of_Endemic_Species.html'))
  }
  suppressWarnings(fig)

```

`r if(report_kind == 'interactive'){"###### By proportion of accepted endemic held"}`
```{r  Map of the proportion of Accepted Endemic species - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'interactive'}
 rep_endemic = rep('No', nrow(plot_int_info))
rep_endemic[plot_int_info$rep_endemic] = 'Yes'

  prop = plot_int_info$no_endemic_species*100/plot_int_info$no_endemic_accepted_wcvp_species
  prop[prop ==  0] = -0.01

    
   colscale_0_1 = as.numeric(unlist(lapply(col_scale, function(x){x[[1]]})))
  point_value = (prop+0.01)/max(prop+0.01)
  color_index = unlist(lapply(point_value, function(x){which.min(abs(x - colscale_0_1))}))
  fillcolor = unlist(lapply(color_index, function(x){col_scale[[x]][2]}))

  
  fig = plot_ly(plot_int_info,  text = ~hover, hoverinfo = 'text') |>
    add_trace(type="choroplethmapbox",
     geojson=data,
     locations=locations$code,
     z= prop+ 0.01,
     colorscale=col_scale,
     reversescale = FALSE,
     marker=list(line=list(
     width=0.01,color ='black')),
     text = plot_int_info$hover,
     hoverinfo = 'text',
    hoverlabel = list(bgcolor = fillcolor)
    ) |>
    layout(
    mapbox=list(
      style="white-bg",
      center = list(lon = 0 ,lat= 60),
      zoom =0.46,
      lataxis = list(range = c(-59, 90)))
  )  |>
    # hide_colorbar()
    colorbar(title = "Proportion of <br> taxa")

  
  fig = fig |>  add_trace(type="scattermapbox",
                          mode = 'markers',
                          data = center_df,
                          lon = center_df$long,
                          lat = center_df$lat,
                          text = plot_int_info$hover,
                          colorscale=col_scale,
                          hoverinfo = 'text',
                          inherit = FALSE,
                          showlegend = FALSE,
                          marker = list(color = fillcolor, line = list(width = 0)),
                           hoverlabel = list(bgcolor = fillcolor))

  fig <- fig   |> config(modeBarButtonsToRemove = c("select2d", "lasso2d"))

  if(separate_figure_folder){
    htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Geography-Proportion_of_Accepted_Endemic_Species_held.html'))
  }
  suppressWarnings(fig)

```
`r if(report_kind == 'interactive'){"##### {-}"}`

In the living collection `r percent_rep`% of the BRU level 3 regions are represented by endemic species, with `r length(no_rep)` regions un-represented. 

`r if(length(no_rep) > 0){"Regions with no endemic species in the living collection are outlined below, together with the total number of endemic plants in each region."}`

```{r families not in the LC - Table, eval = length(no_rep) > 0}
if(report_kind == 'static'){
  missing_regions |>
  flextable() |>
  set_caption(caption = "") |> 
  font(fontname = "Calibri (Body)", part = "all") |> 
  fontsize(size = table_font_size, part = "body") |> 
  # add footer if you want
  # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
  #                colwidths = 4) |> 
  theme_booktabs() |> # default theme
  autofit()
}
if(report_kind == 'interactive'){
  missing_regions |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(missing_regions), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=T,
                                 ordering=T),
                  filter = list(position = "top"))
  
  
  # DT::datatable(missing_regions, rownames = FALSE,
  #                options = list(dom = 'tp',pageLength =  5), filter = list(position = "top"))
}

```

`r if(length(no_rep) > 0){':::: {.blackbox data-latex=""}'}`

`r if(length(no_rep) > 0){"Further information about the plants from the missing families can be downloaded using the button below."}`

```{r link to download plants from missing endemic regions, eval = report_kind == 'interactive' & length(no_rep) > 0}
  wcvp_wanted |>
  download_this(
    output_name = "WCVP endemic plants not represented in the LC",
    output_extension = ".xlsx",
    button_label = "Download missing endemic plants (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained = T
  )
```

`r if(length(no_rep) > 0){"::::"}`
 
***

### Duplication of endemic species

```{r, duplication of endemic species}
### How many items/accessions for each endemic taxa in the LC.
endemic_items_per_taxa = table(paste0(endemic_existing$POWO_taxon_name, ' ', endemic_existing$POWO_taxon_authors))
endemic_items_per_taxa_table = table(as.numeric(endemic_items_per_taxa))

endemic_items_per_taxa_simp = as.numeric(endemic_items_per_taxa)
endemic_items_per_taxa_simp[endemic_items_per_taxa_simp >= 5] = '>4'
endemic_items_per_taxa_table_simp = table(endemic_items_per_taxa_simp)

endemic_accessions = endemic_existing[match(unique(endemic_existing$AccNoFull), endemic_existing$AccNoFull),]
endemic_accessions_per_taxa = table(paste0(endemic_accessions$POWO_taxon_name, ' ', endemic_accessions$POWO_taxon_authors))
endemic_accessions_per_taxa_table = table(as.numeric(endemic_accessions_per_taxa))

endemic_accessions_per_taxa_simp = as.numeric(endemic_accessions_per_taxa)
endemic_accessions_per_taxa_simp[endemic_accessions_per_taxa_simp >= 5] = '>4'
endemic_accessions_per_taxa_table_simp = table(endemic_accessions_per_taxa_simp)

duplication_items = data.frame(endemic_items_per_taxa_table_simp)
names(duplication_items) = c('Duplication', 'Items')

duplication_items$percent = paste0(round(duplication_items$Items / sum(duplication_items$Items)*100,digits = 1),'%')
duplication_items <- duplication_items %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Items))), 
                pos = Items/2 + dplyr::lead(csum, 1),
                pos = dplyr::if_else(is.na(pos), Items/2, pos))


duplication_accessions = data.frame(endemic_accessions_per_taxa_table_simp)
names(duplication_accessions) = c('Duplication', 'Accessions')
# duplication_accessions$Provenance  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(duplication_accessions$Provenance, c('G', 'U', 'W', 'Z'))]
duplication_accessions$percent = paste0(round(duplication_accessions$Accessions / sum(duplication_accessions$Accessions)*100,digits = 1),'%')
duplication_accessions <- duplication_accessions %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Accessions))), 
                pos = Accessions/2 + dplyr::lead(csum, 1),
                pos = dplyr::if_else(is.na(pos), Accessions/2, pos))

flex_data = data.frame(duplication_items$Duplication,
                       duplication_items$Items, 
                       paste0(round(duplication_items$Items/sum(duplication_items$Items)*100,digits=2),'%'),
                       duplication_accessions$Accessions,
                       paste0(round(duplication_accessions$Accessions/sum(duplication_accessions$Accessions)*100,digits=2),'%'))
names(flex_data) = c('Duplication', 'Number of Endemic Species (by items)', 'Proportion of Endemic Species (by items)', 'Number of Endemic Species (by accessions)', 'Proportion of Endemic Species (by accessions)')

if(export_data){
  exporting_data_store$Duplication_of_existing_endemic_plants_in_the_LC = flex_data
}

```

In this section, we explore the duplication of existing endemic species in the living collection. 

Below we produce pie charts and a table of the number of endemic species that have 1, 2, 3, 4 or >4 items or accessions in the living collection. 

```{r Duplication of endemic plants in the LC - Table}
flex_data  = flex_data[c(2:5,1),]
if(report_kind == 'static'){
  flex_data |>
    flextable() |>
    set_caption(caption = paste0('Duplication of existing endemic plants in the LC')) |> 
    font(fontname = "Calibri (Body)", part = "all") |> 
    fontsize(size = table_font_size, part = "body") |> 
    # add footer if you want
    # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
    #                colwidths = 4) |> 
    theme_booktabs() |> # default theme
    separate_header() |> 
    align(align = "center", part = "all") |>
    autofit()
}


```


`r if(report_kind == 'static'){"Converting the table to pie charts yields "}`

```{r, Duplication of endemic plants in the LC pie charts, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'static'}
# Basic piechart
pie1 = ggplot(duplication_items, aes(x="", y=Items, fill=Duplication)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtheme(base_size = 18) +
  ggtitle('Items') +
  scale_fill_discrete() +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

pie2 = ggplot(duplication_accessions, aes(x="", y=Accessions, fill=Duplication)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtitle('Accessions') + 
  scale_fill_discrete() +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

if(value_on_fig){
  pie1 = pie1 + geom_label_repel(aes(y = pos,label = percent),
                                 size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white")   
  
  pie2 = pie2 + geom_label_repel(aes(y = pos,label = percent),
                                 size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white") 
}

p = ggpubr::ggarrange(pie1, pie2, ncol=2, nrow=1, common.legend = TRUE, legend="bottom")

if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Duplication_of_endemic_plants.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}


p

```

`r if(report_kind == 'interactive'){"#####  Duplication of endemic species {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Chart"}`
```{r  Duplication of existing endemic items in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
figs = list()

# Items
text = paste0(duplication_items$Items, ' Endemic Taxa has ', duplication_items$Duplication, ' items')
fig1 <- plot_ly(duplication_items, labels = ~Duplication, values = ~Items, hoverinfo = "text",  hovertext = text, sort = FALSE, marker = list(colors = scales::brewer_pal(palette = palette, direction = 1)(5)))
fig1 <- fig1 |> add_pie(hole = 0.6)
fig1 <- fig1 |> layout(title = "Items",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
figs$items = fig1
#Accessions
text = paste0(duplication_accessions$Accessions, ' endemic taxa has', duplication_accessions$Duplication, ' accessions')
fig2 <- plot_ly(duplication_accessions, labels = ~Duplication, values = ~Accessions, hoverinfo = "text",  hovertext = text, sort = FALSE, marker = list(colors = scales::brewer_pal(palette = palette, direction = 1)(5)))
fig2 <- fig2 |> add_pie(hole = 0.6)
fig2 <- fig2 |> layout(title = "Accessions",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
figs$accessions = fig2
duplication_items <<- duplication_items
duplication_accessions <<- duplication_accessions

duplication_items = duplication_items[c(2:5,1),]
duplication_accessions = duplication_accessions[c(2:5,1),]
# Together
p <- plot_ly() |>
  add_pie(data = duplication_items, labels = ~Duplication, values = ~Items, hole = 0.6,
          title = "Items", name ='', sort = FALSE, marker = list(
            colors =  scales::brewer_pal(palette = palette, direction = 1)(5)),
          domain = list(row = 0, column = 0)) |>
  add_pie(data = duplication_accessions, labels = ~Duplication, values = ~Accessions, hole = 0.6,
          title = "Accessions", name ='', sort = FALSE, marker = list(
            colors = scales::brewer_pal(palette = palette, direction = 1)(5)),
         domain = list(row = 0, column = 1))  |>
  layout(title = "", showlegend = TRUE,
          grid=list(rows=1, columns=2),
         plot_bgcolor="#f0f0f0",
         legend = list(orientation = 'h', xanchor = "center", x = 0.5),
         xaxis = list(title=paste0('Items', 'Accessions'), showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         margin = c(0,0,0,0))


if(separate_figure_folder){
  htmlwidgets::saveWidget(figs$items, file = paste0(figures_dir, '/','endemic_duplication_existing_items.html'))
  htmlwidgets::saveWidget(figs$accessions, file = paste0(figures_dir, '/','endemic_duplication_existing_accessions.html'))
}

p
  

# 
# text = paste0(duplication_items$Items, ' Endemic Taxa has ', duplication_items$Duplication, ' items')
# 
# fig <- plot_ly(duplication_items, labels = ~Duplication, values = ~Items, hoverinfo = "text",  hovertext = text, sort = FALSE)
# fig <- fig %>% add_pie(hole = 0.6)
# fig <- fig %>% layout(title = "",
#                       xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
#                       yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
# 
# fig
# 
# if(separate_figure_folder){
#   htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Pie-duplication_endemic_items.html'))
# }
# 

```

`r if(report_kind == 'interactive' & do_over_time){"###### Table"}`
```{r Duplication of existing endemic items in the LC - table, , eval = report_kind == 'interactive'}
DT::datatable(flex_data, rownames = FALSE,
                # caption = paste0('Native plants in the LC (',paste0(location_name, collapse = ', '),')'),
                options = list(dom = 't'))
```

`r if(report_kind == 'interactive'){"##### {-}"}`

Next we look at how duplication has changed over time. 

```{r, duplication of endemic species over time}
over_time_info = lapply(endemic_existing_each_year, function(x){
  garden_current = endemic[x,]

  endemic_items_per_taxa = table(paste0(garden_current$POWO_taxon_name, ' ', garden_current$POWO_taxon_authors))
endemic_items_per_taxa_table = table(as.numeric(endemic_items_per_taxa))

endemic_items_per_taxa_simp = as.numeric(endemic_items_per_taxa)
endemic_items_per_taxa_simp[endemic_items_per_taxa_simp >= 5] = '>4'
endemic_items_per_taxa_table_simp = table(endemic_items_per_taxa_simp)
formatted = endemic_items_per_taxa_table_simp[match( c('1', '2', '3','4', '>4'), names(endemic_items_per_taxa_table_simp))]
formatted = as.numeric(formatted) ; formatted[is.na(formatted)] = 0

return(formatted)
}) |>
  data.frame() |>
  t() |>
  data.frame()
over_time_info = data.frame(Date = years, over_time_info)
names(over_time_info) = c('year','1', '2', '3', '4', '>4')
row.names(over_time_info) = 1:nrow(over_time_info)
duplication_items_over_time = over_time_info


over_time_info = lapply(endemic_existing_each_year, function(x){
  garden_current = endemic[x,]

endemic_accessions = garden_current[match(unique(garden_current$AccNoFull), garden_current$AccNoFull),]
endemic_accessions_per_taxa = table(paste0(endemic_accessions$POWO_taxon_name, ' ', endemic_accessions$POWO_taxon_authors))
endemic_accessions_per_taxa_table = table(as.numeric(endemic_accessions_per_taxa))

endemic_accessions_per_taxa_simp = as.numeric(endemic_accessions_per_taxa)
endemic_accessions_per_taxa_simp[endemic_accessions_per_taxa_simp >= 5] = '>4'
endemic_accessions_per_taxa_table_simp = table(endemic_accessions_per_taxa_simp)
formatted = endemic_accessions_per_taxa_table_simp[match( c('1', '2', '3','4', '>4'), names(endemic_accessions_per_taxa_table_simp))]
formatted = as.numeric(formatted) ; formatted[is.na(formatted)] = 0

return(formatted)

}) |>
  data.frame() |>
  t() |>
  data.frame()
over_time_info = data.frame(Date = years, over_time_info)
names(over_time_info) = c('year','1', '2', '3', '4', '>4')
row.names(over_time_info) = 1:nrow(over_time_info)
duplication_accessions_over_time = over_time_info


```

`r if(report_kind == 'interactive'& do_over_time){"#####  Duplication of endemic species over time {.tabset}"}`

`r if(report_kind == 'interactive'& do_over_time){"###### Items"}`
```{r  duplication of endemic items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'& do_over_time}
prop_data = duplication_items_over_time
prop_data[,-1] = prop_data[,-1]/rowSums(prop_data[,-1])*100

dd = reshape(prop_data, idvar = "year", varying = list(2:ncol(prop_data)),
                   v.names = "count", timevar = "group", times = names(prop_data)[-1], direction = "long")
dd$group = factor(dd$group, levels = c('1', '2', '3', '4', '>4'))
prop_data = dd
text = paste0(round(prop_data$count,digits=2), '%')
prop_data$text = text
fig <- plot_ly(prop_data, x = ~year, y = ~count, color = ~group, type = 'bar', customdata = ~text,
               hovertemplate = '%{customdata}',  colors = scales::brewer_pal(palette = palette, direction = 1)(5))
fig <- fig |> layout(yaxis = list(title = 'Percentage'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text='')),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)

fig

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_Bar-endemic_duplication_over_time_by_item.html'))
}
```

`r if(report_kind == 'interactive'& do_over_time){"###### Accessions"}`
```{r  duplication of endemic accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'& do_over_time}
prop_data = duplication_accessions_over_time
prop_data[,-1] = prop_data[,-1]/rowSums(prop_data[,-1])*100

dd = reshape(prop_data, idvar = "year", varying = list(2:ncol(prop_data)),
                   v.names = "count", timevar = "group", times = names(prop_data)[-1], direction = "long")
dd$group = factor(dd$group, levels = c('1', '2', '3', '4', '>4'))
prop_data = dd
text = paste0(round(prop_data$count,digits=2), '%')
prop_data$text = text
fig <- plot_ly(prop_data, x = ~year, y = ~count, color = ~group, type = 'bar', customdata = ~text,
               hovertemplate = '%{customdata}',  colors = scales::brewer_pal(palette = palette, direction = 1)(5))
fig <- fig |> layout(yaxis = list(title = 'Percentage'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text='')),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)

fig

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_Bar-endemic_duplication_over_time_by_accessions.html'))
}
```
`r if(report_kind == 'interactive'& do_over_time){"##### {-}"}`


***

### Rarity of endemic species 

```{r, rarity of endemic species}
### How many items/accessions for each endemic taxa in the LC.
endemic_wanted_info = endemic_existing[c("best_name", "no_gardens")]

endemic_wanted_info <- endemic_wanted_info |> 
        dplyr::group_by(best_name) |> 
        dplyr::summarise(global = no_gardens[1], 
                         count = length(no_gardens)) |>
  dplyr::ungroup() 

not_found = sum(is.na(endemic_wanted_info$global))
endemic_wanted_info$global[is.na(endemic_wanted_info$global)] = 0

rarity_plot_info <- endemic_wanted_info |> 
        dplyr::group_by(global) |> 
        dplyr::summarise(global = global[1], 
                         count = length(best_name)) |>
  dplyr::ungroup() 

unique_ = sum(rarity_plot_info$count[rarity_plot_info$global %in% 0:1])  
v_rare = sum(rarity_plot_info$count[rarity_plot_info$global %in% 2:10])  
rare = sum(rarity_plot_info$count[rarity_plot_info$global %in% 11:50]) 
common = sum(rarity_plot_info$count[rarity_plot_info$global %in% 51:100]) 
v_common = sum(rarity_plot_info$count[rarity_plot_info$global %in% 100:1500]) 

doughnut_data = data.frame(rarity = c('Unique','Very Rare', 'Rare', 'Common', 'Very Common'),
                        no_items = c(unique_,v_rare, rare, common, v_common),
                        color = scales::brewer_pal(palette = palette, direction = 1)(5) |> rev())
doughnut_data$percent = paste0(round(doughnut_data$no_items / sum(doughnut_data$no_items)*100,digits = 1),'%')


# data formatted if we want to export/save it.
globally_held_taxa_grouped = doughnut_data[,c(1,2,4,3)]
names(globally_held_taxa_grouped) = c("Rarity in global LCs",   "Number of Taxa in LC", "Percentage",  "Colour" )
```

In this section, we explore the rarity of existing endemic species in the living collection on the global scale. To do this we used BGCI's PlantSearch to extract the number of global collections plants are held within.

We group taxa by the number of collections they are found in globally. These are:

- **Unique**: found in 0 or 1 collection.
- **Very Rare**: found in 10 or less collections.
- **Rare**: found in between 11 and 50 collections.
- **Common**: found in between 51 and 100 collections.
- **Very Common**: found in more than 100 collections.

`r if(report_kind == 'interactive'){"#####  Rarity of endemic species {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Summary"}`
```{r, grouped rarity - interactive figure, fig.dim = c(10, 4), eval = report_kind == 'interactive'}
text = paste0(doughnut_data$no_items, ' records classed as ', doughnut_data$rarity )
doughnut_data$rarity = factor(doughnut_data$rarity, levels = doughnut_data$rarity)

fig <- plot_ly(doughnut_data, labels = ~rarity, values = ~no_items, hoverinfo = "text",  hovertext = text, marker = list(colors = ~color),  sort = FALSE )
fig <- fig %>% add_pie(hole = 0.6)
fig <- fig %>% layout(title = "",  showlegend = T,
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Pie-grouped_global_rarity.html'))
}

fig

```

`r if(report_kind == 'interactive'& do_over_time){"###### Detailed"}`
```{r, taxa in collection against how many sites globally - interactive figure, fig.dim = c(10, 4), eval = report_kind == 'interactive'}
data_plot = rarity_plot_info
text = paste0(data_plot$count, ' endemic species in the garden are found in ', data_plot$global, ' collections globally.')
colo_rare = rev(scales::brewer_pal(palette = palette, direction = 1)(5))

fig <- plot_ly(data_plot, x = ~global, y = ~count, 
         type = 'scatter',  mode = 'markers', hoverinfo = "text",  hovertext = text, colors = 'black', color = 'color')
fig <- fig |> layout(title = "",
  xaxis = list(title = "Number of living collections <br> holding the taxa worldwide"),
  yaxis = list (title = "Number of endemic taxa <br> found in the collection")) 
fig <- layout(fig,
             shapes = list(
                list(type = "rect",
                    fillcolor = colo_rare[1], line = list(color = colo_rare[1]), opacity = 0.3,
                    x0 = 0, x1 = 1.5, xref = "x",
                    y0 = 0, y1 = max(data_plot$count), yref = "y"),
               list(type = "rect",
                    fillcolor = colo_rare[2], line = list(color = colo_rare[2]), opacity = 0.3,
                    x0 = 1.5, x1 = 10.5, xref = "x",
                    y0 = 0, y1 = max(data_plot$count), yref = "y"),
                list(type = "rect",
                    fillcolor = colo_rare[3], line = list(color = colo_rare[3]), opacity = 0.3,
                    x0 = 10.5, x1 = 50.5, xref = "x",
                    y0 = 0, y1 = max(data_plot$count), yref = "y"),
               list(type = "rect",
                    fillcolor = colo_rare[4], line = list(color = colo_rare[4]), opacity = 0.3,
                    x0 = 50.5, x1 = 100.5, xref = "x",
                    y0 = 0, y1 = max(data_plot$count), yref = "y"),
                list(type = "rect",
                    fillcolor = colo_rare[5], line = list(color = colo_rare[5]), opacity = 0.3,
                    x0 = 100.5, x1 = max(data_plot$global), xref = "x",
                    y0 = 0, y1 = max(data_plot$count), yref = "y")               
              ))

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','grown_in_LC_against_global.html'))
}

fig

```

`r if(report_kind == 'interactive'& do_over_time){"##### {-}"}`



***

### Provenance of endemic species
  
In this section we are exploring the provenance of native plants in the collection. Each accession in the garden has one of the following provenance types:

- Wild: plants that were collected directly from the wild,
- Wild-derived: cultivated plants descended from plants of known wild origin,
- Garden: cultivated plants descended from plants not of known wild origin,
- Unknown: plants with unknown origin.

Below we produce a chart and table of provenance for items and accessions.

```{r, Provenance of endemic plants in the LC,  results='hide',fig.keep='all', message=FALSE}
# LC_native_exisiting the data of existing endemic plants in the LC. 
wanted_order = c('Wild', 'Wild-derived', 'Garden', 'Unknown')
prov_items = data.frame(table(endemic_existing$ProvenanceCode))
rows = match(wanted_order, prov_items[,1])
other = which(!prov_items[,1] %in% wanted_order)
o = c(rows,other)
o = o[!is.na(o)]
prov_items = prov_items[o,]
names(prov_items) = c('Provenance', 'Items')
# prov_items$Provenance  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(prov_items$Provenance, c('G', 'U', 'W', 'Z'))]  
prov_items$percent = paste0(round(prov_items$Items / sum(prov_items$Items)*100,digits = 1),'%')
prov_items <- prov_items %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Items))), 
                pos = Items/2 + dplyr::lead(csum, 1),
                pos = dplyr::if_else(is.na(pos), Items/2, pos))


prov_accessions = data.frame(table(endemic_existing$ProvenanceCode[match(unique(endemic_existing$AccNoFull), endemic_existing$AccNoFull)]))
rows = match(wanted_order, prov_accessions[,1])
other = which(!prov_accessions[,1] %in% wanted_order)
o = c(rows,other)
o = o[!is.na(o)]
prov_accessions = prov_accessions[o,]
names(prov_accessions) = c('Provenance', 'Accessions')
# prov_accessions$Provenance  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(prov_accessions$Provenance, c('G', 'U', 'W', 'Z'))]
prov_accessions$percent = paste0(round(prov_accessions$Accessions / sum(prov_accessions$Accessions)*100,digits = 1),'%')
prov_accessions <- prov_accessions %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Accessions))), 
                pos = Accessions/2 + dplyr::lead(csum, 1),
                pos = dplyr::if_else(is.na(pos), Accessions/2, pos))

flex_data = data.frame(prov_items$Provenance,
                       prov_items$Items, 
                       paste0(round(prov_items$Items/sum(prov_items$Items)*100,digits=2),'%'),
                       prov_accessions$Accessions,
                       paste0(round(prov_accessions$Accessions/sum(prov_accessions$Accessions)*100,digits=2),'%'))
names(flex_data) = c('Provenance', 'Number of items', 'Proportion of items', 'Number of accessions', 'Proportion of accessions')

if(export_data){
  exporting_data_store$Provenance_of_existing_endemic_plants_in_the_LC = flex_data
}

### Create provenance by taxa to see if any have multiple provenance codes. 
taxa_prov_og = endemic_existing |>
  dplyr::group_by(best_name) |>
  summarise(wild_items = sum(.data$ProvenanceCode == 'Wild'),
            z_items = sum(.data$ProvenanceCode == "Wild-derived"),
            garden_items = sum(.data$ProvenanceCode == 'Garden'),
            unknown_items = sum(.data$ProvenanceCode == 'Unknown'),
            original_name = toString(.data$TaxonNameFull |> unique())
            )

taxa_prov = taxa_prov_og[,c(1:5)] |> as.data.frame()
for(i in 2:5){taxa_prov[,i] = taxa_prov[,i] |> as.numeric()}

wild_taxa = taxa_prov$best_name[taxa_prov$wild_items > 0]
z_taxa = taxa_prov$best_name[taxa_prov$z_items > 0]
g_taxa = taxa_prov$best_name[taxa_prov$garden_items > 0]
u_taxa = taxa_prov$best_name[taxa_prov$unknown_items > 0]
x = list() ; category.names = NULL ; colours = NULL
if(length(wild_taxa) > 0 ){x$w = wild_taxa ; category.names = c(category.names, "Wild") ; colours = c(colours, interactive_colour(4)[c(1)])}
if(length(u_taxa) > 0 ){x$u = u_taxa ; category.names = c(category.names, "Unknown") ; colours = c(colours, interactive_colour(4)[c(4)])}
if(length(z_taxa) > 0 ){x$z = z_taxa ; category.names = c(category.names, "Wild-derived"); colours = c(colours, interactive_colour(4)[c(2)])}
if(length(g_taxa) > 0 ){x$g = g_taxa ; category.names = c(category.names, "Garden"); colours = c(colours, interactive_colour(4)[c(3)])}
library(VennDiagram)
venn_diag = venn.diagram(x, filename = NULL,
                         category.names = category.names,
                         fill =colours,
                         disable.logging = TRUE,
                         main.fontfamily = "arial",
                         main.fontface = "sans")


# Make a data.frame of the overlapping taxa for a download.
taxa_prov_og$no_val =  lapply(taxa_prov_og[,-6] |> as.data.frame() |> t() |> as.data.frame(),function(x){
  sum(as.numeric(x[-1]) != 0)
}) |> unlist()

taxa_prov = taxa_prov_og[taxa_prov_og$no_val > 1,]
taxa_prov = taxa_prov[,-7]
taxa_prov =taxa_prov[,c(1,6,2,3,4,5)]
names(taxa_prov) = c("Best name found by BGSmartR",
                     "Original Taxonomic name/s",
                     "Number of Wild Origin Items",
                     "Number of Wild-derived Origin Items",
                     "Number of Garden Origin Items",
                     "Number of Unknown Origin Items")


### (END) Create provenance by taxa to see if any have multiple provenance codes. 
```

```{r Provenance of endemic plants in the LC - Table}
if(report_kind == 'static'){
  flex_data |>
    flextable() |>
    set_caption(caption = paste0('Provenance of existing endemic plants in the LC')) |> 
    font(fontname = "Calibri (Body)", part = "all") |> 
    fontsize(size = table_font_size, part = "body") |> 
    # add footer if you want
    # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
    #                colwidths = 4) |> 
    theme_booktabs() |> # default theme
    separate_header() |> 
    align(align = "center", part = "all") |>
    autofit()
}
# if(report_kind == 'interactive'){
#  DT::datatable(flex_data, rownames = FALSE,
#                 # caption = paste0('Provenance of existing endemic plants in the LC'),
#                 options = list(dom = 't'))
# }

```


```{r, Provenance of endemic plants in the LC pie charts, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'static'}
# Basic piechart
pie1 = ggplot(prov_items, aes(x="", y=Items, fill=Provenance)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtheme(base_size = 18) +
  ggtitle('Items') +
  scale_fill_discrete() +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

pie2 = ggplot(prov_accessions, aes(x="", y=Accessions, fill=Provenance)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtitle('Accessions') + 
  scale_fill_discrete() +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

if(value_on_fig){
  pie1 = pie1 + geom_label_repel(aes(y = pos,label = percent),
                                 size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white")   
  
  pie2 = pie2 + geom_label_repel(aes(y = pos,label = percent),
                                 size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white") 
}

p = ggpubr::ggarrange(pie1, pie2, ncol=2, nrow=1, common.legend = TRUE, legend="bottom")

if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Provenance_of_endemic_plants.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}


p

```

`r if(report_kind == 'interactive'){"#####  Provenance of endemic species {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Chart"}`
```{r  Provenance of existing endemic items in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
figs = list()
colo = interactive_colour(4)
colo = colo[match(unique(prov_items$Provenance), wanted_order)]
# Items
text = paste0(prov_items$Items, ' ',prov_items$Provenance,' origin endemic items')
fig1 <- plot_ly(prov_items, labels = ~Provenance, values = ~Items, hoverinfo = "text",  hovertext = text, sort = FALSE, marker = list(colors = colo))
fig1 <- fig1 |> add_pie(hole = 0.6)
fig1 <- fig1 |> layout(title = "Items",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
figs$items = fig1
#Accessions
text = paste0(prov_accessions$Accessions, ' ',prov_accessions$Provenance,' origin endemic items')
fig2 <- plot_ly(prov_accessions, labels = ~Provenance, values = ~Accessions, hoverinfo = "text",  hovertext = text, sort = FALSE, marker = list(colors = colo))
fig2 <- fig2 |> add_pie(hole = 0.6)
fig2 <- fig2 |> layout(title = "Accessions",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
figs$accessions = fig2

# Together
p <- plot_ly() |>
  add_pie(data = prov_items, labels = ~Provenance, values = ~Items, hole = 0.6,
          title = "Items", name ='', sort = FALSE, marker = list(colors = colo),
          domain = list(row = 0, column = 0)) |>
  add_pie(data = prov_accessions, labels = ~Provenance, values = ~Accessions, hole = 0.6,
          title = "Accessions", name ='', sort = FALSE, marker = list(colors = colo),
         domain = list(row = 0, column = 1))  |>
  layout(title = "", showlegend = TRUE,
          grid=list(rows=1, columns=2),
         plot_bgcolor="#f0f0f0",
         legend = list(orientation = 'h', xanchor = "center", x = 0.5),
         xaxis = list(title=paste0('Items', 'Accessions'), showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         margin = c(0,0,0,0))


if(separate_figure_folder){
  htmlwidgets::saveWidget(figs$items, file = paste0(figures_dir, '/','endemic_provenance_existing_items.html'))
  htmlwidgets::saveWidget(figs$accessions, file = paste0(figures_dir, '/','endemic_provenance_existing_accessions.html'))
}

p
  
```

`r if(report_kind == 'interactive' & do_over_time){"###### Table"}`
```{r Provenance of existing endemic items in the LC - table, eval = report_kind == 'interactive'}
flex_data |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = nrow(flex_data),
                                 dom = 'Bt',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=FALSE,
                                 ordering=F))
```

`r if(report_kind == 'interactive'& do_over_time){"##### {-}"}`

`r if(do_over_time){"We will now look at how the provenance of endemic plants in the living collection has changed over time."}`

`r if(!do_over_time){"We do not have the information to explore how provenance of endemic plants in the living collection has changed over time."}`

```{r, Provenance of endemic plants in the LC- change over time data, eval = do_over_time}
# For each year get the number in each group (species and genera)
over_time_info = lapply(endemic_existing_each_year, function(x){
  garden_current = endemic[x,]

  prov_items =  data.frame(table(garden_current$ProvenanceCode))
  if(nrow(prov_items) == 0){
    return(list(prov_items = prov_items,
                prov_accessions = prov_items))
  }
  names(prov_items) = c('Provenance', 'Items')

  prov_accessions = data.frame(table(garden_current$ProvenanceCode[match(unique(garden_current$AccNoFull), garden_current$AccNoFull)]))
  names(prov_accessions) = c('Provenance', 'Accessions')

  return(list(prov_items = prov_items,
              prov_accessions = prov_accessions))
})
prov_endemic_over_time = over_time_info

```

```{r, Provenance of endemic plants in the LC- change over time figures, fig.fullwidth=FALSE, fig.dim = c(10, 6), , eval = report_kind == 'static' & do_over_time}
to_do = c('items', 'accessions')
for(i in 1:length(to_do)){
  # Get the data from over_time_info.
  data_wanted = NULL
  wanted_item = which(grepl('prov',names(prov_endemic_over_time[[1]])) & grepl(to_do[i],names(prov_endemic_over_time[[1]])) )
  for(jj in 1:length(prov_endemic_over_time)){
    info_year = prov_endemic_over_time[[jj]][[wanted_item]]
    if(nrow(info_year) == 0){
      next
    }
    prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
    info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)),
                           info_year = info_year,
                           prop = prop)
    data_wanted = rbind(data_wanted, info_year)
    
  }
  names(data_wanted) = c('year', 'Provenance', 'Items', 'prop')
  data_wanted[,2] = as.character(data_wanted[,2])
  # data_wanted[,2]  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(data_wanted[,2], c('G', 'U', 'W', 'Z') )]
  data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))
  
  
  if(export_data){
    item_name = paste0('Provenance_of_endemic_plants_in_the_LC_proportion_over_time_',to_do[i])
    exporting_data_store$AA = data_wanted
    names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
  }
  
  p = ggplot(data_wanted, aes(fill=Provenance, y=prop, x=year)) + 
    geom_bar(position="stack", stat="identity", width = 1) +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title=paste0("Provenance of ", to_do[i] , " that are endemic in the LC over time"),
         x ="Year",
         y = "Percentage (%)") +
    guides(fill=guide_legend(title=paste0('Provenance')))# +
  # theme(text = element_text(size=table_font_size))
  
  if(separate_figure_folder){
    ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Provenance_of_endemic_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
  }
  print(p)
  
}
```

`r if(report_kind == 'interactive'& do_over_time){"##### {.tabset}"}`

`r if(report_kind == 'interactive'& do_over_time){"###### Items"}`
```{r  Provenance of endemic items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'& do_over_time}
wanted_order = c('Wild', 'Wild-derived', 'Garden', 'Unknown')
to_do = c('items', 'accessions')
i=1

# Get the data from over_time_info.
data_wanted = NULL
wanted_item = which(grepl('prov',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
for(jj in 1:length(over_time_info)){
  info_year = over_time_info[[jj]][[wanted_item]]
  if(nrow(info_year) == 0){
    next
  }
  rows = match(wanted_order, info_year[,1])
  other = which(!info_year[,1] %in% wanted_order)
  o = c(rows,other)
  o = o[!is.na(o)]
  info_year = info_year[o,]
  prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
  info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)),
                         info_year = info_year,
                         prop = prop)
  data_wanted = rbind(data_wanted, info_year)
  
}
names(data_wanted) = c('year', 'Provenance', 'Items', 'prop')
data_wanted[,2] = as.character(data_wanted[,2])
# data_wanted[,2]  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(data_wanted[,2], c('G', 'U', 'W', 'Z') )]
data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))


if(export_data){
  item_name = paste0('Provenance_of_endemic_plants_in_the_LC_proportion_over_time_',to_do[i])
  exporting_data_store$AA = data_wanted
  names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
}


text = paste0(round(data_wanted$prop,digits=2), '% (',data_wanted$Items,' items) ')
data_wanted$text = text
data_wanted$Provenance = factor(data_wanted$Provenance, levels= unique(data_wanted$Provenance))

colo = interactive_colour(4)
colo = colo[match(levels(data_wanted$Provenance), wanted_order)]

fig <- plot_ly(data_wanted, x = ~year, y = ~prop, color = ~Provenance, type = 'bar', text = ~text,
               hovertemplate = '%{text}',  colors = colo,
               sort = FALSE)
fig <- fig |> layout(yaxis = list(title = 'Percentage'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text='')),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)

fig

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_Bar-endemic_provenance_over_time_by_item.html'))
}
```

`r if(report_kind == 'interactive'& do_over_time){"###### Accessions"}`
```{r  Provenance of endemic accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'& do_over_time}
wanted_order = c('Wild', 'Wild-derived', 'Garden', 'Unknown')
to_do = c('items', 'accessions')
i=2

# Get the data from over_time_info.
data_wanted = NULL
wanted_item = which(grepl('prov',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
for(jj in 1:length(over_time_info)){
  info_year = over_time_info[[jj]][[wanted_item]]
  if(nrow(info_year) == 0){
    next
  }
  rows = match(wanted_order, info_year[,1])
  other = which(!info_year[,1] %in% wanted_order)
  o = c(rows,other)
  o = o[!is.na(o)]
  info_year = info_year[o,]
  prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
  info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)),
                         info_year = info_year,
                         prop = prop)
  data_wanted = rbind(data_wanted, info_year)
  
}
names(data_wanted) = c('year', 'Provenance', 'Items', 'prop')
data_wanted[,2] = as.character(data_wanted[,2])
# data_wanted[,2]  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(data_wanted[,2], c('G', 'U', 'W', 'Z') )]
data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))


if(export_data){
  item_name = paste0('Provenance_of_endemic_plants_in_the_LC_proportion_over_time_',to_do[i])
  exporting_data_store$AA = data_wanted
  names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
}


text = paste0(round(data_wanted$prop,digits=2), '% (',data_wanted$Items,' accessions) ')
data_wanted$text = text
data_wanted$Provenance = factor(data_wanted$Provenance, levels= unique(data_wanted$Provenance))

colo = interactive_colour(4)
colo = colo[match(levels(data_wanted$Provenance), wanted_order)]

fig <- plot_ly(data_wanted, x = ~year, y = ~prop, color = ~Provenance, type = 'bar', text = ~text,
               hovertemplate = '%{text}', colors = colo,
               sort = FALSE)
fig <- fig |> layout(yaxis = list(title = 'Percentage'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text='')),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)
fig

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_Bar-endemic_provenance_over_time_by_accession.html'))
}
```

`r if(report_kind == 'interactive'& do_over_time){"##### {-}"}`

In the above analysis we have considered endemic items and accessions where provenance is unique (i.e each accession can only be in one provenance group). Next we look at provenance across taxa. In this case a taxa can be contained in the garden by multiple provenance codes (i.e. one accession of wild origin and one accession of garden origin). To visualise the provenance by taxa we use a Venn diagram visualise how taxa can be expressed by multiple provenances. 

```{r, draw provenace by taxa (venn), results='hide',fig.keep='all', message=FALSE, fig.dim=c(4,4), fig.align = 'center', eval = report_kind == 'interactive' }
grid.newpage()
grid.draw(venn_diag)
```


:::: {.blackbox data-latex=""}

Taxa with multiple provenance types can be downloaded below

```{r}
taxa_prov |>
  download_this(
    output_name = "Taxa with multiple provenances",
    output_extension = ".xlsx",
    button_label = "Download taxa with multiple provenances (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained =  T
  )
```
::::

***
  
### Turnover analysis
  
This section looks at the turnover (gain/loss) of accessions of endemic plants in the living collection.

`r if(!do_over_time){"As we do not have information to explore the data over time we cannot perform turnover analysis."}`

`r if(do_over_time){"We can also view the gain/loss of endemic accessions as a proportion of all gained/lost endemic each year. This will show if the incoming proportion of endemic plants was more or less than the proportion of endemic plants in the collection."}`


```{r, Endemic Turnover - Accessions, eval = do_over_time}
# Start from the original_report
max_year = as.numeric(format(Sys.Date(),'%Y'))
years = min_year:max_year
report = report_original
report = report[report$AccYear > 1650 & report$AccYear<=max_year,]
report = report[!is.na(report$ItemStatusDate),]

## Convert report into accessions
unique_accessions = unique(report$AccNoFull)
LossYear = rep(NA,nrow(report))
ItemStatusYear = as.numeric(stringr::str_extract(report$ItemStatusDate,pattern = '[0-9]{4}'))
LossYear[report$ItemStatusType %in% c('NotExisting', 'Not Existing')] = ItemStatusYear[report$ItemStatusType %in% c('NotExisting', 'Not Existing')]
report$LossYear = LossYear
# Order the items where the lower indices have the most recent death date.
LossYear_dummy = LossYear
LossYear_dummy[is.na(LossYear_dummy)] = 4000
ordered_items = order(LossYear_dummy,decreasing = T)
report = report[ordered_items, ]
# Match to the ordered accessions.
match_to_best = match(unique_accessions,report$AccNoFull)
#Reduce the data to unique accessions with most recent death date.
report = report[match_to_best,]


#Get the number of accessions existing each year for whole collection/
existing_each_year_LC = as.numeric(colSums(BGSmartR::exist_at_date(date = paste0(years,'-12-31'),
                                                                   AccessionYear = as.character(report$AccYear),
                                                                   ItemStatusDate = as.character(report$ItemStatusDate),
                                                                   ItemStatusType = as.character(report$ItemStatusType),
                                                                   post_date = '3000-01-01')))
## Get the turnover for the whole collection.
overall_turnover = turnover_items(report)
exporting_data_store$overall_turnover = overall_turnover

## Get the trends for endemic accessions.
date = paste0(years, '-12-31')
plant_existing = BGSmartR::exist_at_date(date, AccessionYear = report$AccYear,
                                         ItemStatusDate = report$ItemStatusDate,
                                         ItemStatusType = report$ItemStatusType,
                                         post_date = '3000-01-01')
names(plant_existing) = date
trends = pbapply::pblapply(plant_existing, function(x){
  garden_current = report[x,]
  
  accessions = nrow(garden_current)
  
  breakdown_endemic = table(garden_current$endemic)
  
  return(list(accessions = accessions, breakdown_endemic = breakdown_endemic))
})
names(trends) = names(plant_existing)
trend = as.numeric(unlist(lapply(trends,function(x){
  sum(x$breakdown_endemic[grepl('End', names(x$breakdown_endemic))])
})))


do_type = TRUE
report_cur = report[which(report$endemic == 'Endemic'),]
if(nrow(report_cur) == 0){
  do_type = FALSE
}else{
  
  
  turnover = turnover_items(report_cur)
  exporting_data_store$turnover_native = turnover
  
  plots = plots_turnover(turnover, trend = trend, report_kind = report_kind, separate_figure_folder = separate_figure_folder, text = 'endemic', data_type = 'Accessions')
  
  existing_each_year = as.numeric(colSums(BGSmartR::exist_at_date(date = paste0(years,'-12-31'),
                                                                  AccessionYear = report_cur$AccYear,
                                                                  ItemStatusDate = report_cur$ItemStatusDate,
                                                                  ItemStatusType = report_cur$ItemStatusType,
                                                                  post_date = '3000-01-01')))
  collection_proportion = existing_each_year/ existing_each_year_LC
  
  plots_proportional = proportional_plots_turnover(turnover = turnover,
                                                   overall_turnover = overall_turnover,
                                                   collection_proportion = collection_proportion,
                                                   report_kind = report_kind,
                                                   separate_figure_folder = separate_figure_folder,
                                                   text = 'endemic',
                                                   data_type = 'Accessions')
  exporting_data_store$proportional_turnover_native_gain = plots_proportional$data_gain
  exporting_data_store$proportional_turnover_native_loss = plots_proportional$data_loss
}
```


`r if(!do_type){"There are no records that are endemic."}`

```{r, Turnover of endemic items - static, eval = report_kind == 'static'& do_type & FALSE, fig.fullwidth=TRUE, fig.dim = c(10, 6)}
# plots$gain_loss
# 
# plots$net
# 
# plots_accessions$gain_loss
# 
# plots_accessions$net


```

`r if(report_kind == 'interactive' & do_type){"#####  Turnover of endemic {.tabset}"}`

`r if(report_kind == 'interactive' & do_type){"###### Net"}`
```{r  Gain/Loss of endemic items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_type}
plots$trend_and_net
```

`r if(report_kind == 'interactive' & do_type){"###### Gain/Loss"}`
```{r  Net turnover of endemic items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_type}
plots$gain_loss
```

`r if(report_kind == 'interactive' & do_type){"##### {-}"}`

`r if(!do_type){"We now explore how the gain and loss of endemic species compare proportionally to the total number of gained and lost items/accessions and the overall proportion of endemic species each year. To calculate the proportion of the collection that are endemic each year we only consider records that have an accession year and item status date and extract which items/accessions were existing on the first of January each year."}`

```{r, Proportional Turnover of endemic - static, eval = report_kind == 'static'& do_type, fig.fullwidth=TRUE, fig.dim = c(10, 6),}
# plots_proportional$gain
# 
# plots_proportional$loss
# 
# plots_proportional_accessions$gain
# 
# plots_proportional_accessions$loss

```

`r if(report_kind == 'interactive' & do_type){"#####  Proportional turnover of endemic {.tabset}"}`

`r if(report_kind == 'interactive' & do_type){"###### Gain"}`
```{r  Proportional Gain of endemic items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_type}
plots_proportional$gain
```

`r if(report_kind == 'interactive' & do_type){"###### Loss"}`
```{r  Proportional Loss of endemic items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_type}
plots_proportional$loss
```

`r if(report_kind == 'interactive' & do_type){"##### {-}"}`

***

### Survival analysis

```{r, survival analysis, echo = FALSE}
# Remove those without accession year.
do_survival = TRUE
if(!do_over_time){
  do_survival = FALSE
}

if(!is.null(old_accession_year_codes)){
  has_old_accessions_code = which(enriched_report$AccYear %in% old_accession_year_codes)
  no_old_accessions = length(has_old_accessions_code)
  enriched_report$AccYear[has_old_accessions_code] = earliest_allowable_record
}

enriched_report_wanted = enriched_report[as.numeric(enriched_report$AccYear) > 1650 & as.numeric(enriched_report$AccYear) < as.numeric(format(Sys.Date(),'%Y')),]
enriched_report_wanted = enriched_report_wanted[!is.na(enriched_report_wanted$ItemStatusDate),]
enriched_report_wanted = enriched_report_wanted[!is.na(enriched_report_wanted$AccYear),]

# Create a data-frame of the information we want.
wanted_data = data.frame(enriched_report_wanted$TaxonNameFull, enriched_report_wanted$AccYear, enriched_report_wanted$ItemStatusDate, enriched_report_wanted$ItemStatusType)
names(wanted_data) = c('TaxonNameFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType')


if(nrow(wanted_data) == 0){
  do_survival = FALSE
}
if(do_survival){
  #Set accession date (just chose the first of June)
pre_date = rep(NA, length(wanted_data$AccYear))
pre_date = paste(wanted_data$AccYear, "06", "01", sep = "-")

# Convert ItemStatusDate into all dates (i.e if month or day missing add one)
post_date = rep(as.character(Sys.Date()), length(wanted_data$AccYear))
post_date[which(wanted_data$ItemStatusType == "NotExisting")] = as.character(wanted_data$ItemStatusDate[which(wanted_data$ItemStatusType == 
  "NotExisting")])

post_date[which(stringr::str_length(post_date) == 4)] = paste(post_date[which(stringr::str_length(post_date) == 
  4)], "12", "28", sep = "-")
post_date[which(stringr::str_length(post_date) == 7)] = paste(post_date[which(stringr::str_length(post_date) == 
  7)], "28", sep = "-")

# Create the time difference between accession and ItemStatusDate.
time = as.numeric(as.Date(post_date) - as.Date(pre_date)) /365.25

# Create status to tell whether the last item status date was item death or just a check.
status = rep(0,length(wanted_data$AccYear))
status[wanted_data$ItemStatusType == 'NotExisting'] = 1

wanted_data = data.frame(wanted_data, AccessionDate = pre_date,
                         StatusDate = post_date,
                         time = time,
                         Alive_dead = status)


# We haven't removed those with missing ItemStatusDate, these will most likely have negative time so remove these.
missing_itemstatusdate_index = which(wanted_data$time > 0)
status_year = wanted_data$ItemStatusDate |> stringr::str_extract('^[0-9]{4}') |> unlist() |> as.numeric()
status_before_current_year = which(status_year <= format(Sys.Date(),'%Y') |> as.numeric() )
to_keep = intersect(missing_itemstatusdate_index,status_before_current_year)
wanted_data = wanted_data[to_keep,]

enriched_report_wanted = enriched_report_wanted[to_keep,]


## 1) Native or non-native (or doesn't have geography info.)
#Get which records are native.
native_non_native = enriched_report_wanted$endemic

data_to_analyse = data.frame(wanted_data$TaxonNameFull,
                             wanted_data$time,
                             wanted_data$Alive_dead,
                             native_non_native)
names(data_to_analyse) = c("TaxonNameFull", "time", "Alive_dead", "endemic_status")

if(export_data){
  exporting_data_store$Data_for_survival = data_to_analyse
}
}

```

In this section, we look at whether the survival period of endemic plants are longer than widespread plants. Note that plants can be long-lived and most collections will have plants that are older than the collection itself. Therefore, we need to lean into tools from statistics to analyse the lifespan of plants in a collection. Herein, we use survival analysis to calculate the probability that plants will survive for any number of years. 

`r if(FALSE){"Note that \"lifespan\" may be a preferable way to describe this section, however we use survival because accessioned plants may arrive in the garden already a few years old. As we will be using the accession date and item status date to determine the length of time plants have been in the collection this might not align perfectly with the age of the plant. Moreover, it is important to be aware that the data used in the analysis is not \"perfect\" in the sense that plants might have already died a large period of time prior to an audit, moreover this analysis doesn't account for circumstances of plant death which could be natural, or for renovation of a section of the garden, etc. "}`

In the following analysis, we assume that existing items are still existing to the present day. Therefore, even if the last item status date was a year ago if the plant was found to be existing then we assume it is still existing now. (I could change this to just use alive at Item status date, it won't make much difference. )

Since we only have the accession year we set the accession date to be the middle of the year (1st June).
 
`r if(do_survival){"Below we show the survival probability (Kaplan-Meier plots) for endemic and non-endemic plants."}`

`r if(!do_survival){"Survival analysis cannot be performed. (This could be due to lack of accession year or item status date."}`

```{r, survival analysis - figure, echo  = FALSE, fig.fullwidth=TRUE, fig.dim = c(10, 6), results='hide',fig.keep='all', message=FALSE, eval = do_survival}
# Create Kaplan-Meier plots comparing endemic and not endemic
fit = ggsurvfit::survfit2(survival::Surv(time, Alive_dead) ~ endemic_status, data = data_to_analyse)
p = fit |> 
  ggsurvfit::ggsurvfit() +
  ggplot2::labs(
    x = "Years",
    y = "Overall survival probability"
  ) + 
  ggsurvfit::add_confidence_interval()+
    # theme(text = element_text(size=table_font_size))+
  # labs(title=paste0("Survival probability of native and non native plants in the LC")) +
  labs(caption = "Shaded region represents 95% confidence interval.") +
  scale_colour_manual(values = c('#f46d43', '#848484')) +
  scale_fill_manual(values = c('#f46d43', '#848484')) +
   theme(
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text=element_text(size=10))

if(report_kind == 'static'){
  if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','endemic_widespread_survival.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
  }
  p
} 
```

```{r survival_analysis - interactive figure, eval = do_survival,  fig.fullwidth=TRUE, fig.dim = c(10, 4)}
if(report_kind == 'interactive'){
  fig = ggplotly(p, dynamicTicks = TRUE)
  fig$x$layout$title$text =''
  fig$x$layout$legend$title$text = ''
  fig$x$layout$hovermode = 'x unified'
  fig$x$data[[2]]$name = 'Widespread'
  fig$x$data[[2]]$legendgroup = 'Widespread'
  fig$x$data[[1]]$name = 'Endemic'
  fig$x$data[[1]]$legendgroup = 'Endemic'
  fig$x$data[[4]]$hoverinfo = 'none'
  fig$x$data[[3]]$hoverinfo = 'none'
  
  time_region = round(fig$x$data[[4]]$text |>
    stringr::str_extract(pattern = 'time:[ ]+[0-9\\.]+') |>
    stringr::str_extract(pattern = '[0-9]+\\.[0-9]+') |>
    as.numeric(), digits = 3) 
  lower_region = round(fig$x$data[[4]]$text |>
    stringr::str_extract(pattern = 'conf.low: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100,digits = 2)
  upper_region = round(fig$x$data[[4]]$text |>
    stringr::str_extract(pattern = 'conf.high: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100, digits = 2)
  time = round(fig$x$data[[2]]$x,digits = 3)
  lower = lower_region[match(time, time_region)]
  upper = upper_region[match(time, time_region)]
  
  fig$x$data[[2]]$text = paste0(#'Age (years): ',round(fig$x$data[[2]]$x,digits = ), '<br>',
                                'Survival probability: ', round(fig$x$data[[2]]$y*100,digits = 2),'% <br>',
                                '95% confidence Interval: (', lower,'%, ', upper, '%)')
  
    time_region = round(fig$x$data[[3]]$text |>
    stringr::str_extract(pattern = 'time:[ ]+[0-9\\.]+') |>
    stringr::str_extract(pattern = '[0-9]+\\.[0-9]+') |>
    as.numeric(), digits = 3) 
  lower_region = round(fig$x$data[[3]]$text |>
    stringr::str_extract(pattern = 'conf.low: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100,digits = 2)
  upper_region = round(fig$x$data[[3]]$text |>
    stringr::str_extract(pattern = 'conf.high: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100, digits = 2)
  time = round(fig$x$data[[1]]$x,digits = 3)
  lower = lower_region[match(time, time_region)]
  upper = upper_region[match(time, time_region)]
  
  fig$x$data[[1]]$text = paste0('Age (years): ',round(fig$x$data[[1]]$x,digits = ), '<br>',
                                'Survival probability: ', round(fig$x$data[[1]]$y*100,digits = 2),'% <br>',
                                '95% confidence Interval: (', lower,'%, ', upper, '%)')
  
     #Set initial y-axis tick values 
  fig$x$layout$yaxis$ticktext = c("0.25", "0.50", "0.75", "1.00")
  fig$x$layout$yaxis$tickvals = c(0.25, 0.50, 0.75, 1.00)
  fig$x$layout$font$size = 10 # font size
  fig$x$layout$yaxis$title$font$size = 14
  fig$x$layout$xaxis$title$font$size = 14
  fig$x$layout$xaxis$title$font$color = NULL
   fig$x$layout$yaxis$title$font$color = NULL
  fig$x$layout$yaxis$tickfont$size = 12
  fig$x$layout$xaxis$tickfont$size = 12
  
  if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Endemic_survival_analysis.html'))
}

fig
}
```

`r if(do_survival){"Next we give the median surivival times for endemic and not endemic species in the collection."}`

```{r, survival analysis - median survival tables, echo = FALSE, message=FALSE, eval = do_survival}
# We can also get survival probabilities in a table
# 

table_data2 = fit |> 
  gtsummary::tbl_survfit(
    probs = c(0.5),
    label_header = "**Median survival (95% CI)**")

table_data2 = table_data2$table_body
table_data2 = table_data2[,-c(1:4)]
table_data2 = table_data2[-1,]
names(table_data2) = c('Characteristic', 'Median survival + 95% CI (Years)')

table_data2 |>  DT::datatable(extensions = 'Buttons',
                             rownames = FALSE,
                             options = list(scrollX = TRUE,
                                            pageLength = nrow(table_data2),
                                            dom = 'Bt',
                                            buttons = c('copy', 'csv', 'excel', 'pdf'),
                                            paging=FALSE,
                                            ordering=F))


```


`r if(do_survival){"Lastly, we give the survival probability for particular lengths of time."}`

```{r, survival analysis - tables, echo = FALSE, message=FALSE, eval = do_survival}
# We can also get survival probabilities in a table
# 
table_data = fit |> 
  gtsummary::tbl_survfit(
    times = c(2,5,10,25,50,100),
    label_header = "{time}-year survival (95% CI)")

table_data = table_data$table_body
  table_data = table_data[,-c(1:4)]
  table_data = table_data[-1,]
  names(table_data) = c('Status', '2-year survival (95% CI)',
                        '5-year survival (95% CI)',
                        '10-year survival (95% CI)',
                        '25-year survival (95% CI)',
                        '50-year survival (95% CI)',
                        '100-year survival (95% CI)')
  table_data = data.frame(t(table_data))
  table_data = table_data[-1,]
  names(table_data) = c('Endemic', 'Widespread')
  
  
  table_data2 = fit |> 
  gtsummary::tbl_survfit(
    probs = c(0.5),
    label_header = "**Median survival (95% CI)**")

table_data2 = table_data2$table_body
  table_data2 = table_data2[,-c(1:4)]
  table_data2 = table_data2[-1,]
  names(table_data2) = c('Characteristic', 'Median survival (95% CI)')
  
  
  
if(report_kind == 'static'){
  table_data |>
  flextable() |>
  set_caption(caption = paste0('Survival probability table')) |> 
  font(fontname = "Calibri (Body)", part = "all") |> 
  fontsize(size = table_font_size, part = "body") |> 
  # add footer if you want
  # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
  #                colwidths = 4) |> 
  theme_booktabs() |> # default theme
  autofit() |>
  set_table_properties(width = 1, layout = "autofit")
}
if(report_kind == 'interactive'){
  table_data$year  =paste0(c(2,5,10,25,50,100), '-year survival')
  names(table_data)[3] = 'Survival time (95% CI)'
  table_data = table_data[,c(3,1,2)]
  table_data |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = nrow(table_data),
                                 dom = 'Bt',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=FALSE,
                                 ordering=F))

}
```


***

###### {-} 
<!-- This section is for exporting the data -->

```{r, export data}
if(export_data){
  #remove all data except wanted to be exported.
  # rm(list=setdiff(ls(), c("exporting_data_store", "output_dir", "collection")))
  # Do some changes (which we do in smaller chunks in the actual code.)

  endemic_data  = exporting_data_store
  # save as .rda.
  save(endemic_data, file = paste0(output_dir,'/',collection, '_endemic_data.rda'))

}
```

```{r, save excel version of data, eval = save_excel & export_data}
library(xlsx)
file = paste0(output_dir,'/',collection, '_endemic_data.xlsx')
wb <- createWorkbook()
datas <- exporting_data_store

data_titles = names(datas) |> stringr::str_replace_all('_', ' ')
sheetnames <- paste0('Sheet ', 1:length(datas))
sheets <- lapply(sheetnames,  createSheet, wb = wb)
for(i in 1:length(datas)){
  # First we'll create a new row, let's put the title on row 2
  titleRow <-createRow(sheets[[i]], rowIndex=1)
  # We'll add a cell to that row (in the first column) for the title
  sheetTitle <-createCell(titleRow, colIndex=1)
  # We'll add the sheet title to the cell
  setCellValue(sheetTitle[[1,1]], data_titles[i])
  # We'll choose the formatting for the cell
  xlsx::addDataFrame(datas[[i]], sheet = sheets[[i]],row.names = FALSE, startRow = 3)
}
saveWorkbook(wb, file = file)

```

```{r, eval = F}
<!-- ### Recent changes in the endemic species held in the LC -->

<!-- ```{r, recent changes to endemic species} -->
<!-- recent_years = recent_year:2024 -->
<!-- endemic_new = endemic[endemic$AccYear %in% recent_years,] -->
<!-- endemic_new$count = rep(1,nrow(endemic_new)) -->
<!-- endemic_new$powo_name = paste0(endemic_new$POWO_taxon_name, ' ', endemic_new$POWO_taxon_authors) -->
<!-- endemic_new$dead = endemic_new$ItemStatusType == 'NotExisting' -->

<!-- new_endemic_accessions <- endemic_new |> -->
<!--     dplyr::group_by(.data$good_name) |> -->
<!--     dplyr::summarise(original_report_taxon_name = toString(unique(.data$TaxonNameFull)), -->
<!--                      powo_taxon_name = toString(unique(.data$powo_name)), -->
<!--                      no_items_in_LC = sum(.data$count), -->
<!--                      no_dead = sum(.data$dead), -->
<!--                      accessions = toString(unique(.data$AccNoFull)), -->
<!--                      threatened = .data$threatened[1], -->
<!--                      location = .data$geography_codes[1], -->
<!--     ) |> -->
<!--     dplyr::ungroup()  -->

<!-- alive_prior = unlist(lapply(new_endemic_accessions$accessions, function(x){ -->
<!--   accessions = unlist(stringr::str_split(x, ', ')) -->
<!--   taxa = endemic$good_name[endemic$AccNoFull == accessions[1]][1] -->

<!--   all_records = endemic[endemic$good_name == taxa,] -->
<!--   all_records = all_records[order(all_records$AccYear, all_records$AccNoFull),] -->
<!--   items_prior_to_accession = rep(NA, length(accessions)) -->
<!--   for(i in 1:length(accessions)){ -->
<!--     if((match(accessions[i], all_records$AccNoFull)-1) == 0){ -->
<!--       items_prior_to_accession[i] = 'Never in LC before' -->
<!--     }else{ -->
<!--     prior_records =all_records[1:(match(accessions[i], all_records$AccNoFull)-1),] -->
<!--     accession_year = all_records$AccYear[match(accessions[i], all_records$AccNoFull)][1] -->
<!--     def_dead_before = sum(prior_records$status_year < accession_year & prior_records$ItemStatusType == 'NotExisting') -->
<!--     pos_dead_or_alive_before = sum(prior_records$status_year == accession_year & prior_records$ItemStatusType == 'NotExisting') -->
<!--     def_alive = nrow(prior_records) - def_dead_before - pos_dead_or_alive_before -->
<!--     items_prior_to_accession[i] = paste0('(',def_alive, ', ', pos_dead_or_alive_before ,')') -->
<!--     } -->

<!--   } -->
<!--   return(paste0(items_prior_to_accession, collapse = ', ')) -->
<!-- })) -->
<!-- new_endemic_accessions$alive_prior_accession = alive_prior -->

<!-- new_endemic_accessions$location = wgsrpd3$LEVEL3_NAM[match(new_endemic_accessions$location, wgsrpd3$LEVEL3_COD)] -->
<!-- ``` -->

<!-- In this section we explore new additions to the endemic species to the collection since `r recent_year`. In this time frame there have been `r length(unique(endemic_new$AccNoFull))` accessions of endemic species with a total of `r nrow(endemic_new)` items. The new accessions consists of `r nrow(new_endemic_accessions)` endemic taxa which spans `r length(unique(new_endemic_accessions$location))` different locations. Below we produce a table of `r if(report_kind == 'static'){"the top ten"}` locations by the number of accessions. -->

<!-- ```{r table of top 10 locations by "recent endemic" additions } -->
<!-- new_endemic_accessions$total_per_taxa = stringr::str_count(new_endemic_accessions$accessions, ',') + 1 -->

<!-- accessions_per_location = as.data.frame(new_endemic_accessions |> dplyr::count(location, name= "total_per_taxa")) -->
<!-- accessions_per_location = accessions_per_location[order(accessions_per_location$total_per_taxa,decreasing = T),] -->
<!-- names(accessions_per_location) = c('Location', 'Number of Accessions') -->

<!-- if(report_kind == 'static'){ -->
<!--   accessions_per_location[1:min(10, nrow(accessions_per_location)),] |> -->
<!--   flextable() |> -->
<!--   set_caption(caption = paste0("Locations of Endemic Speices Accessioned since ", recent_year)) |>  -->
<!--   font(fontname = "Calibri (Body)", part = "all") |>  -->
<!--   fontsize(size = table_font_size, part = "body") |>  -->
<!--   # add footer if you want -->
<!--   # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.",  -->
<!--   #                colwidths = 4) |>  -->
<!--   theme_booktabs() |> # default theme -->
<!--   autofit() -->
<!-- } -->
<!-- if(report_kind == 'interactive'){ -->
<!--   DT::datatable(accessions_per_location, rownames = FALSE,  options = list(dom = 'tp',pageLength =  5)) -->
<!-- } -->
<!-- ``` -->

<!-- We can use the accession year (no date available) and item status date to calculate how many of the recently accessioned endemic species were new to the LC at the time of accessioning. We do have to be slightly careful since we could have a new accession in the same year as the last previous item of that taxa dying in the same year. In this case, we cannot be sure if the accessioning occurred before or after the plant died. In this case we shall make a note, and class it as "unsure". -->

<!-- Of the `r nrow(new_endemic_accessions)` taxa accessioned `r sum(grepl('Never in LC before', new_endemic_accessions$alive_prior_accession))` were never previously held in the LC. Of those that have being in the LC before (`r sum(new_endemic_accessions$alive_prior_accession != 'Never in LC before')`) `r sum(grepl('^\\(0, 0', new_endemic_accessions$alive_prior_accession))` were not existing at the time of accessions, `r sum(grepl('^\\(0, [1-9]', new_endemic_accessions$alive_prior_accession))` are unsure if they were existing at time of accessioning and `r sum(grepl('^\\([1-9]', new_endemic_accessions$alive_prior_accession))` were already held in the LC. -->

<!-- Of the recently accessioned endemic species `r sum(new_endemic_accessions$no_dead)` items have died, resulting to `r sum(new_endemic_accessions$no_dead == new_endemic_accessions$no_items_in_LC)` taxa having net no new accessions/items since `r recent_year` (i.e all accessioned items have died). This includes `r sum(new_endemic_accessions$no_dead == new_endemic_accessions$no_items_in_LC & grepl('Never in LC before', new_endemic_accessions$alive_prior_accession))` taxa which were never previously held in the LC.  -->


```

### Proportion of native taxonomy found in the collection

In this section we create sunburst and treemap charts showing all of the trees found within WCVP (accepted species; by matching to BGCI GlobalTreeSearch), grouped into families, order and higher level lineages. The charts are shaded lighter to darker orange depending on the proportion of the tree lineage found in the collection. 


```{r, Create taxonomic diversity genus level, echo = FALSE, message = FALSE}
geography_data = wcvp$geography[,grepl('_area_code_l3', names(wcvp$geography))]
want = c('000','010','001','011','100','110','101')
#Depending on the values of the options reduce `want` to only the satisfactory values.
##A) introduced / naturally occurring only.
if(native == 'Introduced only'){
 want = want[grepl('^1',want)]
}else if(native == 'Naturally occurring only'){
 want = want[grepl('^0',want)]
}
## B) Extinct
if(!extinct){
 want = want[!grepl('010|011|110',want)]
}
## C) Doubtful
if(!doubtful_locations){
 want = want[!grepl('001|011|101',want)]
}
# Get the columns in wanted info that contain the geography information we want.
geography_data = geography_data[,grepl(paste0(want,collapse='|'), names(geography_data))]

if(length(want) > 1){
 level3codes =do.call("paste", c(geography_data, sep = ", "))
 level3codes = stringr::str_remove(level3codes, ', NA$')
 level3codes = stringr::str_remove(level3codes, 'NA, ')
}else{
 level3codes = geography_data
}
level3codes_wcvp = level3codes

endemic_index = which(stringr::str_length(level3codes_wcvp) == 3)
endemic_plant_ids =  wcvp$geography$plant_name_id[endemic_index]
endemic_plant_ids = endemic_plant_ids[!is.na(endemic_plant_ids)]

endemic_wcvp = wcvp$wcvp_names[wcvp$wcvp_names$plant_name_id %in% endemic_plant_ids,]





report = endemic_wcvp
report = report[report$taxon_status == 'Accepted',]
collection_report = endemic_existing
LC_in_WCVP = match(unique(collection_report$POWO_plant_name_id) ,report$plant_name_id)
LC_in_WCVP = LC_in_WCVP[!is.na(LC_in_WCVP)]
in_LC = rep(F, nrow(report))
in_LC[LC_in_WCVP] = TRUE
report$in_LC = in_LC
report = report[c('family', 'genus', 'in_LC')]
report$fam_gen = paste0(report$family,' ',report$genus)
report <-  report |> 
        dplyr::group_by(fam_gen) |> 
        dplyr::summarise(family = family[1], 
                         genus = genus[1],
                         in_LC = any(in_LC)) |>
  dplyr::ungroup() 



#No families.
# = Use POWO family if available if not use the original.
no_families <- length(unique(report$family))

#No genus
# = Use POWO genus if available if not use the original.
no_genus <- length(unique(report$fam_gen))


report_div  = report

Diversity_class = BGSmartR::Diversity_classification
Classification <- as.data.frame(Diversity_class$Classification)
synomym_families <- as.data.frame(Diversity_class$synomym_families)

fam = report_div$family

# Convert from conserved family name to family name where applicable. 
AA = apply(synomym_families, 2, function(x){
  fam[fam == as.character(x[2])] = as.character(x[1])
  })
report_div$family = fam

matched_families = match(fam, Classification$family)
order = Classification$order[matched_families]
major_Eudicot_lineage = Classification$`major Eudicot lineage`[matched_families]
major_Angiosperm_lineage = Classification$`major Angiosperm lineage`[matched_families]
major_Land_Plants_lineage = Classification$`major Land Plants lineage`[matched_families]


report_div$order = order
report_div$major_Eudicot_lineage = major_Eudicot_lineage
report_div$major_Angiosperm_lineage = major_Angiosperm_lineage
report_div$major_Land_Plants_lineage = major_Land_Plants_lineage

report_cur = report_div

combined_taxo = paste0(report_cur$genus,'---',
                                       report_cur$family,'---',
                                       report_cur$order,'---',
                                       report_cur$major_Eudicot_lineage,'---',
                                       report_cur$major_Angiosperm_lineage,'---',
                                       report_cur$major_Land_Plants_lineage)

with_issue = length(which(grepl('---NA$',combined_taxo)))
combined_taxo_count = as.numeric(report_cur$in_LC)
#remove those without major land plants lineage. (i.e ends in ---NA).
if(with_issue > 0){
  index_remove = which(grepl('---NA$',combined_taxo))
  combined_taxo = combined_taxo[-index_remove]
  combined_taxo_count = combined_taxo_count[-index_remove]
}
# Convert NA in species to Indet.
combined_taxo[which(grepl('^NA---',combined_taxo))] = stringr::str_replace(combined_taxo[which(grepl('^NA---',combined_taxo))], '^NA---', 'Indet.---')


data = data.frame(ID = combined_taxo, count = combined_taxo_count, count_all = 1)
non_combined  = data.frame(t(data.frame(stringr::str_split(data$ID,pattern = '---'))))
names(non_combined) = c('genus', 'family', 'order', 'major_Eudicot_lineage',
                        'major_Angiosperm_lineage', 'major_Land_Plants_lineage')
rownames(non_combined) = 1:nrow(non_combined)

data = data.frame(data, non_combined)

# push species names to genus species (otherwise issues with repeated species names with different genera)

labels = c(unique(data$major_Land_Plants_lineage), unique(data$major_Angiosperm_lineage), unique(data$major_Eudicot_lineage),
           unique(data$order), unique(data$family), unique(data$genus))
major_Land_Plants_lineage_index = 1:length(unique(data$major_Land_Plants_lineage))
major_Angiosperm_lineage_index = (max(major_Land_Plants_lineage_index)+1):(max(major_Land_Plants_lineage_index)+length(unique(data$major_Angiosperm_lineage)))
major_Eudicot_lineage_index = (max(major_Angiosperm_lineage_index)+1):(max(major_Angiosperm_lineage_index)+length(unique(data$major_Eudicot_lineage)))
order_index = (max(major_Eudicot_lineage_index)+1):(max(major_Eudicot_lineage_index)+length(unique(data$order)))
family_index = (max(order_index)+1):(max(order_index)+length(unique(data$family)))
genus_index = (max(family_index)+1):(max(family_index)+length(unique(data$genus)))

parents = rep('', length(labels))
parents[major_Angiosperm_lineage_index] = data$major_Land_Plants_lineage[match(labels[major_Angiosperm_lineage_index], data$major_Angiosperm_lineage)]
parents[major_Eudicot_lineage_index] = data$major_Angiosperm_lineage[match(labels[major_Eudicot_lineage_index], data$major_Eudicot_lineage)]
parents[order_index] = data$major_Eudicot_lineage[match(labels[order_index], data$order)]
parents[family_index] = data$order[match(labels[family_index], data$family)]
parents[genus_index] = data$family[match(labels[genus_index], data$genus)]

values = rep(NA, length(labels))
values[genus_index] = data$count[match(labels[genus_index], data$genus)]
total_for_families <-  aggregate(. ~family, data[,c(5,2)], sum, na.rm = TRUE)
values[family_index] = total_for_families$count[match(labels[family_index], total_for_families$family)]
total_for_order <-  aggregate(. ~order, data[,c(6,2)], sum, na.rm = TRUE)
values[order_index] = total_for_order$count[match(labels[order_index], total_for_order$order)]
total_for_major_Eudicot_lineage <-  aggregate(. ~major_Eudicot_lineage, data[,c(7,2)], sum, na.rm = TRUE)
values[major_Eudicot_lineage_index] = total_for_major_Eudicot_lineage$count[match(labels[major_Eudicot_lineage_index], total_for_major_Eudicot_lineage$major_Eudicot_lineage)]
total_for_major_Angiosperm_lineage <-  aggregate(. ~major_Angiosperm_lineage, data[,c(8,2)], sum, na.rm = TRUE)
values[major_Angiosperm_lineage_index] = total_for_major_Angiosperm_lineage$count[match(labels[major_Angiosperm_lineage_index], total_for_major_Angiosperm_lineage$major_Angiosperm_lineage)]
total_for_major_Land_Plants_lineage <-  aggregate(. ~major_Land_Plants_lineage, data[,c(9,2)], sum, na.rm = TRUE)
values[major_Land_Plants_lineage_index] = total_for_major_Land_Plants_lineage$count[match(labels[major_Land_Plants_lineage_index], total_for_major_Land_Plants_lineage$major_Land_Plants_lineage)]
in_collection = values

values = rep(NA, length(labels))
values[genus_index] = data$count_all[match(labels[genus_index], data$genus)]
total_for_families <-  aggregate(. ~family, data[,c(5,3)], sum, na.rm = TRUE)
values[family_index] = total_for_families$count[match(labels[family_index], total_for_families$family)]
total_for_order <-  aggregate(. ~order, data[,c(6,3)], sum, na.rm = TRUE)
values[order_index] = total_for_order$count[match(labels[order_index], total_for_order$order)]
total_for_major_Eudicot_lineage <-  aggregate(. ~major_Eudicot_lineage, data[,c(7,3)], sum, na.rm = TRUE)
values[major_Eudicot_lineage_index] = total_for_major_Eudicot_lineage$count[match(labels[major_Eudicot_lineage_index], total_for_major_Eudicot_lineage$major_Eudicot_lineage)]
total_for_major_Angiosperm_lineage <-  aggregate(. ~major_Angiosperm_lineage, data[,c(8,3)], sum, na.rm = TRUE)
values[major_Angiosperm_lineage_index] = total_for_major_Angiosperm_lineage$count[match(labels[major_Angiosperm_lineage_index], total_for_major_Angiosperm_lineage$major_Angiosperm_lineage)]
total_for_major_Land_Plants_lineage <-  aggregate(. ~major_Land_Plants_lineage, data[,c(9,3)], sum, na.rm = TRUE)
values[major_Land_Plants_lineage_index] = total_for_major_Land_Plants_lineage$count[match(labels[major_Land_Plants_lineage_index], total_for_major_Land_Plants_lineage$major_Land_Plants_lineage)]
total_wcvp = values


data_formatted = data.frame(ID = labels, labels=labels, parents = parents, values = total_wcvp,  in_LC = in_collection)

#Go back to just species names.
data_formatted$labels[grepl('---', data_formatted$labels)] = unlist(lapply(stringr::str_split(data_formatted$labels[grepl('---', data_formatted$labels)], pattern = '---'), function(x){x[1]}))
data_formatted$ID[grepl('---', data_formatted$ID)] = unlist(lapply(stringr::str_split(data_formatted$ID[grepl('---', data_formatted$ID)], pattern = '---'), function(x){x[1]}))
# data_formatted$labels=unlist(lapply(stringr::str_split(data_formatted$labels, ' '),function(x){x[length(x)]}))
data_formatted$ID = paste0(data_formatted$labels, '---', data_formatted$parents)

data_formatted$parents = paste0(data_formatted$parents,'---',data_formatted$parents[match(data_formatted$parents, data_formatted$labels)])
data_formatted$parents[data_formatted$parents == "---NA"] =''

# Collapse levels.
data_formatted$labels[data_formatted$labels == 'None_Eudicots'] = 'Other'
data_formatted$labels[data_formatted$labels == 'None_Angiosperms'] = 'Other'

# Remove Intermediate levels.
remove_nodes = c('None_Monocots', 'None_Ferns', 'None_Ferns_Eudicot',"None_Gymnosperms", 'None_Lycophytes',   'None_Liverworts', 'None_Hornworts', 'None_Gymnosperms_Eudicot', 'None_Lycophytes_Eudicot', 'None_Liverworts_Eudicot', 'None_Hornworts_Eudicot', 'No_Mosses_Angiosperm_lineage', 'No_Mosses_Eudicot_lineage', 'None_Angiosperms_Eudicot_lineage')
AA = lapply(remove_nodes, function(node){
  # Select the row to remove (begining with "*node*---")
  to_remove = which(grepl(paste0('^',node,'---'), data_formatted$ID))
  if(length(to_remove)> 0 ){
    #Get new parent id and new label from the node to remove.
    new_parent = data_formatted[to_remove,]$parents
    new_label =  unlist(stringr::str_split(new_parent,'---'))[1]
    # Remove the row.
    data_formatted = data_formatted[-to_remove,]
    # Update End of the ID for the new parent
    data_formatted$ID[grepl(paste0(node,'$'),data_formatted$ID)] = unlist(stringr::str_replace(data_formatted$ID[grepl(paste0(node,'$'),data_formatted$ID)],paste0('---',node), paste0('---',new_label)))
    # Update the parents for each node who originally has 'node' as the value. 
    data_formatted$parents[grepl(paste0('^',node, '---'),data_formatted$parents)] = new_parent
    # Update the parents for each node who originally has 'node' as the parent. 
    data_formatted$parents[grepl(paste0(node,'$'),data_formatted$parents)] = unlist(stringr::str_replace(data_formatted$parents[grepl(paste0(node,'$'),data_formatted$parents)],paste0('---',node), paste0('---',new_label)))
    data_formatted <<- data_formatted
  }
 
  return()
})


# Add header of 'Collection'
data_formatted$ID[grepl('---$', data_formatted$ID)] = paste0(data_formatted$ID[grepl('---$', data_formatted$ID)] , 'WCVP')
data_formatted$parents[grepl('---$', data_formatted$parents)] = paste0(data_formatted$parents[grepl('---$', data_formatted$parents)] , 'WCVP')
data_formatted$parents[data_formatted$parents == ''] = 'WCVP'

data_formatted[nrow(data_formatted)+1,] = c('WCVP', 'WCVP', '', sum(data_formatted$values[data_formatted$parents == 'WCVP']), sum(data_formatted$in_LC[data_formatted$parents == 'WCVP']) )

### Subfamily level information
{
  # Load the downloaded WFO dataset from -> https://www.worldfloraonline.org/downloadData
file = '/Users/jakepowell/Downloads/classification.csv'
data = read.csv(file, sep = '\t')

data_accepted = data[data$taxonomicStatus == 'Accepted',]
data_care = data[c('family', 'subfamily', 'tribe', 'subtribe','majorGroup','genus')]

## Create a summary of families and their subfamilies.
data_simp <- data_care |>
  dplyr::group_by(.data$family) |>
  dplyr::summarise(subfamily = toString(unique(.data$subfamily)),
                   tribe = toString(unique(.data$tribe)),
                   subtribe = toString(unique(.data$subtribe)),
                   majorGroup = toString(unique(.data$majorGroup)),
                   no_genus = length(unique(.data$genus))
  ) |>
  dplyr::ungroup()

data_simp$subfamily = stringr::str_remove(string = data_simp$subfamily, pattern = 'NA, ')
data_simp$tribe = stringr::str_remove(string = data_simp$tribe, pattern = 'NA, ')
data_simp$subtribe = stringr::str_remove(string = data_simp$subtribe, pattern = 'NA, ')

data_simp = data_simp[rev(order(data_simp$no_genus)),]
writexl::write_xlsx(data_simp, path = 'Subfamily_information_in_WFO_v.2023.12.xlsx')


data_accepted = data[data$taxonomicStatus == 'Accepted',]
data_care = data_accepted[c('family', 'subfamily', 'tribe', 'subtribe','majorGroup','genus')]

data_simp <- data_care |>
  dplyr::group_by(.data$family) |>
  dplyr::summarise(subfamily = toString(unique(.data$subfamily)),
                   tribe = toString(unique(.data$tribe)),
                   subtribe = toString(unique(.data$subtribe)),
                   majorGroup = toString(unique(.data$majorGroup)),
                   no_genus = length(unique(.data$genus))
  ) |>
  dplyr::ungroup()

data_simp$subfamily = stringr::str_remove(string = data_simp$subfamily, pattern = 'NA, ')
data_simp$tribe = stringr::str_remove(string = data_simp$tribe, pattern = 'NA, ')
data_simp$subtribe = stringr::str_remove(string = data_simp$subtribe, pattern = 'NA, ')

data_simp = data_simp[rev(order(data_simp$no_genus)),]
writexl::write_xlsx(data_simp, path = 'Subfamily_information_in_WFO_v.2023.12_accepted_only.xlsx')

data_tribe <- data_care[data_care$tribe != '',] |>
  dplyr::group_by(.data$subfamily) |>
  dplyr::summarise(family = toString(unique(.data$family)),
                   tribe = toString(unique(.data$tribe)),
                   subtribe = toString(unique(.data$subtribe)),
                   majorGroup = toString(unique(.data$majorGroup)),
                   no_genus = length(unique(.data$genus))
  ) |>
  dplyr::ungroup()

data_tribe$family = stringr::str_remove(string = data_tribe$family, pattern = 'NA, ')
data_tribe$tribe = stringr::str_remove(string = data_tribe$tribe, pattern = 'NA, ')
data_tribe$subtribe = stringr::str_remove(string = data_tribe$subtribe, pattern = 'NA, ')

data_tribe = data_tribe[rev(order(data_tribe$no_genus)),]
writexl::write_xlsx(data_simp, path = 'Tribe_information_in_WFO_v.2023.12_accepted_only.xlsx')

data_subtribe <- data_care[data_care$subtribe != '',] |>
  dplyr::group_by(.data$tribe) |>
  dplyr::summarise(family = toString(unique(.data$family)),
                   subfamily = toString(unique(.data$subfamily)),
                   subtribe = toString(unique(.data$subtribe)),
                   majorGroup = toString(unique(.data$majorGroup)),
                   no_genus = length(unique(.data$genus))
  ) |>
  dplyr::ungroup()

data_subtribe = data_subtribe[rev(order(data_subtribe$no_genus)),]
writexl::write_xlsx(data_simp, path = 'Subtribe_information_in_WFO_v.2023.12_accepted_only.xlsx')


}

### Add subfamily info to data_formatted
{
  #############################################################################
## Add subfamilies (All)
#############################################################################
## Get the genus that are linked to each sub family.
families_with_sub = data_simp$family[data_simp$subfamily != ""]
data_fam_sub = data_care[data_care$family %in% families_with_sub,]
data_fam_sub$subfamily[data_fam_sub$subfamily == ''] = 'No Subfamily'
data_fam_sub$together = paste0(data_fam_sub$family, '---', data_fam_sub$subfamily)
subfamily_genus = unique(data_fam_sub[c("together", 'genus')])
subfamily_genus_simp <- subfamily_genus |>
  dplyr::group_by(.data$together) |>
  dplyr::summarise(all_genera = toString(unique(.data$genus)),
                   no_genera = length(unique(.data$genus))
  ) |>
  dplyr::ungroup()
subfamily_genus_simp$family = stringr::str_extract(subfamily_genus_simp$together, '[A-Za-z ]*')
subfamily_genus_simp$sub_family = stringr::str_extract(subfamily_genus_simp$together, '[A-Za-z ]*$')

# Remove those without a subfamily (we will deal with these later)
subfamily_genus_simp = subfamily_genus_simp[subfamily_genus_simp$sub_family != "No Subfamily",]
save(subfamily_genus_simp, file = 'subfamily_genus_simp.rda')

for(i in 1:nrow(subfamily_genus_simp)){
  # for(i in 1:30){
  subfamily_info = subfamily_genus_simp[i,]
  subfamily_genera = unlist(stringr::str_split(subfamily_info$all_genera ,', '))
  subfamily_genera = subfamily_genera[subfamily_genera !=  ""]
  if(length(subfamily_genera) == 0){
    next
  }
  in_formatted = which(grepl(paste0(subfamily_info$family, '$'),data_formatted$ID) &
                         grepl(paste0(subfamily_genera, collapse = '|'),data_formatted$labels))
  if(length(in_formatted) >0){
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(subfamily_info$sub_family,'---', subfamily_info$family)
    new = c(new_ID, subfamily_info$sub_family, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = subfamily_info$family, replacement = subfamily_info$sub_family)
    data_want$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new
  }
}

####### Deal with genera with no subfamily (when others in the family have a sub-family.)
# Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
families_with_subfamilies = unique(subfamily_genus_simp$family)
all_subfamilies = unique(subfamily_genus_simp$sub_family)
# Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
for(i in 1:length(families_with_subfamilies)){
  family = families_with_subfamilies[i]
  # Fine records whose parent is the familiy in question and extract the data.

  in_formatted = which(grepl(paste0(family,'$'),data_formatted$ID))
  data_want = data_formatted[in_formatted,]

  # Check if we have any records where we have genus---family (i.e no  subfamily)
  without_subfamily = which(!data_want$labels %in% all_subfamilies)

  #If we have at least one genus-family we need to group these into no subfamily.
  if(length(without_subfamily) > 0){
    data_without_subfam = data_want[without_subfamily,]

    new_ID = paste0('No Subfamily','---', family)

    new_node = new = c(new_ID, 'No Subfamily', data_want$parents[1], sum(as.numeric(data_without_subfam$values)), sum(as.numeric(data_without_subfam$in_LC)))

    data_without_subfam$ID = stringr::str_replace(data_without_subfam$ID,pattern = family, replacement = 'No Subfamily')
    data_without_subfam$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted[without_subfamily],] = data_without_subfam

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new_node
  }

}

#############################################################################
## Add tribes (All)
#############################################################################
# asteraceae = data_simp[data_simp$family == "Asteraceae",]

## Get the genus that are linked to each sub family.
subfamilies_with_tribe = data_tribe$subfamily[data_tribe$tribe != ""]
data_fam_sub = data_care[data_care$subfamily %in% subfamilies_with_tribe,]
data_fam_sub$tribe[data_fam_sub$tribe == ''] = 'No Tribe'
data_fam_sub$together = paste0(data_fam_sub$subfamily, '---', data_fam_sub$tribe)
subfamily_genus = unique(data_fam_sub[c("together", 'genus')])
tribe_genus_simp <- subfamily_genus |>
  dplyr::group_by(.data$together) |>
  dplyr::summarise(all_genera = toString(unique(.data$genus)),
                   no_genera = length(unique(.data$genus))
  ) |>
  dplyr::ungroup()
tribe_genus_simp$tribe = stringr::str_extract(tribe_genus_simp$together, '[A-Za-z ]*$')
tribe_genus_simp$sub_family = stringr::str_extract(tribe_genus_simp$together, '[A-Za-z ]*')

# Remove those without a subfamily (we will deal with these later)
tribe_genus_simp = tribe_genus_simp[tribe_genus_simp$sub_family != "No Subfamily",]
save(tribe_genus_simp, file = 'tribe_genus_simp')

for(i in 1:nrow(tribe_genus_simp)){
  # for(i in 1:30){
  tribe_info = tribe_genus_simp[i,]
  tribe_genera = unlist(stringr::str_split(tribe_info$all_genera ,', '))
  tribe_genera = tribe_genera[tribe_genera !=  ""]
  if(length(tribe_genera) == 0){
    next
  }
  in_formatted = which(grepl(paste0(tribe_info$sub_family, '$'),data_formatted$ID) &
                         grepl(paste0(tribe_genera, collapse = '|'),data_formatted$labels))
  if(length(in_formatted) >0){
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(tribe_info$tribe,'---', tribe_info$sub_family)
    new = c(new_ID, tribe_info$tribe, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = tribe_info$sub_family, replacement = tribe_info$tribe)
    data_want$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new
  }
}

####### Deal with genera with no subfamily (when others in the family have a sub-family.)
# Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
subfamilies_with_tribes = unique(tribe_genus_simp$sub_family)
all_tribes = unique(tribe_genus_simp$tribe)
# Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
for(i in 1:length(subfamilies_with_tribes)){
  subfamily = subfamilies_with_tribes[i]
  # Fine records whose parent is the familiy in question and extract the data.

  in_formatted = which(grepl(paste0(subfamily,'$'),data_formatted$ID))
  data_want = data_formatted[in_formatted,]

  # Check if we have any records where we have genus---subfamily (i.e no  subfamily)
  without_tribe = which(!data_want$labels %in% all_tribes)

  #If we have at least one genus-subfamily we need to group these into no subfamily.
  if(length(without_tribe) > 0){
    data_without_tribe = data_want[without_tribe,]

    new_ID = paste0('No Tribe','---', subfamily)

    new_node = new = c(new_ID, 'No Tribe', data_want$parents[1], sum(as.numeric(data_without_tribe$values)), sum(as.numeric(data_without_tribe$in_LC)))

    data_without_tribe$ID = stringr::str_replace(data_without_tribe$ID,pattern = subfamily, replacement = 'No Tribe')
    data_without_tribe$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted[without_tribe],] = data_without_tribe

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new_node
  }

}


#############################################################################
## Add Subtribes (All)
#############################################################################
# asteraceae = data_simp[data_simp$family == "Asteraceae",]

## Get the genus that are linked to each sub family.
tribes_with_subtribes = data_subtribe$tribe[data_subtribe$subtribe != ""]
data_fam_sub = data_care[data_care$tribe %in% tribes_with_subtribes,]
data_fam_sub$subtribe[data_fam_sub$subtribe == ''] = 'No Subtribe'
data_fam_sub$together = paste0(data_fam_sub$tribe, '---', data_fam_sub$subtribe)
subtribe_genus = unique(data_fam_sub[c("together", 'genus')])
subtribe_genus_simp <- subtribe_genus |>
  dplyr::group_by(.data$together) |>
  dplyr::summarise(all_genera = toString(unique(.data$genus)),
                   no_genera = length(unique(.data$genus))
  ) |>
  dplyr::ungroup()
subtribe_genus_simp$subtribe = stringr::str_extract(subtribe_genus_simp$together, '[A-Za-z ]*$')
subtribe_genus_simp$tribe = stringr::str_extract(subtribe_genus_simp$together, '[A-Za-z ]*')

# Remove those without a subfamily (we will deal with these later)
subtribe_genus_simp = subtribe_genus_simp[subtribe_genus_simp$subtribe != "No Subtribe",]
save(subtribe_genus_simp, file = 'subtribe_genus_simp.rda')

for(i in 1:nrow(subtribe_genus_simp)){
  # for(i in 1:30){
  subtribe_info = subtribe_genus_simp[i,]
  subtribe_genera = unlist(stringr::str_split(subtribe_info$all_genera ,', '))
  subtribe_genera = subtribe_genera[subtribe_genera !=  ""]
  if(length(subtribe_genera) == 0){
    next
  }
  in_formatted = which(grepl(paste0(subtribe_info$tribe, '$'),data_formatted$ID) &
                         grepl(paste0(subtribe_genera, collapse = '|'),data_formatted$labels))
  if(length(in_formatted) == 0){
    next
  }
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(subtribe_info$subtribe,'---', subtribe_info$tribe)
    new = c(new_ID, subtribe_info$subtribe, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = subtribe_info$tribe, replacement = subtribe_info$subtribe)
    data_want$parents = new_ID
    
    
    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want
    
    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new
}

####### Deal with genera with no subfamily (when others in the family have a sub-family.)
# Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
tribes_with_subtribes = unique(subtribe_genus_simp$tribe)
all_subtribes = unique(subtribe_genus_simp$subtribe)
# Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
for(i in 1:length(tribes_with_subtribes)){
  tribe = tribes_with_subtribes[i]
  # Fine records whose parent is the familiy in question and extract the data.
  
  in_formatted = which(grepl(paste0(tribe,'$'),data_formatted$ID))
  data_want = data_formatted[in_formatted,]
  
  # Check if we have any records where we have genus---tribe (i.e no  tribe)
  without_subtribe = which(!data_want$labels %in% all_subtribes)
  
  #If we have at least one genus-tribe we need to group these into no tribe
  if(length(without_subtribe) > 0){
    data_without_tribe = data_want[without_subtribe,]
    
    new_ID = paste0('No Subtribe','---', tribe)
    
    new_node = new = c(new_ID, 'No Subtribe', data_want$parents[1], sum(as.numeric(data_without_tribe$values)), sum(as.numeric(data_without_tribe$in_LC)))
    
    data_without_tribe$ID = stringr::str_replace(data_without_tribe$ID,pattern = tribe, replacement = 'No Subtribe')
    data_without_tribe$parents = new_ID
    
    
    # Replace original genus-family with the new genus-tribe
    data_formatted[in_formatted[without_subtribe],] = data_without_tribe
    
    # Add the new node for the tribe
    data_formatted[nrow(data_formatted)+1,] = new_node
  }
  
}


#############################################################################

}



data_formatted$percentage = as.numeric(data_formatted$in_LC) / as.numeric(data_formatted$values)
rbPal <- colorRampPalette(c("#FEEDDE", "#FDD0A2", "#FDAE6B", "#FD8D3C", "#F16913", "#D94801", "#8C2D04"))
data_formatted$Col <- rbPal(100)[as.numeric(cut(data_formatted$percentage,breaks = 100))]

data_formatted$hover = paste0(round(data_formatted$percentage*100,digits = 2),'% of endemic ', data_formatted$labels, ' genera found within the LC (',data_formatted$in_LC,'/',data_formatted$values,')')
```

```{r, Create  taxonomic diversity at genus with contained/missing, echo = F}
if(report_kind == 'interactive'){
 fig <- plotly::plot_ly(data_formatted,
                             ids = ~ID,
                             labels = ~labels,
                             parents =~parents,
                             values = ~values,
                             type = 'sunburst',
                             insidetextorientation='radial',
                             branchvalues = 'total',
                             maxdepth = 4,
                             marker=list(colors=data_formatted$Col, line = list(color = 'white')),
                             hoverinfo = "text",  hovertext = data_formatted$hoverac
                             )

 fig2 <- plotly::plot_ly(data_formatted,
                             ids = ~ID,
                             labels = ~labels,
                             parents =~parents,
                             values = ~values,
                             type = 'treemap',
                             branchvalues = 'total',
                             maxdepth = 4,
                             marker=list(colors=data_formatted$Col, line = list(color = 'white')),
                         hoverinfo = "text",  hovertext = data_formatted$hover)
                        
if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','sunburst:taxonomic_diversity.html'))
  htmlwidgets::saveWidget(fig2, file = paste0(figures_dir, '/','treemap:taxonomic_diversity.html'))
}

}
```

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Sunburst"}`
```{r  Sunburst genera, fig.fullwidth=TRUE, fig.dim = c(10, 8), eval = report_kind == 'interactive'}
fig
```

`r if(report_kind == 'interactive'){"###### Treemap"}`
```{r  tree map genera, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
fig2
```

`r if(report_kind == 'interactive'){"##### {-}"}`

***
