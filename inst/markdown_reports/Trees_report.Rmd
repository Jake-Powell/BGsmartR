---
title: "Trees in the living collection"
output: html_document
---
  
###### {-} 
<!-- This section is for loading/setting up the data and writing the intro -->
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(plotly)
library(htmltools)
library(sf)
library(here)
library(flextable)
library(ggrepel)
library(downloadthis)

interactive_colour <- function(n){
  color = c('#f46d43', "#FDAE6B", '#848484', '#e6e6e6')
  if(n==2){
    return(color[c(1,4)])
  }
  color[1:n]
}
color_binary <- c('#f46d43', '#e6e6e6')
palette = 'Oranges'
```

```{css, echo = FALSE}
/* from https://ianlunn.github.io/Hover/ */
.hvr-sweep-to-left {
  display: inline-block;
  vertical-align: middle;
  -webkit-transform: perspective(1px) translateZ(0);
  transform: perspective(1px) translateZ(0);
  box-shadow: 0 0 1px rgba(0, 0, 0, 0);
  position: relative;
  -webkit-transition-property: color;
  transition-property: color;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
}
.hvr-sweep-to-left:before {
  content: "";
  position: absolute;
  z-index: -1;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #f46d43;
  -webkit-transform: scaleX(0);
  transform: scaleX(0);
  -webkit-transform-origin: 100% 50%;
  transform-origin: 100% 50%;
  -webkit-transition-property: transform;
  transition-property: transform;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
  -webkit-transition-timing-function: ease-out;
  transition-timing-function: ease-out;
}
.hvr-sweep-to-left:hover, .hvr-sweep-to-left:focus, .hvr-sweep-to-left:active {
  color: white;
}
.hvr-sweep-to-left:hover:before, .hvr-sweep-to-left:focus:before, .hvr-sweep-to-left:active:before {
  -webkit-transform: scaleX(1);
  transform: scaleX(1);
}

.blackbox {
  padding: 1em;
  background: #FDAE6B;
  border: 2px solid #e6e6e6;
  border-radius: 10px;
}
.center {
  text-align: center;
}
```

```{r, imported parameters}
# 
# collection = 'CUBG'
# load('/Users/jakepowell/Cambridge/Enriched_reports_Jake/CUBG_June2023_enriched_report.rda')
# coordinates = c(52.19378853629289,0.1277234065606053)
# # 
# # 
# # load('/Users/jakepowell/Cambridge/Geography Module/wgsrpd3.rda')
# # load('/Users/jakepowell/Cambridge/WCVP/Version 11/wcvp_with_redlistcategory.rda')
# 
# native = 'Naturally occurring only'
# extinct = TRUE
# doubtful_locations = FALSE
# min_year = 1970
# export_data = F
# table_font_size = 14
# ggtheme = NULL
# separate_figure_folder = FALSE
# value_on_fig = TRUE
# report_kind = 'static'
# color_binary = c('darkgray','darkgreen')
# palette = 'Greens'
# recent_year = 2020
```

```{r, add logo, eval = report_kind == 'interactive'}
htmltools::img(src = knitr::image_uri(paste0(system.file(package = "BGSmartR"), "/logo.png")), 
               alt = 'logo', 
               style = 'position:absolute; top:0; right:0; padding:10px; width:87.8px; height:100px')
```

```{r, functions for turnover}
turnover_items <- function(report){
  report = report[(report$LossYear >= min_year & report$LossYear <= max_year) | is.na(report$LossYear),]
  combined = data.frame(Year = years)
  
  # Items
  gain = data.frame(table(report$AccYear))
  if(nrow(gain) == 0){
    gained = rep(0,nrow(combined))
    combined$gain_items = gained
  }else{
    names(gain) = c('Year', 'Items')
    gain$Year = as.numeric(as.character(gain$Year))
    gain = gain[gain$Year >=min_year & gain$Year <= max_year,]
    gained = rep(0,nrow(combined))
    gained[match(gain$Year, combined$Year)] = gain$Items
    combined$gain_items = gained
  }
  
  
  loss = data.frame(table(report$LossYear))
  if(nrow(loss) == 0){
    lost = rep(0,nrow(combined))
    combined$loss_items = lost
  }else{
    names(loss) = c('Year', 'Items')
    loss$Year = as.numeric(as.character(loss$Year))
    loss = loss[loss$Year >=min_year & loss$Year <= max_year,]
    lost = rep(0,nrow(combined))
    lost[match(loss$Year, combined$Year)] = loss$Items
    combined$loss_items = lost
  }
  
  
  combined$net_items = combined$gain_items - combined$loss_items
  return(combined)
}

plots_turnover <- function(turnover, trend, report_kind, text = '', separate_figure_folder, data_type = 'items'){
    dataA = data.frame(turnover[,c(1,3)], rep('Lost', nrow(turnover)))
    names(dataA) = LETTERS[1:3]
    dataB = data.frame(turnover[,c(1,2)], rep('Gain', nrow(turnover)))
    names(dataB) = LETTERS[1:3]
    items_data = rbind(dataA, dataB)
  if(report_kind == 'static'){

    p = ggplot(data=items_data, aes(x=A, y=B, group=C)) +
      geom_line(aes(color=C)) +
      # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
      labs(title=paste0("Turnover of ",text," in the LC (By ",data_type,")"),
           x ="Year",
           y = paste0('Number of ',data_type,'')) +
      guides(color=guide_legend(title=paste0('Gain/Loss'))) +
      # theme(text = element_text(size=table_font_size)) +
      scale_color_manual(values=c("blue", "red"))+
      theme(legend.direction = "horizontal", legend.position = "top", legend.justification = "right")
    
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','turnover_',stringr::str_replace_all(text, ' ', '_'),'_gain_loss_',data_type,'.pdf'),device = 'pdf', scale = 1, width = 20, height = 12, limitsize = FALSE)
    }
    p1=p
    
    # Color based on value
    color <- ifelse(turnover$net_items < 0, "pink", "lightblue")
    p = ggplot(turnover, aes(x = Year, y = net_items)) +
      geom_bar(stat = "identity",
               show.legend = FALSE,
               fill = color,      # Background color
               color = "white") + # Border color
      # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
      labs(title=paste0("Net turnover of ",text," in the LC (By ",data_type,")"),
           x ="Year",
           y = paste0('Number of ',data_type,''))
    # theme(text = element_text(size=table_font_size))
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Net_turnover_',stringr::str_replace_all(text, ' ', '_'),'_',data_type,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
    p2=p
    
    
    # Trend plot.
    trend_data = data.frame(year = turnover$Year, trend = trend)
    p = ggplot(trend_data, aes(x = year, y = trend)) +
      geom_line(width = 1.1) +
      labs(title="",
           x ="Year",
           y = paste0('Number of ',data_type,''))
    p3 = p
    return(list(gain_loss = p1, net = p2, trend = p3))
  }
  if(report_kind == 'interactive'){
    # gain_loss plot
    colors = color_binary |> rev()
    fig <- plot_ly(items_data, x = ~A, y = ~B, color = ~C, colors = colors, type = 'scatter', mode = 'lines+markers')
    fig <- fig |> layout(yaxis = list(title = paste0("Number of ",data_type |> tolower(),"")),
                         xaxis = list(title = "Year"))
    fig <- fig |> layout(hovermode = 'x unified')
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','line-turnover_',stringr::str_replace_all(text, ' ', '_'),'_gain_loss_',data_type,'.html'))
    }
    fig1 = fig
    
    # net plot
    colors = color_binary |> rev()
    color <- ifelse(turnover$net_items < 0, colors[1], colors[2])
    texto = paste0('Net: ', turnover$net_items, '<br>',
                   'Gain: ', turnover$gain_items, '<br>',
                   'Loss: ', turnover$loss_items, '<br>'
    )
    fig = plot_ly(turnover, x = ~Year, y = ~net_items, type = 'bar', hoverinfo = "x+text",  hovertext = texto, color = color, colors = rev(colors), showlegend = FALSE)
    fig <- fig |> layout(yaxis = list(title = paste0("Net number of ",data_type |> tolower(),"")),
                         xaxis = list(title = "Year"))
    fig <- fig |> layout(hovermode = 'x unified')
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Bar-Net_',stringr::str_replace_all(text, ' ', '_'),'turnover_of_',data_type,'.html'))
    }
    fig2 = fig
    
    # Trend plot.
    trend_data = data.frame(year = turnover$Year, trend = trend)
    fig = plot_ly(trend_data, x = ~year, y = ~trend, type = 'scatter', mode = 'line', hoverinfo = "x+text", hovertext = trend)
    fig <- fig |> layout(yaxis = list(title = paste0("Number of ",data_type |> tolower(),"")),
                         xaxis = list(title = "Year"))
    fig <- fig |> layout(hovermode = 'x unified')
    fig3= fig
    
    # Combined trend and net.
    fig <- plot_ly()
    # Add traces
    ay <- list(
      tickfont = list(color = "black"),
      overlaying = "y",
      side = "right",
      title = paste0("Total ", tolower(data_type)))
    
      fig <- fig %>% add_trace(x = years, y = turnover$net_items, name = "Net", type = 'bar', hoverinfo = "x+text",  hovertext = texto, color = color, colors = rev(colors), showlegend = FALSE)
     
    fig <- fig %>% add_trace(x = years, y = trend, name = "Total", mode = "lines+markers", type = "scatter", line = list(color = 'black'), marker = list(color = 'black'),yaxis = "y2")
    
  
    # Set figure title, x and y-axes titles
    fig <- fig |> layout(
      title = "", yaxis2 = ay,
      xaxis = list(title="Year"),
      yaxis = list(title = paste0("Net turnover of ", tolower(data_type)))
    ) |>
      layout(plot_bgcolor='white',
             xaxis = list(
               zerolinecolor = '#ffff',
               zerolinewidth = 2,
               gridcolor = 'ffff'),
             yaxis2 = list(
               zeroline = TRUE,
               zerolinecolor = 'ffff',
               zerolinewidth = 2,
               gridcolor = 'ffff',
               showgrid = FALSE),
              yaxis = list(
                zeroline = TRUE,
                zerolinecolor = '#f0f0f0',
                zerolinewidth = 1,
                gridcolor = '#f0f0f0',
                griddash = 'solid',
                gridwidth = 1,showgrid = T),
             margin = list(t = 10, l = 20, r = 70, b = 20, pad = 4),
             autosize = T
      )
    fig <- fig |> layout(hovermode = 'x unified')
    fig4 = fig
    
    return(list(gain_loss = fig1, net = fig2, trend = fig3, trend_and_net = fig4))
    
  }
}

proportional_plots_turnover <- function(turnover,
                                        overall_turnover,
                                        collection_proportion,
                                        separate_figure_folder, 
                                        report_kind,
                                        text = '',
                                        data_type = 'items',
                                        quantity = ''){
  if(report_kind == 'static'){
    # Gain
    plot_data = data.frame(year = turnover[,1],
                           specific = turnover[,2], 
                           all = overall_turnover[,2])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_gain = plot_data
    p = ggplot(plot_data, aes(y=prop_specific, x=year)) + 
      geom_bar(stat="identity", width = 1, fill = 'lightblue', col = 'black') +
      geom_point(aes(x = year, y = prop_specific_collection))+
      labs(title=paste0("Proportion of gained ",data_type," that are ",text," in the LC"),
           x ="Year",
           y = "Percentage (%)") +
      # theme(text = element_text(size=table_font_size)) +
      labs(caption = paste0("Black points are proportion of ",data_type," in the LC that are ",text," each year."))
    p1 = p
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/',stringr::str_replace_all(text,' ','_'),'_gain_',data_type,'_proportion.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
    
    ### Plot of proportion of lost items being native.
    
    plot_data = data.frame(year =  turnover[,1],
                           specific = turnover[,3], 
                           all = overall_turnover[,3])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_loss = plot_data
    
    p = ggplot(plot_data, aes(y=prop_specific, x=year)) + 
      geom_bar(stat="identity", width = 1, fill = 'pink', col = 'black') +
      geom_point(aes(x = year, y = prop_specific_collection))+
      # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
      labs(title=paste0("Proportion of lost ",data_type," that are ",text," in the LC"),
           x ="Year",
           y = "Percentage (%)") +
      # theme(text = element_text(size=table_font_size)) +
      labs(caption = paste0("Black points are proportion of ",data_type," in the LC that are ",text," each year."))
    
    if(separate_figure_folder){
      ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/',stringr::str_replace_all(text,' ','_'),'_loss_',data_type,'_proportion.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
    
    return(list(gain = p1, loss = p, data_gain = plot_data_gain, data_loss = plot_data_loss))
  }
  if(report_kind =='interactive'){
    # Gain
    plot_data = data.frame(year = turnover[,1],
                           specific = turnover[,2], 
                           all = overall_turnover[,2])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_gain = plot_data
    fig = plot_ly(plot_data, x = ~year, y = ~prop_specific, type = 'bar',
                  name = paste0('New accessions'),
                  marker = list(color = color_binary[2]),
                  hovertemplate = paste("%{y:.2f}% of new accessions <extra></extra>")
                  )
                  
    fig <- fig |> layout(yaxis = list(title = paste0("Percentage")),
                         xaxis = list(title = "Year"))
    fig <- fig |> add_trace(x = ~year, y = ~prop_specific_collection, type = 'scatter', mode = 'lines+markers',
                            name = paste0('Collection'),
                            marker = list(color = 'black'),
                            line = list(color = 'black'),
                             hovertemplate = paste("%{y:.2f}% of the collection <extra></extra>")
                            )
    fig <- fig |> layout(hovermode = 'x unified',
                         yaxis = list(ticksuffix = '%'),
                         xaxis = list(hoverformat = paste0('fvf')),
                         legend=list(title=list(text=paste0('<b>',text |> stringr::str_to_sentence(), '</b>'))))
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Line_Bar-Proportion_of_gained_',stringr::str_replace_all(text, ' ', '_'),'_',data_type,'.html'))
    }
    
    fig1 = fig
    
    ### Plot of proportion of lost items being native.
    
    plot_data = data.frame(year =  turnover[,1],
                           specific = turnover[,3], 
                           all = overall_turnover[,3])
    plot_data$prop_specific = round(plot_data$specific / plot_data$all *100,digits=2)
    plot_data$prop_specific_collection = collection_proportion*100
    plot_data_loss = plot_data
    
    fig = plot_ly(plot_data, x = ~year,
                  y = ~prop_specific,
                  type = 'bar',
                  name = paste0('Lost accessions'),
                  marker = list(color = color_binary[1]),
                  hovertemplate = paste("%{y:.2f}% of lost accessions <extra></extra>"))
    fig <- fig |> layout(yaxis = list(title = paste0("Percentage")),
                         xaxis = list(title = "Year"))
    fig <- fig |> add_trace(x = ~year,
                            y = ~prop_specific_collection,
                            type = 'scatter',
                            mode = 'lines+markers',
                            name = paste0('Collection'),
                            marker = list(color = 'black'),
                            line = list(color = 'black'),
                            hovertemplate = paste("%{y:.2f}% of the collection<extra></extra>"))
    fig <- fig |> layout(hovermode = 'x unified',
                         yaxis = list(ticksuffix = '%'),
                         legend=list(title=list(text=paste0('<b>',text |> stringr::str_to_sentence(), '</b>'))))
    
    if(separate_figure_folder){
      htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Line_Bar-Proportion_of_lost_',stringr::str_replace_all(text, ' ', '_'),'_',data_type,'.html'))
    }
    
    return(list(gain = fig1, loss = fig,  data_gain = plot_data_gain, data_loss = plot_data_loss))
    
  }
}
```

```{r, region names}

level_2 = c("10, 11, 12, 13, 14, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 50, 51, 60, 61, 62, 63, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 90, 91, Northern Europe, Middle Europe, Southwestern Europe, Southeastern Europe, Eastern Europe, Northern Africa, Macaronesia, West Tropical Africa, West-Central Tropical Africa, Northeast Tropical Africa, East Tropical Africa, South Tropical Africa, Southern Africa, Middle Atlantic Ocean, Western Indian Ocean, Siberia, Russian Far East, Middle Asia, Caucasus, Western Asia, Arabian Peninsula, China, Mongolia, Eastern Asia, Indian Subcontinent, Indo-China, Malesia, Papuasia, Australia, New Zealand, Southwestern Pacific, South-Central Pacific, Northwestern Pacific, North-Central Pacific, Subarctic America, Western Canada, Eastern Canada, Northwestern U.S.A., North-Central U.S.A., Northeastern U.S.A., Southwestern U.S.A., South-Central U.S.A., Southeastern U.S.A., Mexico, Central America, Caribbean, Northern South America, Western South America, Brazil, Southern South America, Subantarctic Islands, Antarctic Continent")
level_1 = c("1, 2, 3, 4, 5, 6, 7, 8, 9, Europe, Africa, Asia-Temperate, Asia-Tropical, Australasia, Pacific, Northern America, Southern America, Antarctic")

level_2 = data.frame(matrix(unlist(stringr::str_split(level_2, ', ')), ncol = 2))
names(level_2) = c('code', 'name') ; level_2$code = as.numeric(level_2$code)

level_1 = data.frame(matrix(unlist(stringr::str_split(level_1, ', ')), ncol = 2))
names(level_1) = c('code', 'name') ; level_1$code = as.numeric(level_1$code)

```

```{r theme_ggplot2}
library(ggplot2)

# Changing the default theme
if(is.null(ggtheme)){
  ggtheme <- function(base_size = 16) {
    ggplot2::theme_bw(base_size = base_size) %+replace%
      ggplot2::theme(
        plot.title = ggplot2::element_text(size = rel(1), face = "bold", margin = margin(0,0,5,0), hjust = 0),
        panel.grid.minor = ggplot2::element_blank(),
        panel.border = ggplot2::element_blank(),
        axis.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
        axis.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
        axis.line = ggplot2::element_line(color = "black"),
        legend.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
        legend.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
        legend.key = ggplot2::element_rect(fill = "transparent", colour = NA),
        legend.key.size = ggplot2::unit(1.5, "lines"),
        legend.background = ggplot2::element_rect(fill = "transparent", colour = NA),
        strip.background = ggplot2::element_rect(fill = "#17252D", color = "#17252D"),
        strip.text = ggplot2::element_text(size = rel(0.85), face = "bold", color = "white", margin = margin(5,0,5,0))
      )
  }
}
theme_set(ggtheme())
update_geom_defaults("line", list(size = 2))

# Set the colour scale for the plots
scale_colour_continuous <- scale_colour_continuous
scale_colour_discrete   <- scale_colour_discrete
scale_colour_binned     <- scale_colour_binned
scale_fill_continuous <- scale_fill_continuous
scale_fill_discrete <- scale_fill_discrete
scale_fill_binned <- scale_fill_binned
```

```{r, Add combined geography column to enriched report}
geography_data = enriched_report[,grepl('_area_code_l3', names(enriched_report))]
want = c('000','010','001','011','100','110','101')

#Depending on the values of the options reduce `want` to only the satisfactory values.
##A) introduced / naturally occurring only.
if(native == 'Introduced only'){
  want = want[grepl('^1',want)]
}else if(native == 'Naturally occurring only'){
  want = want[grepl('^0',want)]
}
## B) Extinct
if(!extinct){
  want = want[!grepl('010|011|110',want)]
}
## C) Doubtful
if(!doubtful_locations){
  want = want[!grepl('001|011|101',want)]
}
geog_want_values = want
# Get the columns in wanted info that contain the geography information we want.
geography_data = geography_data[,grepl(paste0(want,collapse='|'), names(geography_data))]

if(length(want) > 1){
  level3codes =do.call("paste", c(geography_data, sep = ", "))
  level3codes = stringr::str_remove(level3codes, ', NA$')
  level3codes = stringr::str_remove(level3codes, 'NA, ')
}else{
  level3codes = geography_data
}
level3codes[level3codes == "NA"] = NA

enriched_report$geography_codes = level3codes
```

```{r, Get location_type_text}
location_type_text = ''
if(native == 'Naturally occurring only'){
  location_type_text = paste0(location_type_text, 'naturally occurring only,', collapse = ' ')  
}else if(native == 'Introduced only'){
  location_type_text = paste0(location_type_text, 'introduced only,', collapse = ' ')  
  
}else{
  location_type_text = paste0(location_type_text, 'Either naturally occurring or introduced,', collapse = ' ')  
}
if(extinct){
  location_type_text = paste0(location_type_text, ' allowing extinct regions and', collapse = ' ')  
}else{
  location_type_text = paste0(location_type_text, ' not including extinct regions and', collapse = ' ')  
}
if(doubtful_locations){
  location_type_text = paste0(location_type_text, ' allowing doubtful regions.', collapse = ' ')  
  
}else{
  location_type_text = paste0(location_type_text, ' not allowing doubtful regions.', collapse = ' ')  
}
```

`r if(any(! c('AccNoFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"*** \n **Warning!**\n\n This enriched report contains missing 'original' columns needed to perform the analyses in this report. Default values have been created. In particular, the following were missing "}`

`r if(!'AccNoFull' %in% names(enriched_report)){"- AccNoFull: assume each item is its own accession.\n"}`
`r if(!'AccYear' %in% names(enriched_report)){"- AccYear: Cannot do analyses over time.\n"}`
`r if(!'ItemStatusDate' %in% names(enriched_report)){"- AccNoFull: Cannot do analyses over time.\n"}`
`r if(!'ItemStatusType' %in% names(enriched_report)){"- AccNoFull: Cannot do analyses over time.\n"}`

`r if(any(! c('AccNoFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"***"}`

```{r, Find LC location}
coord_contained = TRUE
# Extract the location of the collection.
pnts <- data.frame( x = coordinates[2], y = coordinates[1])

# create a points collection
pnts_sf <- do.call("st_sfc",c(lapply(1:nrow(pnts), 
                                     function(i) {sf::st_point(as.numeric(pnts[i, ]))}), list("crs" = 4326))) 

pnts_trans <- st_transform(pnts_sf, 2163) # apply transformation to pnts sf
tt1_trans <- st_transform(wgsrpd3, 2163)      # apply transformation to polygons sf

intersect = as.vector(st_intersects(tt1_trans, pnts_trans, sparse = FALSE))
collection_geog_details = wgsrpd3[which(intersect),-5]
location_name = collection_geog_details$LEVEL3_NAM
location_code = collection_geog_details$LEVEL3_COD

if(length(location_name) == 0){
  coord_contained = FALSE
  # Try and find the nearest polygon.
  collection_geog_details  =  wgsrpd3[which.min(as.vector(sf::st_distance(tt1_trans, pnts_trans))),-5]
  location_name = collection_geog_details$LEVEL3_NAM
  location_code = collection_geog_details$LEVEL3_COD
}
```


```{r, Extracting information from enriched report, echo = F}
#Â Add required columns if missing.
do_over_time = TRUE
needed_columns = c('AccNoFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType')
if(!'AccNoFull' %in% names(enriched_report)){
  enriched_report$AccNoFull = 1:nrow(enriched_report)
}
if(!'AccYear' %in% names(enriched_report)){
  do_over_time = FALSE
  enriched_report$AccYear = rep(0, nrow(enriched_report))
}
if(!'ItemStatusDate' %in% names(enriched_report)){
  do_over_time = FALSE
  enriched_report$ItemStatusDate = rep(NA, nrow(enriched_report))
}
if(!'ItemStatusType' %in% names(enriched_report)){
  do_over_time = FALSE
  enriched_report$ItemStatusType = rep('Existing', nrow(enriched_report))
}
if(all(is.na(enriched_report$ItemStatusDate))){
  do_over_time = FALSE
}
if(all(is.na(enriched_report$ItemStatusType))){
  do_over_time = FALSE
}
if(all(is.na(enriched_report$AccYear))){
  do_over_time = FALSE
}

#Extract endemic information from enriched_report
endemic = rep('Widespread', nrow(enriched_report))
endemic_index = which(stringr::str_length(enriched_report$geography_codes) == 3)
endemic[endemic_index] = 'Endemic'
enriched_report$endemic = endemic
rm(endemic)

#Extract endemic information from enriched_report
tree = rep('Not tree', nrow(enriched_report))
tree_index = which(enriched_report$Enrich_is_tree)
tree[tree_index] = 'Tree'
enriched_report$tree = tree
rm(tree)

# Extract threatened. 
threat_cat = c('VU','EN','CR','EW','EX')
threatened = rep('Not Threatened', nrow(enriched_report))
threatened[which(enriched_report$redList_category %in% threat_cat)] = 'Threatened'
threatened[which(enriched_report$POWO_Red_category %in% threat_cat)] = 'Threatened'
enriched_report$threatened = threatened
rm(threatened)

# Extract threatened category. 
threatened_category = rep(NA, nrow(enriched_report))
for(i in 1:length(threat_cat)){
  threatened_category[which(enriched_report$redList_category == threat_cat[i])] = threat_cat[i]
  threatened_category[which(enriched_report$POWO_Red_category == threat_cat[i])] = threat_cat[i]
}
enriched_report$threatened_category = threatened_category
rm(threatened_category)

# Convert Provenance code to text.
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'G'] = 'Garden'
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'U'] = 'Unknown'
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'W'] = 'Wild'
enriched_report$ProvenanceCode[enriched_report$ProvenanceCode == 'Z'] = 'Wild-derived'

# Add native column.
nativeo = rep('Non-native', nrow(enriched_report))
native_index = which(grepl(location_code, enriched_report$geography_codes))
nativeo[native_index] = 'Native'
enriched_report$native = nativeo
rm(nativeo)

LossYear = rep(NA,nrow(enriched_report))
ItemStatusYear = as.numeric(stringr::str_extract(enriched_report$ItemStatusDate,pattern = '[0-9]{4}'))
LossYear[enriched_report$ItemStatusType == 'NotExisting'] = ItemStatusYear[enriched_report$ItemStatusType == 'NotExisting']
enriched_report$LossYear = LossYear

# Create a sanitised taxonomic name.
enriched_report$good_name = paste0(enriched_report$sanitised_taxon, ' ', enriched_report$extracted_author)

best_name = paste0(enriched_report$POWO_taxon_name, ' ', enriched_report$POWO_taxon_authors)
best_name[which(best_name == 'NA NA')] = enriched_report$good_name[which(best_name == 'NA NA')]
enriched_report$best_name = best_name


report_original = enriched_report

if(separate_figure_folder){
  figures_dir = paste0(output_dir,'/',collection,'_Figures')
  dir.create(figures_dir,showWarnings = FALSE)
}

exporting_data_store = list()
```

###### {-} 

This report explores the trees in **`r collection`**.

A taxon in the collection is classed as a **tree** if it's genus species pair is found within [BGCI's GlobalTreeSearch](https://tools.bgci.org/global_tree_search.php), or if the matched accepted POWO taxonomic name is found within BGCI's GlobalTreeSearch.

<!-- Note that in this document we will show the geographic area that trees in the LC belong to. To determine the geographic distribution of items in the living collection we enrich with information from [Plants of the World Online](https://powo.science.kew.org), by matching taxonomic names. POWO uses [TDWG geographical codes](https://www.tdwg.org/standards/wgsrpd/) (Brummitt, 2001) expressed to that system's third level. This splits the world into 369 regions. Thus, each accepted name in POWO is associated with a list of geographic regions. POWO splits the geographic regions associated with a taxa by three conditions: -->

<!-- - Native / introduced, -->
<!-- - Extinct / Not extinct, -->
<!-- - Location is doubtful / otherwise. -->

<!-- This document considers locations that are: `r location_type_text`  -->
 
```{r get tree only information}
Tree = enriched_report[which(enriched_report$Enrich_is_tree),]

# Tree must match to POWO so no naming issues.
Tree_existing = Tree[Tree$ItemStatusType == 'Existing',] 
no_Tree_items_existing = nrow(Tree_existing)
no_Tree_accessions_existing = length(unique(Tree_existing$AccNoFull))
no_Tree_species_existing = length(unique(paste0(Tree_existing$POWO_genus, ' ', Tree_existing$POWO_species)))
no_Tree_taxa_existing = length(unique(paste0(Tree_existing$POWO_taxon_name, ' ', Tree_existing$POWO_taxon_authors)))

# For all items we need to be more careful. Items and accessions are fine. 
# For species and taxa only consider those that have matched to POWO. 
LC_existing = enriched_report[enriched_report$ItemStatusType == 'Existing',]
no_LC_items_existing = nrow(LC_existing)
no_LC_accessions_existing = length(unique(LC_existing$AccNoFull))
no_LC_species_existing = length(unique(paste0(LC_existing$POWO_genus, ' ', LC_existing$POWO_species)))
no_LC_species_existing = no_LC_species_existing - sum(any(is.na(LC_existing$POWO_genus)))
no_LC_taxa_existing = length(unique(paste0(LC_existing$POWO_taxon_name, ' ', LC_existing$POWO_taxon_authors)))
no_LC_taxa_existing = no_LC_taxa_existing - sum(any(is.na(LC_existing$POWO_genus)))


category = c('Items', 'Accessions', 'Species', 'Taxa')
Tree_values = c(no_Tree_items_existing, no_Tree_accessions_existing, no_Tree_species_existing, no_Tree_taxa_existing)
LC_values  = c(no_LC_items_existing, no_LC_accessions_existing, no_LC_species_existing, no_LC_taxa_existing)
proportion = paste0(round(Tree_values/LC_values*100, digits = 2),'%')

Tree_count_table = data.frame(category, LC_values, Tree_values, proportion)
names(Tree_count_table) = c('', 'All plants', 'Trees', 'Proportion')
if(export_data){
  exporting_data_store$Tree_count_table = Tree_count_table
}

### Over time information
### A) Tree
year_cur = as.numeric(format(Sys.Date(), '%Y'))
years = max(min_year, min(enriched_report$AccYear[enriched_report$AccYear > 1650],na.rm = T)) :year_cur
dates = paste0(years,'-01-01')
Tree_existing_each_year = BGSmartR::exist_at_date(date = dates,
                                                     AccessionYear = as.character(Tree$AccYear),
                                                     ItemStatusDate = as.character(Tree$ItemStatusDate),
                                                     ItemStatusType = as.character(Tree$ItemStatusType))

# Get the number of items accession taxa species for Tree plants in the LC.
over_time_info = lapply(Tree_existing_each_year, function(x){
  garden_current = Tree[x,]
  
  # Get the values of interest.
  no_items = nrow(garden_current)
  no_accessions = length(unique(garden_current$AccNoFull))
  no_taxa = length(unique(garden_current$TaxonNameFull))
  no_species = length(unique(paste0(garden_current$POWO_taxon_name, garden_current$POWO_taxon_authors)[!is.na(garden_current$POWO_plant_name_id)]))
  
  return(c(no_items, no_accessions, no_taxa, no_species))
}) |>
  data.frame() |>
  t() |> 
  data.frame()
names(over_time_info) = c('Items', 'Accessions', 'Taxa', 'Species')
over_time_info = data.frame(Date = dates, over_time_info)
row.names(over_time_info) = 1:nrow(over_time_info)
Tree_over_time = over_time_info

if(export_data){
  exporting_data_store$Number_of_Tree_species_in_LC_over_time = Tree_over_time
}

### B) Whole LC.
# Do the same for the whole collection.
report = enriched_report
report = report[report$AccYear > 1650 & report$AccYear<=year_cur,]
report = report[!is.na(report$ItemStatusDate),]
plant_existing = BGSmartR::exist_at_date(dates, AccessionYear = as.character(report$AccYear),
                                         ItemStatusDate = as.character(report$ItemStatusDate),
                                         ItemStatusType = as.character(report$ItemStatusType))

# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing, function(x){
  garden_current = report[x,]
  
  # Get the values of interest.
  no_items = nrow(garden_current)
  no_accessions = length(unique(garden_current$AccNoFull))
  no_taxa = length(unique(garden_current$TaxonNameFull))
  no_species = length(unique(paste0(garden_current$POWO_taxon_name, garden_current$POWO_taxon_authors)[!is.na(garden_current$POWO_plant_name_id)]))
  
  return(c(no_items, no_accessions, no_taxa, no_species))
}) |>
  data.frame() |>
  t() |> 
  data.frame()
names(over_time_info) = c('Items', 'Accessions', 'Taxa', 'Species')
over_time_info = data.frame(Date = dates, over_time_info)
row.names(over_time_info) = 1:nrow(over_time_info)
LC_data = over_time_info

if(export_data){
  exporting_data_store$Total_counts_of_LC_over_time = LC_data
}

### MANAGEMENT SHEET: All existing Tree accessions.
Tree_accessions = Tree_existing
Tree_accessions = Tree_accessions[match(unique(Tree_accessions$AccNoFull),Tree_accessions$AccNoFull),]
powo_name = paste0(Tree_accessions$POWO_taxon_name, ' ', Tree_accessions$POWO_taxon_authors)
powo_name[powo_name == 'NA NA'] = NA
Tree_accessions$powo_name = powo_name
Tree_accessions = Tree_accessions[,match(c('AccNoFull', 'TaxonNameFull', 'powo_name', 'Enrich_is_tree', 'threatened', 'endemic', 'geography_codes', 'ProvenanceCode', 'no_gardens'), names(Tree_accessions))]
names(Tree_accessions) = c('Accession Number', 'Original Taxonomic Name and Author', 'POWO Taxonomic Name and Author', 'Tree', 'Threatened', 'Endemic', 'Geography', 'Provenance', 'Number of Global Collections Held in')
writexl::write_xlsx(Tree_accessions, path =paste0(output_dir,'/',collection,'_Tree_accessions_list.xlsx'))


```

### Tree collection size

In the living collection there are `r format(no_Tree_items_existing, big.mark=',')` items corresponding to  `r format(no_Tree_accessions_existing, big.mark=',')` accessions of existing trees. The number of trees existing in the living collection is summarised below.

```{r, How many native species are in the LC - table}
if(report_kind == 'static'){
  Tree_count_table |>
    flextable() |>
    set_caption(caption = "Tree plants in the LC") |> 
    font(fontname = "Calibri (Body)", part = "all") |> 
    fontsize(size = table_font_size, part = "body") |> 
    # add footer if you want
    # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
    #                colwidths = 4) |> 
    theme_booktabs() |> # default theme
    autofit()
}
if(report_kind == 'interactive'){
  Tree_count_table |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(Tree_count_table), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=F,
                                 ordering=F))
}

```

***

### Change in trees over time

In this section we explore how the number of trees in the living collection has varied over time.

```{r, What proportion of the LC at `r collection` is Tree and how has this varied over time - static number figures, eval = report_kind == 'static' & do_over_time,  fig.fullwidth=TRUE, fig.dim = c(10, 6)}
to_do = c('Items', 'Accessions', 'Taxa', 'Species')
titles = c('items', 'accessions', 'taxa', 'species')
for(i in 1:length(to_do)){
  counts = Tree_over_time[,match(to_do[i], names(Tree_over_time))]
  plot_data = data.frame(date = years, counts = counts)
  
  p = ggplot(data=plot_data, aes(x=date, y=counts)) +
    geom_line()+
    geom_point() +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title=paste0("Number of Tree ", titles[i] , " over time"),
         x ="Year",
         y = paste0("Number of ",titles[i])) #+
  # guides(fill=guide_legend(title=paste0("", titles[i]))) +
  # theme(text = element_text(size=table_font_size))
  
  if(separate_figure_folder){
    ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','number_Tree_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
  }
  
  print(p)
}
```

`r if(report_kind == 'interactive' & do_over_time){"#####  {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Items"}`
```{r  Number of Tree items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
number_over_time <- function(data, type, title){
counts = data[,match(type, names(data))]
plot_data = data.frame(date = years, counts = counts)

fig <- plot_ly(plot_data, x = ~date, y = ~counts, type = 'scatter', mode = 'lines+markers', line = list(color = interactive_colour(1)), marker = list(color = interactive_colour(1)))

fig <- fig |> layout(yaxis = list(title = paste0("Number of ",title)),
                   xaxis = list(title = "Year"))
fig <- fig |> layout(hovermode = 'x unified')
return(fig)
}
fig = number_over_time(data = Tree_over_time, type = 'Items', title = 'items')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','number_of_Tree_items_over_time.html'))
}

fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Accessions"}`
```{r  Number of Tree accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = number_over_time(data = Tree_over_time, type = 'Accessions', title = 'accessions')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','number_of_Tree_accessions_over_time.html'))
}

fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Taxa"}`
```{r  Number of Tree taxa over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = number_over_time(data = Tree_over_time, type = 'Taxa', title = 'taxa')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','number_of_Tree_taxa_over_time.html'))
}

fig

```

`r if(report_kind == 'interactive' & do_over_time){"###### Species"}`
```{r  Number of Tree species over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = number_over_time(data = Tree_over_time, type = 'Species', title = 'species')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','number_of_Tree_species_over_time.html'))
}

fig
```

`r if(report_kind == 'interactive' & do_over_time){"##### {-}"}`

`r if(do_over_time){"Next we view trees in the living collection as a percentage of all plants over time."}`

```{r, What proportion of the LC at `r collection` is Tree and how has this varied over time - percentage data, eval = do_over_time}
# Do the same for the whole collection.
report = report_original
report = report[report$AccYear > 1650 & report$AccYear<=year_cur,]
report = report[!is.na(report$ItemStatusDate),]
date = paste0(years,'-01-01')
plant_existing = BGSmartR::exist_at_date(date, AccessionYear = as.character(report$AccYear),
                       ItemStatusDate = as.character(report$ItemStatusDate),
                       ItemStatusType = as.character(report$ItemStatusType))

# For each year get the number in each group (species and genera)
over_time_info = lapply(plant_existing, function(x){
    garden_current = report[x,]
    
    # Get the values of interest.

    no_items = nrow(garden_current)
    no_accessions = length(unique(garden_current$AccNoFull))
    no_taxa = length(unique(garden_current$TaxonNameFull))
    no_species = length(unique(paste0(garden_current$POWO_taxon_name, garden_current$POWO_taxon_authors)[!is.na(garden_current$POWO_plant_name_id)]))

    return(c(no_items, no_accessions, no_taxa, no_species))
}) |>
                  data.frame() |>
                  t() |> 
                  data.frame()
names(over_time_info) = c('Items', 'Accessions', 'Taxa', 'Species')
over_time_info = data.frame(Date = date, over_time_info)
row.names(over_time_info) = 1:nrow(over_time_info)
LC_data = over_time_info

if(export_data){
  exporting_data_store$Total_species_in_LC_over_time = LC_data
}
```

```{r, What proportion of the LC at `r collection` is Tree and how has this varied over time - static percentage figures, eval = report_kind == 'static' & do_over_time, fig.fullwidth=TRUE, fig.dim = c(10, 6)}
to_do =  c('Items', 'Accessions', 'Taxa', 'Species')
titles = c('items', 'accessions', 'taxa', 'species')

# Loop over to_do.
for(i in 1:length(to_do)){
  Tree_counts = Tree_over_time[,match(to_do[i], names(Tree_over_time))]
  total_counts = LC_data[,match(paste0(to_do[i]), names(LC_data))]
  
  percent = round(Tree_counts/total_counts*100, digits = 3)
  
  plot_dataA = data.frame(date =years, 
                          percent = percent,
                          represented = rep('Tree', length(date)))
  plot_dataB = data.frame(date =years, 
                          percent = 100-percent,
                          represented = rep('Widespread', length(date)))
  
  plot_data = rbind(plot_dataA, plot_dataB)
  plot_data$represented = factor(plot_data$represented,levels = c('Widespread','Tree'))
  
  names(plot_data) = c('dates', 'percentage', 'represented')
  
  p = ggplot(plot_data, aes(fill=represented, y=percentage, x=dates)) + 
    geom_bar(position="stack", stat="identity", width = 1) +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title=paste0("Proportion of ", titles[i] , " that are Tree in the LC over time"),
         x ="Year",
         y = "Percentage (%)") +
    guides(fill=guide_legend(title=paste0("", titles[i]))) +
    scale_fill_discrete() # +
  # theme(text = element_text(size=table_font_size))
  
  if(separate_figure_folder){
    ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','proportion_Tree_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
  }
  
  print(p)
}


```

`r if(report_kind == 'interactive' & do_over_time){"#####  {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Items"}`
```{r  Proportion of Tree items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
proportion_plot <- function(data, LC_data, type, title){
  native_counts = data[,match(type, names(data))]
  total_counts = LC_data[,match(paste0(type), names(LC_data))]

  percent = round(native_counts/total_counts*100, digits = 3)
  

  # Line graph of only the native plants. 
  plot_data = data.frame(date =years, 
                               percent = percent
                               )
  fig <- plot_ly(plot_data, x = ~date, y = ~percent, type = 'scatter', mode = 'lines+markers', line = list(color = interactive_colour(1)), marker = list(color = interactive_colour(1)))

fig <- fig |> layout(yaxis = list(title = paste0("Percentage of ",title)),
                   xaxis = list(title = "Year"))
fig <- fig |> layout(hovermode = 'x unified',
                     yaxis = list(ticksuffix  ='%', hoverformat = '.1f'))
  

  # Stacked Bar version. 
   # plot_dataA = data.frame(date =years, 
   #                             percent = percent,
   #                             represented = rep('Native', length(date)))
   # 
  # plot_dataB = data.frame(date =years, 
  #                            percent = 100-percent,
  #                             represented = rep('Non-Native', length(date)))
  
  # plot_data = rbind(plot_dataA, plot_dataB)
  # plot_data$represented = factor(plot_data$represented, levels = c('Native', 'Non-Native'))
  # fig <- plot_ly(plot_data, x = ~date, y = ~percent, color = ~represented, type = 'bar', colors = interactive_colour(2))
  # fig <- fig |> layout(yaxis = list(title = paste0('Percentage of ',title)),
  #                      xaxis = list(title = "Year"),
  #                      legend=list(title=list(text=paste0("Native ", title))),
  #                      barmode = 'stack',
  #                      hoverlabel = list(namelength = -1))
  # fig <- fig |> layout(hovermode = 'x unified',
  #                      bargap =0,
  #                      yaxis = list(ticksuffix  ='%', hoverformat = '.1f')
                       
return(fig)
}

fig = proportion_plot(data = Tree_over_time, LC_data = LC_data, type = 'Items', title = 'items')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','percentage_of_Tree_items_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Accessions"}`
```{r  Proportion of Tree accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = proportion_plot(data = Tree_over_time, LC_data = LC_data, type = 'Accessions', title = 'accessions')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','percentage_of_Tree_accessions_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Taxa"}`
```{r  Proportion of Tree taxa over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = proportion_plot(data = Tree_over_time, LC_data = LC_data, type = 'Taxa', title = 'taxa')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','percentage_of_Tree_taxa_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"###### Species"}`
```{r  Proportion of Tree species over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_over_time}
fig = proportion_plot(data = Tree_over_time, LC_data = LC_data, type = 'Species', title = 'species')

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','percentage_of_Tree_species_over_time.html'))
}
  
fig
```

`r if(report_kind == 'interactive' & do_over_time){"##### {-}"}`

***

### Geographic coverage of trees 

```{r check if we are given the number of accepted species or endemic species}
All_locations = wgsrpd3$LEVEL3_COD
# if(!is.null(wcvp) & (is.null(accepted_species_per_region) | is.null(endemic_species_per_region))){
   geography_data = wcvp$geography[,grepl('_area_code_l3', names(wcvp$geography))]
  want = c('000','010','001','011','100','110','101')

  #Depending on the values of the options reduce `want` to only the satisfactory values.
  ##A) introduced / naturally occurring only.
  if(native == 'Introduced only'){
    want = want[grepl('^1',want)]
  }else if(native == 'Naturally occurring only'){
    want = want[grepl('^0',want)]
  }
  ## B) Extinct
  if(!extinct){
    want = want[!grepl('010|011|110',want)]
  }
  ## C) Doubtful
  if(!doubtful_locations){
    want = want[!grepl('001|011|101',want)]
  }
  geog_want_values = want
  # Get the columns in wanted info that contain the geography information we want.
  geography_data = geography_data[,grepl(paste0(geog_want_values,collapse='|'), names(geography_data))]

  # If multiple columns join the strings such that each contains only a single list of regions.
  if(length(geog_want_values) > 1){
    level3codes =do.call("paste", c(geography_data, sep = ", "))
    level3codes = stringr::str_remove(level3codes, ', NA$')
    level3codes = stringr::str_remove(level3codes, 'NA, ')
  }else{
    level3codes = geography_data
  }
  level3codes[level3codes == "NA"] = NA

  wcvp_geography = data.frame(id = wcvp$geography$plant_name_id,
                              codes = level3codes)

  #Next we need to extract all the plant name ids from wcvp that are  accepted
  plant_ids = wcvp$wcvp_names$plant_name_id[wcvp$wcvp_names$taxon_status %in% c('Accepted')& !is.na(wcvp$wcvp_names$species)]

  # reduce wcvp_geography to only accepted plant name ids. (Note that usually only accepted plants have geography so this won't actually remove many records)
  wcvp_geography = wcvp_geography[wcvp_geography$id %in% plant_ids,]
  if(!exists('accepted_species_per_region')){
    no_accepted_species_wcvp = unlist(lapply(All_locations, function(x){
    sum(grepl(x, wcvp_geography$codes))}))
    
    accepted_species_per_region = data.frame(code = All_locations, no_accepted_taxa_wcvp = no_accepted_species_wcvp)
  }
  

  # Reduce to only endemic plants.
  wcvp_geography_endemic = wcvp_geography[stringr::str_length(wcvp_geography$codes) == 3,]

    if(!exists('endemic_species_per_region')){
      no_endemic_accepted_species_wcvp = unlist(lapply(All_locations, function(x){
    sum(grepl(x, wcvp_geography_endemic$codes))
  }))
  endemic_species_per_region = data.frame(code = All_locations, no_endemic_accepted_species_wcvp = no_endemic_accepted_species_wcvp)
  }

  # Reduce to only trees.
  wcvp_geography_tree = wcvp_geography[which(wcvp_geography$id %in% (wcvp$trees |> unlist() |> as.numeric())), ]
   if(!exists('trees_per_region')){
      no_trees_accepted_species_wcvp = unlist(lapply(All_locations, function(x){
    sum(grepl(x, wcvp_geography_tree$codes))
  }))
  tree_species_per_region = data.frame(code = All_locations, no_trees_accepted_species_wcvp = no_trees_accepted_species_wcvp)
   }
  
# }
```


```{r trees Species map -  data}
# Get all BRU level 3 location codes.
All_locations = wgsrpd3$LEVEL3_COD

wanted_info = Tree_existing
wanted_info_species = wanted_info[match(unique(wanted_info$best_name), wanted_info$best_name),]



#Get the number of species for each location.
no_tree_items = unlist(lapply(All_locations, function(x){
  sum(grepl(x, wanted_info$geography_codes))
}))
#Get the number of species for each location.
no_tree_species = unlist(lapply(All_locations, function(x){
  sum(grepl(x, wanted_info_species$geography_codes))
}))


# Combine the wanted information into location data.
location_data = data.frame(code =  wgsrpd3$LEVEL3_COD,
                           name = wgsrpd3$LEVEL3_NAM,
                           rep_tree = no_tree_items > 0,
                           no_tree_items = no_tree_items,
                           no_tree_species = no_tree_species
)

location_data$name = stringr::str_replace(location_data$name, 'Is\\.', 'Islands')
location_data$name = stringr::str_replace(location_data$name, 'I\\.', 'Island')

# If we are given wcvp calculate the number of endemic species that each geographic area contains.
if(!is.null((tree_species_per_region))){
  no_tree_accepted_species_wcvp = tree_species_per_region[,2][match(location_data$code,tree_species_per_region[,1])]
  location_data$no_tree_accepted_wcvp_species = no_tree_accepted_species_wcvp
}

if(!is.null(wcvp)){
  
  ## Which regions do we have 0 endemic items (when species exist in wcvp)
  missing_regions = location_data[which(location_data$no_tree_items == 0 & location_data$no_tree_accepted_wcvp_species !=0), match(c('name', 'code', 'no_tree_accepted_wcvp_species'), names(location_data))]
  
  if(nrow(missing_regions) > 0){
    
  }
  wgsrpd3$LEVEL1_COD[match(missing_regions$code,wgsrpd3$LEVEL3_COD)]
  level_1_names = level_1$name[match(wgsrpd3$LEVEL1_COD[match(missing_regions$code,wgsrpd3$LEVEL3_COD)], level_1$code)]
  level_2_names = level_2$name[match(wgsrpd3$LEVEL2_COD[match(missing_regions$code,wgsrpd3$LEVEL3_COD)], level_2$code)]
  missing_regions = data.frame(missing_regions$name, level_2_names, level_1_names, missing_regions$no_tree_accepted_wcvp_species)
  
  
  names(missing_regions) = c('Region', 'Level 2 region','Level 1 region', 'Number of Trees')
  missing_regions = missing_regions[order(missing_regions$`Number of Trees`, decreasing = T),]
  
  # Create a data frame of the missing trees from wcvp.
  codes = location_data[which(location_data$no_tree_items == 0 & location_data$no_tree_accepted_wcvp_species !=0), match(c('code'), names(location_data))]
  
  ids = wcvp_geography$id[grep(paste0(codes, collapse = '|'),wcvp_geography$codes)]
  ids = ids[which(ids %in% (wcvp$trees |> unlist() |> as.numeric()))]
  wcvp_wanted = wcvp$wcvp_names[match(ids, wcvp$wcvp_names$plant_name_id),]
  geography = wcvp_geography$codes[match(wcvp_wanted$plant_name_id, wcvp_geography$id)]

  
  texteo = rep('',nrow(wcvp_wanted))
  for(i in 1:length(codes)){
   texteo[grep(codes[i], geography)] = paste0(texteo[grep(codes[i], geography)],
                                                          ', ',
                                                          wgsrpd3$LEVEL3_NAM[match(codes[i],wgsrpd3$LEVEL3_COD)])
  }
  texteo = stringr::str_remove(texteo,pattern = '^, ')
  wcvp_wanted$geography = texteo
  texteo <<- texteo
  codes <<- codes
  geography <<- geography
  wcvp_wanted$web_link = paste0("https://powo.science.kew.org/taxon/urn:lsid:ipni.org:names:",wcvp_wanted$powo_id)
  wcvp_wanted = wcvp_wanted[c('taxon_name', 'web_link', 'geography', 'powo_id', 'ipni_id', "family", "genus", "species_hybrid", "species",              "infraspecific_rank", "infraspecies", "parenthetical_author", "primary_author", "publication_author", "nomenclatural_remarks", "geographic_area", "lifeform_description", "climate_description")]
}


plot_info_tree <- wgsrpd3 |>
  #add the location data to the geometry data
  dplyr::left_join(location_data, by=c("LEVEL3_COD"="code"))

# Do we want to export the data into an excel spreadsheet and r data file.
if(export_data){
  l = location_data
  names(l) = c('BRU level 3 code',
               'BRU level 3 name',
               'Has tree in LC',
               'Number of tree (items)',
               'Number of tree (taxa)')
  
  exporting_data_store$map_of_tree_species = location_data
  rm(l)
}
# all_tree = sum(plot_info_tree$no_tree_accepted_wcvp_species != 0 )
# percent_rep = round(sum(plot_info_tree$rep_tree) / all_tree *100,digits = 2)
# no_rep = plot_info_tree$LEVEL3_NAM[!plot_info_tree$rep_tree & plot_info_tree$no_tree_accepted_wcvp_species != 0 ]
```

The maps in this section show which botanical countries are represented by trees in the collection, how many tree species from each botanical country are in the collection, and the proportion of trees in the collection relative to the total number of trees species in a botanical country.

Note that in the living collection there are `r length(unique(Tree_existing$best_name[which(is.na(Tree_existing$geography_codes))]))` tree taxa that are classed as trees without geographic information provided by the WCVP.

```{r Get Tree without geography table, eval = FALSE}

threat_without_geography = Tree_existing[which(is.na(Tree_existing$geography_codes)),]
threat_without_geography$POWO_web_address[8]
if(report_kind == 'static'){
  Tree_count_table |>
    flextable() |>
    set_caption(caption = "Trees in the LC") |> 
    font(fontname = "Calibri (Body)", part = "all") |> 
    fontsize(size = table_font_size, part = "body") |> 
    # add footer if you want
    # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
    #                colwidths = 4) |> 
    theme_booktabs() |> # default theme
    autofit()
}
if(report_kind == 'interactive'){
 Tree_count_table |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(Tree_count_table), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=F,
                                 ordering=F))
  
}
```

```{r, Number Tree Species in the LC - figure, fig.fullwidth=FALSE, fig.dim = c(10, 6), eval = report_kind == 'static'}
top10_name = plot_info$LEVEL3_NAM[order(plot_info$no_Tree_species, decreasing = TRUE)][1:10]
top10_value = plot_info$no_Tree_species[order(plot_info$no_Tree_species, decreasing = TRUE)][1:10]
top10 = data.frame(region = top10_name, no_Tree = top10_value)

###################################################################
# Plot of the representation of Tree species in each geographic region.
# Regions that have no Tree plants are set to NA.
plot_info$rep_Tree[plot_info$rep_Tree == TRUE] = 'Yes'
plot_info$rep_Tree[plot_info$rep_Tree == FALSE] = 'No'

plot_info$`Have Tree` = plot_info$rep_Tree

p = ggplot(plot_info)+
  geom_sf(aes(fill=`Have Tree`),  col="transparent")+
  stat_sf_coordinates(aes(col=`Have Tree`), show.legend = FALSE)+
  coord_sf(expand=FALSE) + 
  ggtitle("Geography of Trees in the LC")

if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Map_representation_of_Tree_species.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}

p
###################################################################
###################################################################
# Plot of the number of Tree species in each geographic region.
plot_info$no_Tree_species[plot_info$no_Tree_species == 0] = NA
p = ggplot(plot_info)+
  geom_sf(aes(fill=no_Tree_species),  col="transparent")+
  stat_sf_coordinates(aes(col=no_Tree_species))+
  scale_colour_distiller(direction=1, 
                         name="Number\nof Species", na.value = 'black') +
  scale_fill_distiller(direction=1,
                       name="Number\nof Species", na.value = 'black')+
  coord_sf(expand=FALSE) + 
  ggtitle("Number of Tree Species")

if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Map_number_of_Tree_species.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}

p

```

```{r, interactive map data setup, eval = report_kind == 'interactive'}
# Due to the high level of detail in wgsrpd3 we need to go to a simplified geometry for the interactive geometry plots. 
# load all geo areas
wgsrpd3_level3_simp = BGSmartR::wgsrpd3_level3_simp

# Reduce to only regions that have tree species.
plot_int_info <- wgsrpd3_level3_simp |>
  dplyr::left_join(location_data, by=c("code"="code"))
plot_int_info$name = plot_int_info$name.x
locations = wgsrpd3_level3_simp

if('no_tree_accepted_wcvp_species' %in% names(plot_int_info)){
  regions_to_remove = plot_int_info$code[plot_int_info$no_tree_accepted_wcvp_species == 0]
  plot_int_info = plot_int_info[!plot_int_info$no_tree_accepted_wcvp_species == 0,]
  locations = locations[!locations$code %in% regions_to_remove, drop = TRUE]
}


data_g = st_geometry(plot_int_info)
centers = st_centroid(data_g)
AA = unlist(centers)
center_df = data.frame(long = AA[seq(1,length(AA),2)], lat = AA[seq(2,length(AA),2)])

# Convert geometry into a format accepted by plotly
mapp = sf::st_cast(wgsrpd3_level3_simp, "MULTIPOLYGON")
geo_sf = geojsonsf::sf_geojson(mapp)
data = rjson::fromJSON(geo_sf)
feat = data$features
for(i in 1:length(feat)){
  feat[[i]]$id = feat[[i]]$properties$code
}
data$features = feat

if('no_tree_accepted_wcvp_species' %in% names(plot_int_info)){
  data$features = data$features[-c(which(location_data$code %in% regions_to_remove))]
}

index = seq(0,1,0.01)
col_rep = color_binary |> rev()
colours = c(rep(col_rep[1],51), rep(col_rep[2],50))
counter = 1:length(index)
col_scale_rep = lapply(counter, function(i){return(c(index[i], colours[i]))})

colours_cont = scales::brewer_pal(palette = palette, direction = 1)(7)
ramp <- scales::colour_ramp(colours_cont)
colos = ramp(seq(0, 1, length = 1001))


index = seq(0,1,0.001)
colours_cont = c( "#e6e6e6","#e6e6e6",colos)
counter = 1:length(index)
col_scale = lapply(counter, function(i){return(c(index[i], colours_cont[i]))})

plot_int_info$name = stringr::str_replace(plot_int_info$name, 'Is\\.', 'Islands')
plot_int_info$name = stringr::str_replace(plot_int_info$name, 'I\\.', 'Island')
```

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Represented regions"}`
```{r  Map of the representation of tree species - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'interactive'}
 prop = round(location_data$no_tree_species / location_data$no_tree_accepted_wcvp_species*100,digits=2)
  prop_true = prop
  prop_true[is.nan(prop_true)] = 'NA'
  prop[prop ==  0] = -0.01


rep_tree = rep('No', nrow(plot_int_info))
rep_tree[plot_int_info$rep_tree] = 'Yes'
plot_int_info$rep_tree_yes_no = rep_tree
text = paste0('Region: ', plot_int_info$name, '<br />', 
              'Represented: ', rep_tree, '<br />',
              'Taxa in LC: ', plot_int_info$no_tree_species,
              '/',plot_int_info$no_tree_accepted_wcvp_species,
              '<br />',
              'Items in LC: ', plot_int_info$no_tree_items, '<br />',
              'tree from region in LC: ', round(plot_int_info$no_tree_species*100/plot_int_info$no_tree_accepted_wcvp_species,digits = 2),
              '%', '<br />'
              )
plot_int_info$hover = text

fig = plot_ly(plot_int_info,  text = ~hover, hoverinfo = 'text') |>
  add_trace(type="choroplethmapbox",
            geojson=data,
            locations=locations$code,
            z=as.numeric(plot_int_info$rep_tree),
            colorscale=col_scale_rep,
            reversescale = FALSE,
            marker=list(line=list(
              width=0.01,color ='black'),
              text = plot_int_info$hover,
              hoverinfo = 'text'
            )) |>
  layout(
    mapbox=list(
      style="white-bg",
      center = list(lon = 0 ,lat= 60),
      zoom =0.46, 
      lataxis = list(range = c(-59, 90)))
  ) |>
  hide_colorbar()
# colorbar(title = "Species <br> Represented <br> in LC")  
fig = fig |>  add_trace(type="scattermapbox",
                        mode = 'markers',
                        data = center_df,
                        lon = center_df$long,
                        lat = center_df$lat,
                        text = plot_int_info$hover,
                        color = I(col_rep[as.numeric(plot_int_info$rep_tree)+1]), 
                        hoverinfo = 'text',
                        inherit = FALSE, showlegend = FALSE) 

fig <- fig   |> config(modeBarButtonsToRemove = c("select2d", "lasso2d"))

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Geography-Representation_of_tree_Species.html'))
}
suppressWarnings(fig)

```

`r if(report_kind == 'interactive'){"###### Number of trees held/region"}`
```{r  Map of the number of tree species - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'interactive'}
rep_tree = rep('No', nrow(plot_int_info))
rep_tree[plot_int_info$rep_tree] = 'Yes'

  plot_int_info$no_tree_species_use = plot_int_info$no_tree_species
  plot_int_info$no_tree_species_use[plot_int_info$no_tree_species == 0] = -1
  
  colscale_0_1 = as.numeric(unlist(lapply(col_scale, function(x){x[[1]]})))
  point_value = (plot_int_info$no_tree_species_use+1)/max(plot_int_info$no_tree_species_use+1)
  color_index = unlist(lapply(point_value, function(x){which.min(abs(x - colscale_0_1))}))
  fillcolor = unlist(lapply(color_index, function(x){col_scale[[x]][2]}))
  
  
  # fig = fig |>  add_trace(type="scattermapbox",
  #                         mode = 'markers',
  #                         data = center_df,
  #                         lon = center_df$long,
  #                         lat = center_df$lat,
  #                         text = plot_int_info$hover,
  #                         # fill = plot_int_info$no_tree_species+1,
  #                         # fillcolor=col_scale,
  #                         hoverinfo = 'skip',
  #                         inherit = FALSE,
  #                         showlegend = FALSE,
  #                         marker = list(color = fillcolor, line = list(width = 0)))


  
  fig = plot_ly(plot_int_info,  text = plot_int_info$hover, hoverinfo = 'text') |>
      add_trace(type="scattermapbox",
                          mode = 'markers',
                          data = center_df,
                          lon = center_df$long,
                          lat = center_df$lat,
                          text = plot_int_info$hover,
                          # fill = plot_int_info$no_tree_species+1,
                          # fillcolor=col_scale,
                          hoverinfo = 'text',
                          inherit = FALSE,
                          showlegend = FALSE,
                          marker = list(color = fillcolor, line = list(width = 0)),
                          hoverlabel = list(bgcolor = fillcolor)) |>
    add_trace(type="choroplethmapbox",
     geojson=data,
     locations=locations$code,
     z=plot_int_info$no_tree_species_use+1,
     zmin = 0, zmax = max(plot_int_info$no_tree_species_use),
     colorscale=col_scale,
     reversescale = FALSE,
     marker=list(line=list(
     width=0.01,color ='black')),
     text = plot_int_info$hover,
     hoverinfo = 'text',
     hoverlabel = list(bgcolor = fillcolor)
    ) |>
    layout(
    mapbox=list(
      style="white-bg",
      center = list(lon = 0 ,lat= 60),
      zoom =0.46,
      lataxis = list(range = c(-59, 90)))
  ) |>
    colorbar(title = "Number of <br> taxa")


  fig <- fig   |> config(modeBarButtonsToRemove = c("select2d", "lasso2d"))

  if(separate_figure_folder){
    htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Geography-Number_of_tree_Species.html'))
  }
  suppressWarnings(fig)

```

`r if(report_kind == 'interactive'){"###### % held relative to native trees"}`
```{r  Map of the proportion of Accepted Tree species - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'interactive'}
 rep_endemic = rep('No', nrow(plot_int_info))
rep_endemic[plot_int_info$rep_endemic] = 'Yes'

  prop = plot_int_info$no_tree_species*100/plot_int_info$no_tree_accepted_wcvp_species
  prop[prop ==  0] = -0.01

    
   colscale_0_1 = as.numeric(unlist(lapply(col_scale, function(x){x[[1]]})))
  point_value = (prop+0.01)/max(prop+0.01)
  color_index = unlist(lapply(point_value, function(x){which.min(abs(x - colscale_0_1))}))
  fillcolor = unlist(lapply(color_index, function(x){col_scale[[x]][2]}))

  
  fig = plot_ly(plot_int_info,  text = ~hover, hoverinfo = 'text') |>
    add_trace(type="choroplethmapbox",
     geojson=data,
     locations=locations$code,
     z= prop+ 0.01,
     colorscale=col_scale,
     reversescale = FALSE,
     marker=list(line=list(
     width=0.01,color ='black')),
     text = plot_int_info$hover,
     hoverinfo = 'text',
    hoverlabel = list(bgcolor = fillcolor)
    ) |>
    layout(
    mapbox=list(
      style="white-bg",
      center = list(lon = 0 ,lat= 60),
      zoom =0.46,
      lataxis = list(range = c(-59, 90)))
  ) |>
    # hide_colorbar()
    colorbar(title = "Proportion <br> of taxa")

  
  fig = fig |>  add_trace(type="scattermapbox",
                          mode = 'markers',
                          data = center_df,
                          lon = center_df$long,
                          lat = center_df$lat,
                          text = plot_int_info$hover,
                          colorscale=col_scale,
                          hoverinfo = 'text',
                          inherit = FALSE,
                          showlegend = FALSE,
                          marker = list(color = fillcolor, line = list(width = 0)),
                           hoverlabel = list(bgcolor = fillcolor))

  fig <- fig   |> config(modeBarButtonsToRemove = c("select2d", "lasso2d"))

  if(separate_figure_folder){
    htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Geography-Proportion_of_Accepted_trees_held.html'))
  }
  suppressWarnings(fig)

```

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

 
***

### Duplication of trees

```{r, duplication of Tree species}
### How many items/accessions for each Tree taxa in the LC.
Tree_items_per_taxa = table(paste0(Tree_existing$POWO_taxon_name, ' ', Tree_existing$POWO_taxon_authors))
Tree_items_per_taxa_table = table(as.numeric(Tree_items_per_taxa))

Tree_items_per_taxa_simp = as.numeric(Tree_items_per_taxa)
Tree_items_per_taxa_simp[Tree_items_per_taxa_simp >= 5] = '>4'
Tree_items_per_taxa_table_simp = table(Tree_items_per_taxa_simp)

Tree_accessions = Tree_existing[match(unique(Tree_existing$AccNoFull), Tree_existing$AccNoFull),]
Tree_accessions_per_taxa = table(paste0(Tree_accessions$POWO_taxon_name, ' ', Tree_accessions$POWO_taxon_authors))
Tree_accessions_per_taxa_table = table(as.numeric(Tree_accessions_per_taxa))

Tree_accessions_per_taxa_simp = as.numeric(Tree_accessions_per_taxa)
Tree_accessions_per_taxa_simp[Tree_accessions_per_taxa_simp >= 5] = '>4'
Tree_accessions_per_taxa_table_simp = table(Tree_accessions_per_taxa_simp)

duplication_items = data.frame(Tree_items_per_taxa_table_simp)
names(duplication_items) = c('Duplication', 'Items')

duplication_items$percent = paste0(round(duplication_items$Items / sum(duplication_items$Items)*100,digits = 1),'%')
duplication_items <- duplication_items %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Items))), 
                pos = Items/2 + dplyr::lead(csum, 1),
                pos = dplyr::if_else(is.na(pos), Items/2, pos))


duplication_accessions = data.frame(Tree_accessions_per_taxa_table_simp)
names(duplication_accessions) = c('Duplication', 'Accessions')
# duplication_accessions$Provenance  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(duplication_accessions$Provenance, c('G', 'U', 'W', 'Z'))]
duplication_accessions$percent = paste0(round(duplication_accessions$Accessions / sum(duplication_accessions$Accessions)*100,digits = 1),'%')
duplication_accessions <- duplication_accessions %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Accessions))), 
                pos = Accessions/2 + dplyr::lead(csum, 1),
                pos = dplyr::if_else(is.na(pos), Accessions/2, pos))

flex_data = data.frame(duplication_items$Duplication,
                       duplication_items$Items, 
                       paste0(round(duplication_items$Items/sum(duplication_items$Items)*100,digits=2),'%'),
                       duplication_accessions$Accessions,
                       paste0(round(duplication_accessions$Accessions/sum(duplication_accessions$Accessions)*100,digits=2),'%'))
names(flex_data) = c('Duplication', 'Number of Trees (by items)', 'Proportion of Trees (by items)', 'Number of Trees (by accessions)', 'Proportion of Trees (by accessions)')

if(export_data){
  exporting_data_store$Duplication_of_existing_Tree_plants_in_the_LC = flex_data
}

```

In this section, we explore the duplication of existing trees in the living collection. 

Below we show the number and proportion of trees by accessions and items.

```{r Duplication of Tree plants in the LC - Table}
flex_data  = flex_data[c(2:5,1),]
if(report_kind == 'static'){
  flex_data |>
    flextable() |>
    set_caption(caption = paste0('Duplication of existing trees in the LC')) |> 
    font(fontname = "Calibri (Body)", part = "all") |> 
    fontsize(size = table_font_size, part = "body") |> 
    # add footer if you want
    # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
    #                colwidths = 4) |> 
    theme_booktabs() |> # default theme
    separate_header() |> 
    align(align = "center", part = "all") |>
    autofit()
}


```


`r if(report_kind == 'static'){"Converting the table to pie charts yields "}`

```{r, Duplication of tree plants in the LC pie charts, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'static'}
# Basic piechart
pie1 = ggplot(duplication_items, aes(x="", y=Items, fill=Duplication)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtheme(base_size = 18) +
  ggtitle('Items') +
  scale_fill_discrete() +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

pie2 = ggplot(duplication_accessions, aes(x="", y=Accessions, fill=Duplication)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtitle('Accessions') + 
  scale_fill_discrete() +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

if(value_on_fig){
  pie1 = pie1 + geom_label_repel(aes(y = pos,label = percent),
                                 size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white")   
  
  pie2 = pie2 + geom_label_repel(aes(y = pos,label = percent),
                                 size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white") 
}

p = ggpubr::ggarrange(pie1, pie2, ncol=2, nrow=1, common.legend = TRUE, legend="bottom")

if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Duplication_of_Tree_plants.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}


p

```

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Chart"}`
```{r  Duplication of existing tree items in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
figs = list()

# Items
text = paste0(duplication_items$Items, ' trees has ', duplication_items$Duplication, ' items')
fig1 <- plot_ly(duplication_items, labels = ~Duplication, values = ~Items, hoverinfo = "text",  hovertext = text, sort = FALSE, marker = list(colors = scales::brewer_pal(palette = palette, direction = 1)(5)))
fig1 <- fig1 |> add_pie(hole = 0.6)
fig1 <- fig1 |> layout(title = "Items",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
figs$items = fig1
#Accessions
text = paste0(duplication_accessions$Accessions, ' trees has', duplication_accessions$Duplication, ' accessions')
fig2 <- plot_ly(duplication_accessions, labels = ~Duplication, values = ~Accessions, hoverinfo = "text",  hovertext = text, sort = FALSE, marker = list(colors = scales::brewer_pal(palette = palette, direction = 1)(5)))
fig2 <- fig2 |> add_pie(hole = 0.6)
fig2 <- fig2 |> layout(title = "Accessions",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
figs$accessions = fig2
duplication_items <<- duplication_items
duplication_accessions <<- duplication_accessions

duplication_items = duplication_items[c(2:5,1),]
duplication_accessions = duplication_accessions[c(2:5,1),]
# Together
p <- plot_ly() |>
  add_pie(data = duplication_items, labels = ~Duplication, values = ~Items, hole = 0.6,
          title = "Items", name ='', sort = FALSE, marker = list(
            colors =  scales::brewer_pal(palette = palette, direction = 1)(5)),
          domain = list(row = 0, column = 0)) |>
  add_pie(data = duplication_accessions, labels = ~Duplication, values = ~Accessions, hole = 0.6,
          title = "Accessions", name ='', sort = FALSE, marker = list(
            colors = scales::brewer_pal(palette = palette, direction = 1)(5)),
         domain = list(row = 0, column = 1))  |>
  layout(title = "", showlegend = TRUE,
          grid=list(rows=1, columns=2),
         plot_bgcolor="#f0f0f0",
         legend = list(orientation = 'h', xanchor = "center", x = 0.5),
         xaxis = list(title=paste0('Items', 'Accessions'), showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         margin = c(0,0,0,0))


if(separate_figure_folder){
  htmlwidgets::saveWidget(figs$items, file = paste0(figures_dir, '/','tree_duplication_existing_items.html'))
  htmlwidgets::saveWidget(figs$accessions, file = paste0(figures_dir, '/','tree_duplication_existing_accessions.html'))
}

p
  

```

`r if(report_kind == 'interactive' & do_over_time){"###### Table"}`
```{r Duplication of existing tree items in the LC - table, , eval = report_kind == 'interactive'}
flex_data |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(flex_data), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=F,
                                 ordering=F))

# DT::datatable(flex_data, rownames = FALSE,
#                 # caption = paste0('Native plants in the LC (',paste0(location_name, collapse = ', '),')'),
#                 options = list(dom = 't'))
```

`r if(report_kind == 'interactive'){"##### {-}"}`

Next we look at how duplication has changed over time. 

```{r, duplication of Trees over time}
over_time_info = lapply(Tree_existing_each_year, function(x){
  garden_current = Tree[x,]

  Tree_items_per_taxa = table(paste0(garden_current$POWO_taxon_name, ' ', garden_current$POWO_taxon_authors))
Tree_items_per_taxa_table = table(as.numeric(Tree_items_per_taxa))

Tree_items_per_taxa_simp = as.numeric(Tree_items_per_taxa)
Tree_items_per_taxa_simp[Tree_items_per_taxa_simp >= 5] = '>4'
Tree_items_per_taxa_table_simp = table(Tree_items_per_taxa_simp)
formatted = Tree_items_per_taxa_table_simp[match( c('1', '2', '3','4', '>4'), names(Tree_items_per_taxa_table_simp))]
formatted = as.numeric(formatted) ; formatted[is.na(formatted)] = 0

return(formatted)
}) |>
  data.frame() |>
  t() |>
  data.frame()
over_time_info = data.frame(Date = years, over_time_info)
names(over_time_info) = c('year','1', '2', '3', '4', '>4')
row.names(over_time_info) = 1:nrow(over_time_info)
duplication_items_over_time = over_time_info


over_time_info = lapply(Tree_existing_each_year, function(x){
  garden_current = Tree[x,]

Tree_accessions = garden_current[match(unique(garden_current$AccNoFull), garden_current$AccNoFull),]
Tree_accessions_per_taxa = table(paste0(Tree_accessions$POWO_taxon_name, ' ', Tree_accessions$POWO_taxon_authors))
Tree_accessions_per_taxa_table = table(as.numeric(Tree_accessions_per_taxa))

Tree_accessions_per_taxa_simp = as.numeric(Tree_accessions_per_taxa)
Tree_accessions_per_taxa_simp[Tree_accessions_per_taxa_simp >= 5] = '>4'
Tree_accessions_per_taxa_table_simp = table(Tree_accessions_per_taxa_simp)
formatted = Tree_accessions_per_taxa_table_simp[match( c('1', '2', '3','4', '>4'), names(Tree_accessions_per_taxa_table_simp))]
formatted = as.numeric(formatted) ; formatted[is.na(formatted)] = 0

return(formatted)

}) |>
  data.frame() |>
  t() |>
  data.frame()
over_time_info = data.frame(Date = years, over_time_info)
names(over_time_info) = c('year','1', '2', '3', '4', '>4')
row.names(over_time_info) = 1:nrow(over_time_info)
duplication_accessions_over_time = over_time_info


```

`r if(report_kind == 'interactive'& do_over_time){"#####  Duplication of trees over time {.tabset}"}`

`r if(report_kind == 'interactive'& do_over_time){"###### Items"}`
```{r  duplication of Tree items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'& do_over_time}
prop_data = duplication_items_over_time
prop_data[,-1] = prop_data[,-1]/rowSums(prop_data[,-1])*100

dd = reshape(prop_data, idvar = "year", varying = list(2:ncol(prop_data)),
                   v.names = "count", timevar = "group", times = names(prop_data)[-1], direction = "long")
dd$group = factor(dd$group, levels = c('1', '2', '3', '4', '>4'))
prop_data = dd
text = paste0(round(prop_data$count,digits=2), '%')
prop_data$text = text
fig <- plot_ly(prop_data, x = ~year, y = ~count, color = ~group, type = 'bar', customdata = ~text,
               hovertemplate = '%{customdata}',  colors = scales::brewer_pal(palette = palette, direction = 1)(5))
fig <- fig |> layout(yaxis = list(title = 'Percentage'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text='')),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)

fig

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_Bar-Tree_duplication_over_time_by_item.html'))
}
```

`r if(report_kind == 'interactive'& do_over_time){"###### Accessions"}`
```{r  duplication of Tree accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'& do_over_time}
prop_data = duplication_accessions_over_time
prop_data[,-1] = prop_data[,-1]/rowSums(prop_data[,-1])*100

dd = reshape(prop_data, idvar = "year", varying = list(2:ncol(prop_data)),
                   v.names = "count", timevar = "group", times = names(prop_data)[-1], direction = "long")
dd$group = factor(dd$group, levels = c('1', '2', '3', '4', '>4'))
prop_data = dd
text = paste0(round(prop_data$count,digits=2), '%')
prop_data$text = text
fig <- plot_ly(prop_data, x = ~year, y = ~count, color = ~group, type = 'bar', customdata = ~text,
               hovertemplate = '%{customdata}',  colors = scales::brewer_pal(palette = palette, direction = 1)(5))
fig <- fig |> layout(yaxis = list(title = 'Percentage'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text='')),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)

fig

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_Bar-Tree_duplication_over_time_by_accessions.html'))
}
```
`r if(report_kind == 'interactive'& do_over_time){"##### {-}"}`


***

### Rarity of trees 

```{r, rarity of Trees}
### How many items/accessions for each Tree taxa in the LC.
Tree_wanted_info = Tree_existing[c("AccNoFull", "best_name", "no_gardens")]
Tree_wanted_info_og = Tree_wanted_info

Tree_wanted_info <- Tree_wanted_info |> 
        dplyr::group_by(best_name) |> 
        dplyr::summarise(global = no_gardens[1], 
                         count = length(no_gardens)) |>
  dplyr::ungroup() 

not_found = sum(is.na(Tree_wanted_info$global))
Tree_wanted_info$global[is.na(Tree_wanted_info$global)] = 0

rarity_plot_info <- Tree_wanted_info |> 
        dplyr::group_by(global) |> 
        dplyr::summarise(global = global[1], 
                         count = length(best_name)) |>
  dplyr::ungroup() 

unique_ = sum(rarity_plot_info$count[rarity_plot_info$global %in% 0:1])  
v_rare = sum(rarity_plot_info$count[rarity_plot_info$global %in% 2:10])  
rare = sum(rarity_plot_info$count[rarity_plot_info$global %in% 11:50]) 
common = sum(rarity_plot_info$count[rarity_plot_info$global %in% 51:100]) 
v_common = sum(rarity_plot_info$count[rarity_plot_info$global %in% 100:1500]) 

doughnut_data = data.frame(rarity = c('Unique','Very Rare', 'Rare', 'Common', 'Very Common'),
                        no_items = c(unique_,v_rare, rare, common, v_common),
                        color = scales::brewer_pal(palette = palette, direction = 1)(5) |> rev())
doughnut_data$percent = paste0(round(doughnut_data$no_items / sum(doughnut_data$no_items)*100,digits = 1),'%')


# data formatted if we want to export/save it.
globally_held_taxa_grouped = doughnut_data[,c(1,2,4,3)]
names(globally_held_taxa_grouped) = c("Rarity in global living collections",   "Number of Taxa in living collection", "Percentage",  "Colour" )


# For downloaded table
Tree_wanted_info_og$no_gardens[is.na(Tree_wanted_info_og$no_gardens)] = 0
to_download = Tree_wanted_info_og[Tree_wanted_info_og$no_gardens < 10,]

to_download = to_download |>
  dplyr::group_by(best_name) |> 
  summarise(acc = toString(unique(AccNoFull)),
            no_gardens = no_gardens[1]
            )

names(to_download) = c('Taxa', 'Accessions', 'Number of global collections')
```

In this section, we explore the rarity in cultivation of existing trees in the living collection on the global scale. To do this we used BGCI's PlantSearch to extract the number of global collections plants are held within.

We group taxa by the number of collections they are found in globally. These are:

- **Unique**: plants found nowhere else (0 or 1 collection). These are names that do not match any name or match a name reported in only one collection in BGCIâs PlantSearch tool. Since it is not possible to know to which collection it belongs, BGsmartR assumes it belongs to yours and the name is in PlantSearch thanks to your input to that database. 
- **Very Rare**: plants found in 2-10 collections.
- **Rare**: plants found in 11-50 collections.
- **Common**: plants found in 51-100 collections.
- **Very Common**: plants found in more than 100 collections.

`r if(report_kind == 'interactive'){"#####  Rarity of trees {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Summary"}`
```{r, grouped rarity - interactive figure, fig.dim = c(10, 4), eval = report_kind == 'interactive'}
text = paste0(doughnut_data$no_items, ' records classed as ', doughnut_data$rarity )
doughnut_data$rarity = factor(doughnut_data$rarity, levels = doughnut_data$rarity)

fig <- plot_ly(doughnut_data, labels = ~rarity, values = ~no_items, hoverinfo = "text",  hovertext = text, marker = list(colors = ~color),  sort = FALSE )
fig <- fig %>% add_pie(hole = 0.6)
fig <- fig %>% layout(title = "",  showlegend = T,
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Pie-grouped_global_rarity.html'))
}

fig

```

`r if(report_kind == 'interactive'& do_over_time){"###### Detailed"}`
```{r, taxa in collection against how many sites globally - interactive figure, fig.dim = c(10, 4), eval = report_kind == 'interactive'}
data_plot = rarity_plot_info
text = paste0(data_plot$count, ' trees in the garden are found in ', data_plot$global, ' collections globally.')
colo_rare = rev(scales::brewer_pal(palette = palette, direction = 1)(5))

fig <- plot_ly(data_plot, x = ~global, y = ~count, 
         type = 'scatter',  mode = 'markers', hoverinfo = "text",  hovertext = text, colors = 'black', color = 'color')
fig <- fig |> layout(title = "",
  xaxis = list(title = "Number of living collections <br> holding the taxa worldwide"),
  yaxis = list (title = "Number of trees <br> found in the collection")) 
fig <- layout(fig,
             shapes = list(
                list(type = "rect",
                    fillcolor = colo_rare[1], line = list(color = colo_rare[1]), opacity = 0.3,
                    x0 = 0, x1 = 1.5, xref = "x",
                    y0 = 0, y1 = max(data_plot$count), yref = "y"),
               list(type = "rect",
                    fillcolor = colo_rare[2], line = list(color = colo_rare[2]), opacity = 0.3,
                    x0 = 1.5, x1 = 10.5, xref = "x",
                    y0 = 0, y1 = max(data_plot$count), yref = "y"),
                list(type = "rect",
                    fillcolor = colo_rare[3], line = list(color = colo_rare[3]), opacity = 0.3,
                    x0 = 10.5, x1 = 50.5, xref = "x",
                    y0 = 0, y1 = max(data_plot$count), yref = "y"),
               list(type = "rect",
                    fillcolor = colo_rare[4], line = list(color = colo_rare[4]), opacity = 0.3,
                    x0 = 50.5, x1 = 100.5, xref = "x",
                    y0 = 0, y1 = max(data_plot$count), yref = "y"),
                list(type = "rect",
                    fillcolor = colo_rare[5], line = list(color = colo_rare[5]), opacity = 0.3,
                    x0 = 100.5, x1 = max(data_plot$global), xref = "x",
                    y0 = 0, y1 = max(data_plot$count), yref = "y")               
              ))

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','grown_in_LC_against_global.html'))
}

fig

```

`r if(report_kind == 'interactive'& do_over_time){"##### {-}"}`


:::: {.blackbox data-latex=""}

Note that unique/very rare taxa may suffer from inaccurate naming. These taxa can be downloaded using the button below

```{r}
to_download |>
  download_this(
    output_name = "unique_and_rare_trees",
    output_extension = ".xlsx",
    button_label = "Download unique and rare trees (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained =  T
  )
```
::::

***

### Provenance of trees
  
In this section we are exploring the provenance of trees in the collection. Each accession in the garden has one of the following provenance types:

- Wild: plants that were collected directly from the wild,
- Wild-derived: cultivated plants descended from plants of known wild origin,
- Garden: cultivated plants descended from plants not of known wild origin,
- Unknown: plants with unknown origin.

Below we produce a chart and table of provenance for items and accessions.

```{r, Provenance of Tree plants in the LC,  results='hide',fig.keep='all', message=FALSE}
# Tree_existing the data of existing Tree plants in the LC. 
wanted_order = c('Wild', 'Wild-derived', 'Garden', 'Unknown')
prov_items = data.frame(table(Tree_existing$ProvenanceCode))
rows = match(wanted_order, prov_items[,1])
other = which(!prov_items[,1] %in% wanted_order)
o = c(rows,other)
o = o[!is.na(o)]
prov_items = prov_items[o,]
names(prov_items) = c('Provenance', 'Items')
# prov_items$Provenance  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(prov_items$Provenance, c('G', 'U', 'W', 'Z'))]  
prov_items$percent = paste0(round(prov_items$Items / sum(prov_items$Items)*100,digits = 1),'%')
prov_items <- prov_items %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Items))), 
                pos = Items/2 + dplyr::lead(csum, 1),
                pos = dplyr::if_else(is.na(pos), Items/2, pos))


prov_accessions = data.frame(table(Tree_existing$ProvenanceCode[match(unique(Tree_existing$AccNoFull), Tree_existing$AccNoFull)]))
rows = match(wanted_order, prov_accessions[,1])
other = which(!prov_accessions[,1] %in% wanted_order)
o = c(rows,other)
o = o[!is.na(o)]
prov_accessions = prov_accessions[o,]
names(prov_accessions) = c('Provenance', 'Accessions')
# prov_accessions$Provenance  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(prov_accessions$Provenance, c('G', 'U', 'W', 'Z'))]
prov_accessions$percent = paste0(round(prov_accessions$Accessions / sum(prov_accessions$Accessions)*100,digits = 1),'%')
prov_accessions <- prov_accessions %>% 
  dplyr::mutate(csum = rev(cumsum(rev(Accessions))), 
                pos = Accessions/2 + dplyr::lead(csum, 1),
                pos = dplyr::if_else(is.na(pos), Accessions/2, pos))

flex_data = data.frame(prov_items$Provenance,
                       prov_items$Items, 
                       paste0(round(prov_items$Items/sum(prov_items$Items)*100,digits=2),'%'),
                       prov_accessions$Accessions,
                       paste0(round(prov_accessions$Accessions/sum(prov_accessions$Accessions)*100,digits=2),'%'))
names(flex_data) = c('Provenance', 'Number of items', 'Proportion of items', 'Number of accessions', 'Proportion of accessions')

if(export_data){
  exporting_data_store$Provenance_of_existing_Tree_plants_in_the_LC = flex_data
}

### Create provenance by taxa to see if any have multiple provenance codes. 
taxa_prov_og = Tree_existing |>
  dplyr::group_by(best_name) |>
  summarise(wild_items = sum(.data$ProvenanceCode == 'Wild'),
            z_items = sum(.data$ProvenanceCode == "Wild-derived"),
            garden_items = sum(.data$ProvenanceCode == 'Garden'),
            unknown_items = sum(.data$ProvenanceCode == 'Unknown'),
            original_name = toString(.data$TaxonNameFull |> unique())
            )

taxa_prov = taxa_prov_og[,c(1:5)] |> as.data.frame()
for(i in 2:5){taxa_prov[,i] = taxa_prov[,i] |> as.numeric()}

wild_taxa = taxa_prov$best_name[taxa_prov$wild_items > 0]
z_taxa = taxa_prov$best_name[taxa_prov$z_items > 0]
g_taxa = taxa_prov$best_name[taxa_prov$garden_items > 0]
u_taxa = taxa_prov$best_name[taxa_prov$unknown_items > 0]
x = list() ; category.names = NULL ; colours = NULL
if(length(wild_taxa) > 0 ){x$w = wild_taxa ; category.names = c(category.names, "Wild") ; colours = c(colours, interactive_colour(4)[c(1)])}
if(length(u_taxa) > 0 ){x$u = u_taxa ; category.names = c(category.names, "Unknown") ; colours = c(colours, interactive_colour(4)[c(4)])}
if(length(z_taxa) > 0 ){x$z = z_taxa ; category.names = c(category.names, "Wild-derived"); colours = c(colours, interactive_colour(4)[c(2)])}
if(length(g_taxa) > 0 ){x$g = g_taxa ; category.names = c(category.names, "Garden"); colours = c(colours, interactive_colour(4)[c(3)])}
library(VennDiagram)
venn_diag = venn.diagram(x, filename = NULL,
                         category.names = category.names,
                         fill =colours,
                         disable.logging = TRUE,
                         main.fontfamily = "arial",
                         main.fontface = "sans")


# Make a data.frame of the overlapping taxa for a download.
taxa_prov_og$no_val =  lapply(taxa_prov_og[,-6] |> as.data.frame() |> t() |> as.data.frame(),function(x){
  sum(as.numeric(x[-1]) != 0)
}) |> unlist()

taxa_prov = taxa_prov_og[taxa_prov_og$no_val > 1,]
taxa_prov = taxa_prov[,-7]
taxa_prov =taxa_prov[,c(1,6,2,3,4,5)]
names(taxa_prov) = c("Best name found by BGSmartR",
                     "Original Taxonomic name/s",
                     "Number of Wild Origin Items",
                     "Number of Wild-derived Origin Items",
                     "Number of Garden Origin Items",
                     "Number of Unknown Origin Items")


### (END) Create provenance by taxa to see if any have multiple provenance codes. 
```

```{r Provenance of Tree plants in the LC - Table}
if(report_kind == 'static'){
  flex_data |>
    flextable() |>
    set_caption(caption = paste0('Provenance of existing Trees in the LC')) |> 
    font(fontname = "Calibri (Body)", part = "all") |> 
    fontsize(size = table_font_size, part = "body") |> 
    # add footer if you want
    # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
    #                colwidths = 4) |> 
    theme_booktabs() |> # default theme
    separate_header() |> 
    align(align = "center", part = "all") |>
    autofit()
}
# if(report_kind == 'interactive'){
#  DT::datatable(flex_data, rownames = FALSE,
#                 # caption = paste0('Provenance of existing Tree plants in the LC'),
#                 options = list(dom = 't'))
# }

```


```{r, Provenance of Tree plants in the LC pie charts, fig.fullwidth=TRUE, fig.dim = c(10, 6), eval = report_kind == 'static'}
# Basic piechart
pie1 = ggplot(prov_items, aes(x="", y=Items, fill=Provenance)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtheme(base_size = 18) +
  ggtitle('Items') +
  scale_fill_discrete() +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

pie2 = ggplot(prov_accessions, aes(x="", y=Accessions, fill=Provenance)) +
  geom_bar(stat="identity", width=1, color="white") +
  ggtheme(base_size = 18) +
  coord_polar("y", start=0) +
  ggtitle('Accessions') + 
  scale_fill_discrete() +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        panel.background=element_blank(),
        panel.border=element_blank(),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        plot.background=element_blank(),
        plot.title = element_text(hjust = 0.5))

if(value_on_fig){
  pie1 = pie1 + geom_label_repel(aes(y = pos,label = percent),
                                 size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white")   
  
  pie2 = pie2 + geom_label_repel(aes(y = pos,label = percent),
                                 size = 4.5, nudge_x = 1, show.legend = FALSE, fill = "white") 
}

p = ggpubr::ggarrange(pie1, pie2, ncol=2, nrow=1, common.legend = TRUE, legend="bottom")

if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Provenance_of_Tree_plants.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}


p

```

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive' & do_over_time){"###### Chart"}`
```{r  Provenance of existing Tree items in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
figs = list()
colo = interactive_colour(4)
colo = colo[match(unique(prov_items$Provenance), wanted_order)]
# Items
text = paste0(prov_items$Items, ' ',prov_items$Provenance,' origin Tree items')
fig1 <- plot_ly(prov_items, labels = ~Provenance, values = ~Items, hoverinfo = "text",  hovertext = text, sort = FALSE, marker = list(colors = colo))
fig1 <- fig1 |> add_pie(hole = 0.6)
fig1 <- fig1 |> layout(title = "Items",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
figs$items = fig1
#Accessions
text = paste0(prov_accessions$Accessions, ' ',prov_accessions$Provenance,' origin Tree items')
fig2 <- plot_ly(prov_accessions, labels = ~Provenance, values = ~Accessions, hoverinfo = "text",  hovertext = text, sort = FALSE, marker = list(colors = colo))
fig2 <- fig2 |> add_pie(hole = 0.6)
fig2 <- fig2 |> layout(title = "Accessions",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
figs$accessions = fig2

# Together
p <- plot_ly() |>
  add_pie(data = prov_items, labels = ~Provenance, values = ~Items, hole = 0.6,
          title = "Items", name ='', sort = FALSE, marker = list(colors = colo),
          domain = list(row = 0, column = 0)) |>
  add_pie(data = prov_accessions, labels = ~Provenance, values = ~Accessions, hole = 0.6,
          title = "Accessions", name ='', sort = FALSE, marker = list(colors = colo),
         domain = list(row = 0, column = 1))  |>
  layout(title = "", showlegend = TRUE,
          grid=list(rows=1, columns=2),
         plot_bgcolor="#f0f0f0",
         legend = list(orientation = 'h', xanchor = "center", x = 0.5),
         xaxis = list(title=paste0('Items', 'Accessions'), showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         margin = c(0,0,0,0))


if(separate_figure_folder){
  htmlwidgets::saveWidget(figs$items, file = paste0(figures_dir, '/','Tree_provenance_existing_items.html'))
  htmlwidgets::saveWidget(figs$accessions, file = paste0(figures_dir, '/','Tree_provenance_existing_accessions.html'))
}

p
  
```

`r if(report_kind == 'interactive' & do_over_time){"###### Table"}`
```{r Provenance of existing Tree items in the LC - table, eval = report_kind == 'interactive'}
flex_data |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = nrow(flex_data),
                                 dom = 'Bt',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=FALSE,
                                 ordering=F))
```

`r if(report_kind == 'interactive'& do_over_time){"##### {-}"}`

`r if(do_over_time){"We will now look at how the provenance of trees in the living collection has changed over time."}`

`r if(!do_over_time){"We do not have the information to explore how provenance of trees in the living collection has changed over time."}`

```{r, Provenance of Tree plants in the LC- change over time data, eval = do_over_time}
# For each year get the number in each group (species and genera)
over_time_info = lapply(Tree_existing_each_year, function(x){
  garden_current = Tree[x,]

  prov_items =  data.frame(table(garden_current$ProvenanceCode))
  if(nrow(prov_items) == 0){
    return(list(prov_items = prov_items,
                prov_accessions = prov_items))
  }
  names(prov_items) = c('Provenance', 'Items')

  prov_accessions = data.frame(table(garden_current$ProvenanceCode[match(unique(garden_current$AccNoFull), garden_current$AccNoFull)]))
  names(prov_accessions) = c('Provenance', 'Accessions')

  return(list(prov_items = prov_items,
              prov_accessions = prov_accessions))
})
prov_Tree_over_time = over_time_info

```

```{r, Provenance of Tree plants in the LC- change over time figures, fig.fullwidth=FALSE, fig.dim = c(10, 6), , eval = report_kind == 'static' & do_over_time}
to_do = c('items', 'accessions')
for(i in 1:length(to_do)){
  # Get the data from over_time_info.
  data_wanted = NULL
  wanted_item = which(grepl('prov',names(prov_Tree_over_time[[1]])) & grepl(to_do[i],names(prov_Tree_over_time[[1]])) )
  for(jj in 1:length(prov_Tree_over_time)){
    info_year = prov_Tree_over_time[[jj]][[wanted_item]]
    if(nrow(info_year) == 0){
      next
    }
    prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
    info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)),
                           info_year = info_year,
                           prop = prop)
    data_wanted = rbind(data_wanted, info_year)
    
  }
  names(data_wanted) = c('year', 'Provenance', 'Items', 'prop')
  data_wanted[,2] = as.character(data_wanted[,2])
  # data_wanted[,2]  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(data_wanted[,2], c('G', 'U', 'W', 'Z') )]
  data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))
  
  
  if(export_data){
    item_name = paste0('Provenance_of_Tree_plants_in_the_LC_proportion_over_time_',to_do[i])
    exporting_data_store$AA = data_wanted
    names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
  }
  
  p = ggplot(data_wanted, aes(fill=Provenance, y=prop, x=year)) + 
    geom_bar(position="stack", stat="identity", width = 1) +
    # theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),panel.background = element_blank(), axis.line = element_line(colour = "black")) +
    labs(title=paste0("Provenance of ", to_do[i] , " that are Tree in the LC over time"),
         x ="Year",
         y = "Percentage (%)") +
    guides(fill=guide_legend(title=paste0('Provenance')))# +
  # theme(text = element_text(size=table_font_size))
  
  if(separate_figure_folder){
    ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Provenance_of_Tree_over_time', to_do[i] ,'.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
  }
  print(p)
  
}
```

`r if(report_kind == 'interactive'& do_over_time){"##### {.tabset}"}`

`r if(report_kind == 'interactive'& do_over_time){"###### Items"}`
```{r  Provenance of Tree items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'& do_over_time}
wanted_order = c('Wild', 'Wild-derived', 'Garden', 'Unknown')
to_do = c('items', 'accessions')
i=1

# Get the data from over_time_info.
data_wanted = NULL
wanted_item = which(grepl('prov',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
for(jj in 1:length(over_time_info)){
  info_year = over_time_info[[jj]][[wanted_item]]
  if(nrow(info_year) == 0){
    next
  }
  rows = match(wanted_order, info_year[,1])
  other = which(!info_year[,1] %in% wanted_order)
  o = c(rows,other)
  o = o[!is.na(o)]
  info_year = info_year[o,]
  prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
  info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)),
                         info_year = info_year,
                         prop = prop)
  data_wanted = rbind(data_wanted, info_year)
  
}
names(data_wanted) = c('year', 'Provenance', 'Items', 'prop')
data_wanted[,2] = as.character(data_wanted[,2])
# data_wanted[,2]  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(data_wanted[,2], c('G', 'U', 'W', 'Z') )]
data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))


if(export_data){
  item_name = paste0('Provenance_of_Tree_plants_in_the_LC_proportion_over_time_',to_do[i])
  exporting_data_store$AA = data_wanted
  names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
}


text = paste0(round(data_wanted$prop,digits=2), '% (',data_wanted$Items,' items) ')
data_wanted$text = text
data_wanted$Provenance = factor(data_wanted$Provenance, levels= unique(data_wanted$Provenance))

colo = interactive_colour(4)
colo = colo[match(levels(data_wanted$Provenance), wanted_order)]

fig <- plot_ly(data_wanted, x = ~year, y = ~prop, color = ~Provenance, type = 'bar', text = ~text,
               hovertemplate = '%{text}',  colors = colo,
               sort = FALSE)
fig <- fig |> layout(yaxis = list(title = 'Percentage'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text='')),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)

fig

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_Bar-Tree_provenance_over_time_by_item.html'))
}
```

`r if(report_kind == 'interactive'& do_over_time){"###### Accessions"}`
```{r  Provenance of Tree accessions over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'& do_over_time}
wanted_order = c('Wild', 'Wild-derived', 'Garden', 'Unknown')
to_do = c('items', 'accessions')
i=2

# Get the data from over_time_info.
data_wanted = NULL
wanted_item = which(grepl('prov',names(over_time_info[[1]])) & grepl(to_do[i],names(over_time_info[[1]])) )
for(jj in 1:length(over_time_info)){
  info_year = over_time_info[[jj]][[wanted_item]]
  if(nrow(info_year) == 0){
    next
  }
  rows = match(wanted_order, info_year[,1])
  other = which(!info_year[,1] %in% wanted_order)
  o = c(rows,other)
  o = o[!is.na(o)]
  info_year = info_year[o,]
  prop = round(info_year[,2] / sum(info_year[,2]) *100,digits = 3)
  info_year = data.frame(year = rep(names(over_time_info)[jj], nrow(info_year)),
                         info_year = info_year,
                         prop = prop)
  data_wanted = rbind(data_wanted, info_year)
  
}
names(data_wanted) = c('year', 'Provenance', 'Items', 'prop')
data_wanted[,2] = as.character(data_wanted[,2])
# data_wanted[,2]  = c('Garden', 'Unknown', 'Wild', 'Wild-dervived')[match(data_wanted[,2], c('G', 'U', 'W', 'Z') )]
data_wanted$year = as.numeric(stringr::str_extract(data_wanted$year,'[0-9]{4}'))


if(export_data){
  item_name = paste0('Provenance_of_Tree_plants_in_the_LC_proportion_over_time_',to_do[i])
  exporting_data_store$AA = data_wanted
  names(exporting_data_store)[names(exporting_data_store) == 'AA'] = item_name
}


text = paste0(round(data_wanted$prop,digits=2), '% (',data_wanted$Items,' accessions) ')
data_wanted$text = text
data_wanted$Provenance = factor(data_wanted$Provenance, levels= unique(data_wanted$Provenance))

colo = interactive_colour(4)
colo = colo[match(levels(data_wanted$Provenance), wanted_order)]

fig <- plot_ly(data_wanted, x = ~year, y = ~prop, color = ~Provenance, type = 'bar', text = ~text,
               hovertemplate = '%{text}', colors = colo,
               sort = FALSE)
fig <- fig |> layout(yaxis = list(title = 'Percentage'),
                     xaxis = list(title = "Year", hoverformat = 'Year: '),
                     legend=list(title=list(text='')),
                     barmode = 'stack')
fig <- fig |> layout(hovermode = 'x unified', bargap =0)
fig

if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Stacked_Bar-Tree_provenance_over_time_by_accession.html'))
}
```

`r if(report_kind == 'interactive'& do_over_time){"##### {-}"}`


In the above analysis we have considered tree items and accessions where provenance is unique (i.e each accession can only be in one provenance group). Next we look at provenance across taxa. In this case a taxa can be contained in the garden by multiple provenance codes (i.e. one accession of wild origin and one accession of garden origin). To visualise the provenance by taxa we use a Venn diagram visualise how taxa can be expressed by multiple provenances. 

```{r, draw provenace by taxa (venn), results='hide',fig.keep='all', message=FALSE, fig.dim=c(4,4), fig.align = 'center', eval = report_kind == 'interactive' }
grid.newpage()
grid.draw(venn_diag)
```


:::: {.blackbox data-latex=""}

Taxa with multiple provenance types can be downloaded below

```{r}
taxa_prov |>
  download_this(
    output_name = "Taxa with multiple provenances",
    output_extension = ".xlsx",
    button_label = "Download taxa with multiple provenances (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained =  T
  )
```
::::


***
  
### Turnover analysis
  
This section looks at the turnover (gain/loss) of accessions of trees in the living collection.

`r if(!do_over_time){"As we do not have information to explore the data over time we cannot perform turnover analysis."}`

`r if(do_over_time){"We can also view the gain/loss of tree accessions as a proportion of all gained/lost trees each year. This will show if the incoming proportion of trees was more or less than the proportion of trees in the collection."}`


```{r, tree Turnover - Accessions, eval = do_over_time}
# Start from the original_report
max_year = as.numeric(format(Sys.Date(),'%Y'))
years = min_year:max_year
report = report_original
report = report[report$AccYear > 1650 & report$AccYear<=max_year,]
report = report[!is.na(report$ItemStatusDate),]

## Convert report into accessions
unique_accessions = unique(report$AccNoFull)
LossYear = rep(NA,nrow(report))
ItemStatusYear = as.numeric(stringr::str_extract(report$ItemStatusDate,pattern = '[0-9]{4}'))
LossYear[report$ItemStatusType %in% c('NotExisting', 'Not Existing')] = ItemStatusYear[report$ItemStatusType %in% c('NotExisting', 'Not Existing')]
report$LossYear = LossYear
# Order the items where the lower indices have the most recent death date.
LossYear_dummy = LossYear
LossYear_dummy[is.na(LossYear_dummy)] = 4000
ordered_items = order(LossYear_dummy,decreasing = T)
report = report[ordered_items, ]
# Match to the ordered accessions.
match_to_best = match(unique_accessions,report$AccNoFull)
#Reduce the data to unique accessions with most recent death date.
report = report[match_to_best,]


#Get the number of accessions existing each year for whole collection/
existing_each_year_LC = as.numeric(colSums(BGSmartR::exist_at_date(date = paste0(years,'-12-31'),
                                                                   AccessionYear = as.character(report$AccYear),
                                                                   ItemStatusDate = as.character(report$ItemStatusDate),
                                                                   ItemStatusType = as.character(report$ItemStatusType),
                                                                   post_date = '3000-01-01')))
## Get the turnover for the whole collection.
overall_turnover = turnover_items(report)
exporting_data_store$overall_turnover = overall_turnover

## Get the trends for Tree accessions.
date = paste0(years, '-12-31')
plant_existing = BGSmartR::exist_at_date(date, AccessionYear = report$AccYear,
                                         ItemStatusDate = report$ItemStatusDate,
                                         ItemStatusType = report$ItemStatusType,
                                         post_date = '3000-01-01')
names(plant_existing) = date
trends = pbapply::pblapply(plant_existing, function(x){
  garden_current = report[x,]
  
  accessions = nrow(garden_current)
  
  breakdown_tree = table(garden_current$tree)
  
  return(list(accessions = accessions, breakdown_tree = breakdown_tree))
})
names(trends) = names(plant_existing)
trend = as.numeric(unlist(lapply(trends,function(x){
  sum(x$breakdown_tree[grepl('^Tree', names(x$breakdown_tree))])
})))


do_type = TRUE
report_cur = report[which(report$tree == 'Tree'),]
if(nrow(report_cur) == 0){
  do_type = FALSE
}else{
  
  
  turnover = turnover_items(report_cur)
  exporting_data_store$turnover_tree = turnover
  
  plots = plots_turnover(turnover, trend = trend, report_kind = report_kind, separate_figure_folder = separate_figure_folder, text = 'tree', data_type = 'Accessions')
  
  existing_each_year = as.numeric(colSums(BGSmartR::exist_at_date(date = paste0(years,'-12-31'),
                                                                  AccessionYear = report_cur$AccYear,
                                                                  ItemStatusDate = report_cur$ItemStatusDate,
                                                                  ItemStatusType = report_cur$ItemStatusType,
                                                                  post_date = '3000-01-01')))
  collection_proportion = existing_each_year/ existing_each_year_LC
  
  plots_proportional = proportional_plots_turnover(turnover = turnover,
                                                   overall_turnover = overall_turnover,
                                                   collection_proportion = collection_proportion,
                                                   report_kind = report_kind,
                                                   separate_figure_folder = separate_figure_folder,
                                                   text = 'tree',
                                                   data_type = 'Accessions')
  exporting_data_store$proportional_turnover_native_gain = plots_proportional$data_gain
  exporting_data_store$proportional_turnover_native_loss = plots_proportional$data_loss
}
```


`r if(!do_type){"There are no records that are trees"}`

```{r, Turnover of trees items - static, eval = report_kind == 'static'& do_type, fig.fullwidth=TRUE, fig.dim = c(10, 6),}
# plots$gain_loss
# 
# plots$net
# 
# plots_accessions$gain_loss
# 
# plots_accessions$net
# 

```

`r if(report_kind == 'interactive' & do_type){"#####  Turnover of trees {.tabset}"}`

`r if(report_kind == 'interactive' & do_type){"###### Net"}`
```{r  Gain/Loss of Tree items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_type}
plots$trend_and_net
```

`r if(report_kind == 'interactive' & do_type){"###### Gain/Loss"}`
```{r  Net turnover of Tree items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_type}
plots$gain_loss
```

`r if(report_kind == 'interactive' & do_type){"##### {-}"}`

`r if(!do_type){"We now explore how the gain and loss of trees compare proportionally to the total number of gained and lost items/accessions and the overall proportion of trees each year. To calculate the proportion of the collection that are trees each year we only consider records that have an accession year and item status date and extract which items/accessions were existing on the first of January each year."}`

```{r, Proportional Turnover of Tree - static, eval = report_kind == 'static'& do_type, fig.fullwidth=TRUE, fig.dim = c(10, 6),}
# plots_proportional$gain
# 
# plots_proportional$loss
# 
# plots_proportional_accessions$gain
# 
# plots_proportional_accessions$loss

```

`r if(report_kind == 'interactive' & do_type){"#####  Proportional turnover of trees {.tabset}"}`

`r if(report_kind == 'interactive' & do_type){"###### Gain"}`
```{r  Proportional Gain of Tree items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_type}
plots_proportional$gain
```

`r if(report_kind == 'interactive' & do_type){"###### Loss"}`
```{r  Proportional Loss of Tree items over time in the LC - interactive, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & do_type}
plots_proportional$loss
```

`r if(report_kind == 'interactive' & do_type){"##### {-}"}`

***
  
### Survival analysis
  
```{r, survival analysis, echo = FALSE}
# Remove those without accession year.
do_survival = TRUE
if(!do_over_time){
  do_survival = FALSE
}

if(!is.null(old_accession_year_codes)){
  has_old_accessions_code = which(enriched_report$AccYear %in% old_accession_year_codes)
  no_old_accessions = length(has_old_accessions_code)
  enriched_report$AccYear[has_old_accessions_code] = earliest_allowable_record
}

enriched_report_wanted = enriched_report[as.numeric(enriched_report$AccYear) > 1650 & as.numeric(enriched_report$AccYear) < as.numeric(format(Sys.Date(),'%Y')),]
enriched_report_wanted = enriched_report_wanted[!is.na(enriched_report_wanted$ItemStatusDate),]
enriched_report_wanted = enriched_report_wanted[!is.na(enriched_report_wanted$AccYear),]

# Create a data-frame of the information we want.
wanted_data = data.frame(enriched_report_wanted$TaxonNameFull, enriched_report_wanted$AccYear, enriched_report_wanted$ItemStatusDate, enriched_report_wanted$ItemStatusType)
names(wanted_data) = c('TaxonNameFull', 'AccYear', 'ItemStatusDate', 'ItemStatusType')


if(nrow(wanted_data) == 0){
  do_survival = FALSE
}
if(do_survival){
  #Set accession date (just chose the first of June)
pre_date = rep(NA, length(wanted_data$AccYear))
pre_date = paste(wanted_data$AccYear, "06", "01", sep = "-")

# Convert ItemStatusDate into all dates (i.e if month or day missing add one)
post_date = rep(as.character(Sys.Date()), length(wanted_data$AccYear))
post_date[which(wanted_data$ItemStatusType == "NotExisting")] = as.character(wanted_data$ItemStatusDate[which(wanted_data$ItemStatusType == 
  "NotExisting")])

post_date[which(stringr::str_length(post_date) == 4)] = paste(post_date[which(stringr::str_length(post_date) == 
  4)], "12", "31", sep = "-")
post_date[which(stringr::str_length(post_date) == 7)] = paste(post_date[which(stringr::str_length(post_date) == 
  7)], "28", sep = "-")

# Create the time difference between accession and ItemStatusDate.
time = as.numeric(as.Date(post_date) - as.Date(pre_date)) /365.25

# Create status to tell whether the last item status date was item death or just a check.
status = rep(0,length(wanted_data$AccYear))
status[wanted_data$ItemStatusType == 'NotExisting'] = 1

wanted_data = data.frame(wanted_data, AccessionDate = pre_date,
                         StatusDate = post_date,
                         time = time,
                         Alive_dead = status)


# We haven't removed those with missing ItemStatusDate, these will most likely have negative time so remove these.
missing_itemstatusdate_index = which(wanted_data$time > 0)
status_year = wanted_data$ItemStatusDate |> stringr::str_extract('^[0-9]{4}') |> unlist() |> as.numeric()
status_before_current_year = which(status_year <= format(Sys.Date(),'%Y') |> as.numeric() )
to_keep = intersect(missing_itemstatusdate_index,status_before_current_year)
wanted_data = wanted_data[to_keep,]

enriched_report_wanted = enriched_report_wanted[to_keep,]

  ## 1) Native or non-native (or doesn't have geography info.)
  #Get which records are native.
  native_non_native = enriched_report_wanted$tree
  
  data_to_analyse = data.frame(wanted_data$TaxonNameFull,
                               wanted_data$time,
                               wanted_data$Alive_dead,
                               native_non_native)
  names(data_to_analyse) = c("TaxonNameFull", "time", "Alive_dead", "tree_status")
  data_to_analyse <<- data_to_analyse
  if(export_data){
    exporting_data_store$Data_for_survival = data_to_analyse
  }
}

```

In this section, we look at whether the survival period of trees are longer than non-trees. Note that plants can be long-lived and most collections will have plants that are older than the collection itself. Therefore, we need to lean into tools from statistics to analyse the lifespan of plants in a collection. Herein, we use survival analysis to calculate the probability that plants will survive for any number of years. 

`r if(FALSE){"Note that \"lifespan\" may be a preferable way to describe this section, however we use survival because accessioned plants may arrive in the garden already a few years old. As we will be using the accession date and item status date to determine the length of time plants have been in the collection this might not align perfectly with the age of the plant. Moreover, it is important to be aware that the data used in the analysis is not \"perfect\" in the sense that plants might have already died a large period of time prior to an audit, moreover this analysis doesn't account for circumstances of plant death which could be natural, or for renovation of a section of the garden, etc. "}`

In the following analysis, we assume that existing items are still existing to the present day. Therefore, even if the last item status date was a year ago if the plant was found to be existing then we assume it is still existing now. (I could change this to just use alive at Item status date, it won't make much difference. )

Since we only have the accession year we set the accession date to be the middle of the year (1st June).
 
`r if(do_survival){"Below we show the survival probability (Kaplan-Meier plots) for trees and non-trees."}`

`r if(!do_survival){"Survival analysis cannot be performed. (This could be due to lack of accession year or item status date."}`

```{r, survival analysis - figure, echo  = FALSE, fig.fullwidth=TRUE, fig.dim = c(10, 6), results='hide',fig.keep='all', message=FALSE, eval = do_survival}
data_to_analyse$tree_status = factor(data_to_analyse$tree_status, levels = c('Tree', 'Not tree'))

# Create Kaplan-Meier plots comparing endemic and not endemic
fit = ggsurvfit::survfit2(survival::Surv(time, Alive_dead) ~ tree_status, data = data_to_analyse)
p = fit |> 
  ggsurvfit::ggsurvfit() +
  ggplot2::labs(
    x = "Years",
    y = "Overall survival probability"
  ) + 
  ggsurvfit::add_confidence_interval()+
    # theme(text = element_text(size=table_font_size))+
  # labs(title=paste0("Survival probability of native and non native plants in the LC")) +
  labs(caption = "Shaded region represents 95% confidence interval.") +
  scale_colour_manual(values = c('#f46d43', '#848484')) +
  scale_fill_manual(values = c('#f46d43', '#848484')) +
   theme(
    panel.border = element_blank(),
    panel.background = element_blank(),
    axis.text=element_text(size=10))

if(report_kind == 'static'){
  if(separate_figure_folder){
  ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Tree_widespread_survival.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
  }
  p
} 
```

```{r survival_analysis - interactive figure, eval = do_survival,  fig.fullwidth=TRUE, fig.dim = c(10, 4)}
if(report_kind == 'interactive'){
  fig = ggplotly(p, dynamicTicks = TRUE)
  fig$x$layout$title$text =''
  fig$x$layout$legend$title$text = ''
  fig$x$layout$hovermode = 'x unified'
  fig$x$data[[2]]$name = 'Not tree'
  fig$x$data[[2]]$legendgroup = 'Not tree'
  fig$x$data[[1]]$name = 'Tree'
  fig$x$data[[1]]$legendgroup = 'Tree'
  fig$x$data[[4]]$hoverinfo = 'none'
  fig$x$data[[3]]$hoverinfo = 'none'
  
  time_region = round(fig$x$data[[4]]$text |>
    stringr::str_extract(pattern = 'time:[ ]+[0-9\\.]+') |>
    stringr::str_extract(pattern = '[0-9]+\\.[0-9]+') |>
    as.numeric(), digits = 3) 
  lower_region = round(fig$x$data[[4]]$text |>
    stringr::str_extract(pattern = 'conf.low: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100,digits = 2)
  upper_region = round(fig$x$data[[4]]$text |>
    stringr::str_extract(pattern = 'conf.high: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100, digits = 2)
  time = round(fig$x$data[[2]]$x,digits = 3)
  lower = lower_region[match(time, time_region)]
  upper = upper_region[match(time, time_region)]
  
  fig$x$data[[2]]$text = paste0(#'Age (years): ',round(fig$x$data[[2]]$x,digits = ), '<br>',
                                'Survival probability: ', round(fig$x$data[[2]]$y*100,digits = 2),'% <br>',
                                '95% confidence Interval: (', lower,'%, ', upper, '%)')
  
    time_region = round(fig$x$data[[3]]$text |>
    stringr::str_extract(pattern = 'time:[ ]+[0-9\\.]+') |>
    stringr::str_extract(pattern = '[0-9]+\\.[0-9]+') |>
    as.numeric(), digits = 3) 
  lower_region = round(fig$x$data[[3]]$text |>
    stringr::str_extract(pattern = 'conf.low: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100,digits = 2)
  upper_region = round(fig$x$data[[3]]$text |>
    stringr::str_extract(pattern = 'conf.high: [0-9\\.]+') |>
    stringr::str_extract(pattern = '[01]\\.[0-9]+') |>
    as.numeric()*100, digits = 2)
  time = round(fig$x$data[[1]]$x,digits = 3)
  lower = lower_region[match(time, time_region)]
  upper = upper_region[match(time, time_region)]
  
  fig$x$data[[1]]$text = paste0('Age (years): ',round(fig$x$data[[1]]$x,digits = ), '<br>',
                                'Survival probability: ', round(fig$x$data[[1]]$y*100,digits = 2),'% <br>',
                                '95% confidence Interval: (', lower,'%, ', upper, '%)')
  
   #Set initial y-axis tick values 
  fig$x$layout$yaxis$ticktext = c("0.25", "0.50", "0.75", "1.00")
  fig$x$layout$yaxis$tickvals = c(0.25, 0.50, 0.75, 1.00)
  fig$x$layout$font$size = 10 # font size
  fig$x$layout$yaxis$title$font$size = 14
  fig$x$layout$xaxis$title$font$size = 14
  fig$x$layout$xaxis$title$font$color = NULL
   fig$x$layout$yaxis$title$font$color = NULL
  fig$x$layout$yaxis$tickfont$size = 12
  fig$x$layout$xaxis$tickfont$size = 12
  
  if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','Tree_survival_analysis.html'))
}

fig
}
```

`r if(do_survival){"Next we give the median surivival times for trees and non-trees in the collection."}`

```{r, survival analysis - median survival tables, echo = FALSE, message=FALSE, eval = do_survival}
# We can also get survival probabilities in a table
# 

table_data2 = fit |> 
  gtsummary::tbl_survfit(
    probs = c(0.5),
    label_header = "**Median survival (95% CI)**")

table_data2 = table_data2$table_body
table_data2 = table_data2[,-c(1:4)]
table_data2 = table_data2[-1,]
names(table_data2) = c('Characteristic', 'Median survival + 95% CI (Years)')

table_data2 |>  DT::datatable(extensions = 'Buttons',
                             rownames = FALSE,
                             options = list(scrollX = TRUE,
                                            pageLength = nrow(table_data2),
                                            dom = 'Bt',
                                            buttons = c('copy', 'csv', 'excel', 'pdf'),
                                            paging=FALSE,
                                            ordering=F))


```


`r if(do_survival){"Lastly, we give the survival probability for particular lengths of time."}`

```{r, survival analysis - tables, echo = FALSE, message=FALSE, eval = do_survival}
# We can also get survival probabilities in a table
# 
table_data = fit |> 
  gtsummary::tbl_survfit(
    times = c(2,5,10,25,50,100),
    label_header = "{time}-year survival (95% CI)")

table_data = table_data$table_body
  table_data = table_data[,-c(1:4)]
  table_data = table_data[-1,]
  names(table_data) = c('Status', '2-year survival (95% CI)',
                        '5-year survival (95% CI)',
                        '10-year survival (95% CI)',
                        '25-year survival (95% CI)',
                        '50-year survival (95% CI)',
                        '100-year survival (95% CI)')
  table_data = data.frame(t(table_data))
  table_data = table_data[-1,]
  names(table_data) = c('Tree', 'Not tree')
  
  
  table_data2 = fit |> 
  gtsummary::tbl_survfit(
    probs = c(0.5),
    label_header = "**Median survival (95% CI)**")

table_data2 = table_data2$table_body
  table_data2 = table_data2[,-c(1:4)]
  table_data2 = table_data2[-1,]
  names(table_data2) = c('Characteristic', 'Median survival (95% CI)')
  
  
  
if(report_kind == 'static'){
  table_data |>
  flextable() |>
  set_caption(caption = paste0('Survival probability table')) |> 
  font(fontname = "Calibri (Body)", part = "all") |> 
  fontsize(size = table_font_size, part = "body") |> 
  # add footer if you want
  # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
  #                colwidths = 4) |> 
  theme_booktabs() |> # default theme
  autofit() |>
  set_table_properties(width = 1, layout = "autofit")
}
if(report_kind == 'interactive'){
  table_data$year  =paste0(c(2,5,10,25,50,100), '-year survival')
  names(table_data)[3] = 'Survival time (95% CI)'
  table_data = table_data[,c(3,1,2)]
  table_data |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = nrow(table_data),
                                 dom = 'Bt',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=FALSE,
                                 ordering=F))

}
```

***

###### {-} 
<!-- This section is for exporting the data -->

```{r, export data}
if(export_data){
  #remove all data except wanted to be exported.
  # rm(list=setdiff(ls(), c("exporting_data_store", "output_dir", "collection")))
  # Do some changes (which we do in smaller chunks in the actual code.)

  tree_data  = exporting_data_store
  # save as .rda.
  save(tree_data, file = paste0(output_dir,'/',collection, '_tree_data.rda'))

}
```

### Taxonomic representation of trees

In this section we create sunburst and treemap charts showing all of the trees found within WCVP (accepted species; by matching to BGCI GlobalTreeSearch), grouped into families, orders and higher-level lineages. The charts are shaded lighter to darker orange depending on the proportion of the tree lineages found in the collection, where lineages in light orange are not represented. This provides a tool to visualise potential lineages to add to the collection in order to increase taxonomic diversity.  

```{r, Create taxonomic diversity genus level, echo = FALSE, message = FALSE}
report = wcvp$wcvp_names[wcvp$wcvp_names$plant_name_id %in% wcvp$trees$plant_name_id,] 
# report = native_wcvp
report = report[report$taxon_status == 'Accepted',]
collection_report = Tree_existing
LC_in_WCVP = match(unique(collection_report$POWO_plant_name_id) ,report$plant_name_id)
LC_in_WCVP = LC_in_WCVP[!is.na(LC_in_WCVP)]
in_LC = rep(F, nrow(report))
in_LC[LC_in_WCVP] = TRUE
report$in_LC = in_LC
report = report[c('family', 'genus', 'in_LC')]
report$fam_gen = paste0(report$family,' ',report$genus)
report <-  report |> 
        dplyr::group_by(fam_gen) |> 
        dplyr::summarise(family = family[1], 
                         genus = genus[1],
                         in_LC = any(in_LC)) |>
  dplyr::ungroup() 



#No families.
# = Use POWO family if available if not use the original.
no_families <- length(unique(report$family))

#No genus
# = Use POWO genus if available if not use the original.
no_genus <- length(unique(report$fam_gen))


report_div  = report

Diversity_class = BGSmartR::Diversity_classification
Classification <- as.data.frame(Diversity_class$Classification)
synomym_families <- as.data.frame(Diversity_class$synomym_families)

fam = report_div$family

# Convert from conserved family name to family name where applicable. 
AA = apply(synomym_families, 2, function(x){
  fam[fam == as.character(x[2])] = as.character(x[1])
  })
report_div$family = fam

matched_families = match(fam, Classification$family)
order = Classification$order[matched_families]
major_Eudicot_lineage = Classification$`major Eudicot lineage`[matched_families]
major_Angiosperm_lineage = Classification$`major Angiosperm lineage`[matched_families]
major_Land_Plants_lineage = Classification$`major Land Plants lineage`[matched_families]


report_div$order = order
report_div$major_Eudicot_lineage = major_Eudicot_lineage
report_div$major_Angiosperm_lineage = major_Angiosperm_lineage
report_div$major_Land_Plants_lineage = major_Land_Plants_lineage

report_cur = report_div

combined_taxo = paste0(report_cur$genus,'---',
                                       report_cur$family,'---',
                                       report_cur$order,'---',
                                       report_cur$major_Eudicot_lineage,'---',
                                       report_cur$major_Angiosperm_lineage,'---',
                                       report_cur$major_Land_Plants_lineage)

with_issue = length(which(grepl('---NA$',combined_taxo)))
combined_taxo_count = as.numeric(report_cur$in_LC)
#remove those without major land plants lineage. (i.e ends in ---NA).
if(with_issue > 0){
  index_remove = which(grepl('---NA$',combined_taxo))
  combined_taxo = combined_taxo[-index_remove]
  combined_taxo_count = combined_taxo_count[-index_remove]
}
# Convert NA in species to Indet.
combined_taxo[which(grepl('^NA---',combined_taxo))] = stringr::str_replace(combined_taxo[which(grepl('^NA---',combined_taxo))], '^NA---', 'Indet.---')


data = data.frame(ID = combined_taxo, count = combined_taxo_count, count_all = 1)
non_combined  = data.frame(t(data.frame(stringr::str_split(data$ID,pattern = '---'))))
names(non_combined) = c('genus', 'family', 'order', 'major_Eudicot_lineage',
                        'major_Angiosperm_lineage', 'major_Land_Plants_lineage')
rownames(non_combined) = 1:nrow(non_combined)

data = data.frame(data, non_combined)

# push species names to genus species (otherwise issues with repeated species names with different genera)

labels = c(unique(data$major_Land_Plants_lineage), unique(data$major_Angiosperm_lineage), unique(data$major_Eudicot_lineage),
           unique(data$order), unique(data$family), unique(data$genus))
major_Land_Plants_lineage_index = 1:length(unique(data$major_Land_Plants_lineage))
major_Angiosperm_lineage_index = (max(major_Land_Plants_lineage_index)+1):(max(major_Land_Plants_lineage_index)+length(unique(data$major_Angiosperm_lineage)))
major_Eudicot_lineage_index = (max(major_Angiosperm_lineage_index)+1):(max(major_Angiosperm_lineage_index)+length(unique(data$major_Eudicot_lineage)))
order_index = (max(major_Eudicot_lineage_index)+1):(max(major_Eudicot_lineage_index)+length(unique(data$order)))
family_index = (max(order_index)+1):(max(order_index)+length(unique(data$family)))
genus_index = (max(family_index)+1):(max(family_index)+length(unique(data$genus)))

parents = rep('', length(labels))
parents[major_Angiosperm_lineage_index] = data$major_Land_Plants_lineage[match(labels[major_Angiosperm_lineage_index], data$major_Angiosperm_lineage)]
parents[major_Eudicot_lineage_index] = data$major_Angiosperm_lineage[match(labels[major_Eudicot_lineage_index], data$major_Eudicot_lineage)]
parents[order_index] = data$major_Eudicot_lineage[match(labels[order_index], data$order)]
parents[family_index] = data$order[match(labels[family_index], data$family)]
parents[genus_index] = data$family[match(labels[genus_index], data$genus)]

values = rep(NA, length(labels))
values[genus_index] = data$count[match(labels[genus_index], data$genus)]
total_for_families <-  aggregate(. ~family, data[,c(5,2)], sum, na.rm = TRUE)
values[family_index] = total_for_families$count[match(labels[family_index], total_for_families$family)]
total_for_order <-  aggregate(. ~order, data[,c(6,2)], sum, na.rm = TRUE)
values[order_index] = total_for_order$count[match(labels[order_index], total_for_order$order)]
total_for_major_Eudicot_lineage <-  aggregate(. ~major_Eudicot_lineage, data[,c(7,2)], sum, na.rm = TRUE)
values[major_Eudicot_lineage_index] = total_for_major_Eudicot_lineage$count[match(labels[major_Eudicot_lineage_index], total_for_major_Eudicot_lineage$major_Eudicot_lineage)]
total_for_major_Angiosperm_lineage <-  aggregate(. ~major_Angiosperm_lineage, data[,c(8,2)], sum, na.rm = TRUE)
values[major_Angiosperm_lineage_index] = total_for_major_Angiosperm_lineage$count[match(labels[major_Angiosperm_lineage_index], total_for_major_Angiosperm_lineage$major_Angiosperm_lineage)]
total_for_major_Land_Plants_lineage <-  aggregate(. ~major_Land_Plants_lineage, data[,c(9,2)], sum, na.rm = TRUE)
values[major_Land_Plants_lineage_index] = total_for_major_Land_Plants_lineage$count[match(labels[major_Land_Plants_lineage_index], total_for_major_Land_Plants_lineage$major_Land_Plants_lineage)]
in_collection = values

values = rep(NA, length(labels))
values[genus_index] = data$count_all[match(labels[genus_index], data$genus)]
total_for_families <-  aggregate(. ~family, data[,c(5,3)], sum, na.rm = TRUE)
values[family_index] = total_for_families$count[match(labels[family_index], total_for_families$family)]
total_for_order <-  aggregate(. ~order, data[,c(6,3)], sum, na.rm = TRUE)
values[order_index] = total_for_order$count[match(labels[order_index], total_for_order$order)]
total_for_major_Eudicot_lineage <-  aggregate(. ~major_Eudicot_lineage, data[,c(7,3)], sum, na.rm = TRUE)
values[major_Eudicot_lineage_index] = total_for_major_Eudicot_lineage$count[match(labels[major_Eudicot_lineage_index], total_for_major_Eudicot_lineage$major_Eudicot_lineage)]
total_for_major_Angiosperm_lineage <-  aggregate(. ~major_Angiosperm_lineage, data[,c(8,3)], sum, na.rm = TRUE)
values[major_Angiosperm_lineage_index] = total_for_major_Angiosperm_lineage$count[match(labels[major_Angiosperm_lineage_index], total_for_major_Angiosperm_lineage$major_Angiosperm_lineage)]
total_for_major_Land_Plants_lineage <-  aggregate(. ~major_Land_Plants_lineage, data[,c(9,3)], sum, na.rm = TRUE)
values[major_Land_Plants_lineage_index] = total_for_major_Land_Plants_lineage$count[match(labels[major_Land_Plants_lineage_index], total_for_major_Land_Plants_lineage$major_Land_Plants_lineage)]
total_wcvp = values


data_formatted = data.frame(ID = labels, labels=labels, parents = parents, values = total_wcvp,  in_LC = in_collection)

#Go back to just species names.
data_formatted$labels[grepl('---', data_formatted$labels)] = unlist(lapply(stringr::str_split(data_formatted$labels[grepl('---', data_formatted$labels)], pattern = '---'), function(x){x[1]}))
data_formatted$ID[grepl('---', data_formatted$ID)] = unlist(lapply(stringr::str_split(data_formatted$ID[grepl('---', data_formatted$ID)], pattern = '---'), function(x){x[1]}))
# data_formatted$labels=unlist(lapply(stringr::str_split(data_formatted$labels, ' '),function(x){x[length(x)]}))
data_formatted$ID = paste0(data_formatted$labels, '---', data_formatted$parents)

data_formatted$parents = paste0(data_formatted$parents,'---',data_formatted$parents[match(data_formatted$parents, data_formatted$labels)])
data_formatted$parents[data_formatted$parents == "---NA"] =''

# Collapse levels.
data_formatted$labels[data_formatted$labels == 'None_Eudicots'] = 'Other'
data_formatted$labels[data_formatted$labels == 'None_Angiosperms'] = 'Other'

# Remove Intermediate levels.
remove_nodes = c('None_Monocots', 'None_Ferns', 'None_Ferns_Eudicot',"None_Gymnosperms", 'None_Lycophytes',   'None_Liverworts', 'None_Hornworts', 'None_Gymnosperms_Eudicot', 'None_Lycophytes_Eudicot', 'None_Liverworts_Eudicot', 'None_Hornworts_Eudicot', 'No_Mosses_Angiosperm_lineage', 'No_Mosses_Eudicot_lineage', 'None_Angiosperms_Eudicot_lineage')
AA = lapply(remove_nodes, function(node){
  # Select the row to remove (begining with "*node*---")
  to_remove = which(grepl(paste0('^',node,'---'), data_formatted$ID))
  if(length(to_remove)> 0 ){
    #Get new parent id and new label from the node to remove.
    new_parent = data_formatted[to_remove,]$parents
    new_label =  unlist(stringr::str_split(new_parent,'---'))[1]
    # Remove the row.
    data_formatted = data_formatted[-to_remove,]
    # Update End of the ID for the new parent
    data_formatted$ID[grepl(paste0(node,'$'),data_formatted$ID)] = unlist(stringr::str_replace(data_formatted$ID[grepl(paste0(node,'$'),data_formatted$ID)],paste0('---',node), paste0('---',new_label)))
    # Update the parents for each node who originally has 'node' as the value. 
    data_formatted$parents[grepl(paste0('^',node, '---'),data_formatted$parents)] = new_parent
    # Update the parents for each node who originally has 'node' as the parent. 
    data_formatted$parents[grepl(paste0(node,'$'),data_formatted$parents)] = unlist(stringr::str_replace(data_formatted$parents[grepl(paste0(node,'$'),data_formatted$parents)],paste0('---',node), paste0('---',new_label)))
    data_formatted <<- data_formatted
  }
 
  return()
})


# Add header of 'Collection'
data_formatted$ID[grepl('---$', data_formatted$ID)] = paste0(data_formatted$ID[grepl('---$', data_formatted$ID)] , 'WCVP')
data_formatted$parents[grepl('---$', data_formatted$parents)] = paste0(data_formatted$parents[grepl('---$', data_formatted$parents)] , 'WCVP')
data_formatted$parents[data_formatted$parents == ''] = 'WCVP'

data_formatted[nrow(data_formatted)+1,] = c('WCVP', 'WCVP', '', sum(data_formatted$values[data_formatted$parents == 'WCVP']), sum(data_formatted$in_LC[data_formatted$parents == 'WCVP']) )


### Add subfamily info to data_formatted
{
  #############################################################################
## Add subfamilies (All)
#############################################################################
subfamily_genus_simp = BGSmartR::subfamily_genus_simp
for(i in 1:nrow(subfamily_genus_simp)){
  # for(i in 1:30){
  subfamily_info = subfamily_genus_simp[i,]
  subfamily_genera = unlist(stringr::str_split(subfamily_info$all_genera ,', '))
  subfamily_genera = subfamily_genera[subfamily_genera !=  ""]
  if(length(subfamily_genera) == 0){
    next
  }
  in_formatted = which(grepl(paste0(subfamily_info$family, '$'),data_formatted$ID) & data_formatted$labels %in% subfamily_genera)
  if(length(in_formatted) >0){
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(subfamily_info$sub_family,'---', subfamily_info$family)
    new = c(new_ID, subfamily_info$sub_family, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = subfamily_info$family, replacement = subfamily_info$sub_family)
    data_want$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new
  }
}

####### Deal with genera with no subfamily (when others in the family have a sub-family.)
# Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
families_with_subfamilies = unique(subfamily_genus_simp$family)
all_subfamilies = unique(subfamily_genus_simp$sub_family)
# Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
for(i in 1:length(families_with_subfamilies)){
  family = families_with_subfamilies[i]
  # Fine records whose parent is the familiy in question and extract the data.

  in_formatted = which(grepl(paste0(family,'$'),data_formatted$ID))
  data_want = data_formatted[in_formatted,]

  # Check if we have any records where we have genus---family (i.e no  subfamily)
  without_subfamily = which(!data_want$labels %in% all_subfamilies)

  #If we have at least one genus-family we need to group these into no subfamily.
  if(length(without_subfamily) > 0){
    data_without_subfam = data_want[without_subfamily,]

    new_ID = paste0('No Subfamily','---', family)

    new_node = new = c(new_ID, 'No Subfamily', data_want$parents[1], sum(as.numeric(data_without_subfam$values)), sum(as.numeric(data_without_subfam$in_LC)))

    data_without_subfam$ID = stringr::str_replace(data_without_subfam$ID,pattern = family, replacement = 'No Subfamily')
    data_without_subfam$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted[without_subfamily],] = data_without_subfam

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new_node
  }

}

#############################################################################
## Add tribes (All)
#############################################################################
tribe_genus_simp = BGSmartR::tribe_genus_simp
for(i in 1:nrow(tribe_genus_simp)){
  # for(i in 1:30){
  tribe_info = tribe_genus_simp[i,]
  tribe_genera = unlist(stringr::str_split(tribe_info$all_genera ,', '))
  tribe_genera = tribe_genera[tribe_genera !=  ""]
  if(length(tribe_genera) == 0){
    next
  }
  in_formatted = which(grepl(paste0(tribe_info$sub_family, '$'),data_formatted$ID) &
                         data_formatted$labels %in% tribe_genera)
  if(length(in_formatted) >0){
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(tribe_info$tribe,'---', tribe_info$sub_family)
    new = c(new_ID, tribe_info$tribe, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = tribe_info$sub_family, replacement = tribe_info$tribe)
    data_want$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new
  }
}

####### Deal with genera with no subfamily (when others in the family have a sub-family.)
# Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
subfamilies_with_tribes = unique(tribe_genus_simp$sub_family)
all_tribes = unique(tribe_genus_simp$tribe)
# Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
for(i in 1:length(subfamilies_with_tribes)){
  subfamily = subfamilies_with_tribes[i]
  # Fine records whose parent is the familiy in question and extract the data.

  in_formatted = which(grepl(paste0(subfamily,'$'),data_formatted$ID))
  data_want = data_formatted[in_formatted,]

  # Check if we have any records where we have genus---subfamily (i.e no  subfamily)
  without_tribe = which(!data_want$labels %in% all_tribes)

  #If we have at least one genus-subfamily we need to group these into no subfamily.
  if(length(without_tribe) > 0){
    data_without_tribe = data_want[without_tribe,]

    new_ID = paste0('No Tribe','---', subfamily)

    new_node = new = c(new_ID, 'No Tribe', data_want$parents[1], sum(as.numeric(data_without_tribe$values)), sum(as.numeric(data_without_tribe$in_LC)))

    data_without_tribe$ID = stringr::str_replace(data_without_tribe$ID,pattern = subfamily, replacement = 'No Tribe')
    data_without_tribe$parents = new_ID


    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted[without_tribe],] = data_without_tribe

    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new_node
  }

}


#############################################################################
## Add Subtribes (All)
#############################################################################
subtribe_genus_simp = BGSmartR::subtribe_genus_simp

for(i in 1:nrow(subtribe_genus_simp)){
  # for(i in 1:30){
  subtribe_info = subtribe_genus_simp[i,]
  subtribe_genera = unlist(stringr::str_split(subtribe_info$all_genera ,', '))
  subtribe_genera = subtribe_genera[subtribe_genera !=  ""]
  if(length(subtribe_genera) == 0){
    next
  }
  in_formatted = which(grepl(paste0(subtribe_info$tribe, '$'),data_formatted$ID) &
                          data_formatted$labels %in% subtribe_genera)
  if(length(in_formatted) == 0){
    next
  }
    data_want = data_formatted[in_formatted,]
    new_ID = paste0(subtribe_info$subtribe,'---', subtribe_info$tribe)
    new = c(new_ID, subtribe_info$subtribe, data_want$parents[1], sum(as.numeric(data_want$values)), sum(as.numeric(data_want$in_LC)))
    data_want$ID = stringr::str_replace(data_want$ID,pattern = subtribe_info$tribe, replacement = subtribe_info$subtribe)
    data_want$parents = new_ID
    
    
    # Replace original genus-family with the new genus-subfamily.
    data_formatted[in_formatted,] = data_want
    
    # Add the new node for the subfamily.
    data_formatted[nrow(data_formatted)+1,] = new
}

####### Deal with genera with no subfamily (when others in the family have a sub-family.)
# Get all families with subfamilies and the vector of all subfamilies (irrespective of family)
tribes_with_subtribes = unique(subtribe_genus_simp$tribe)
all_subtribes = unique(subtribe_genus_simp$subtribe)
# Loop over each family to put all non-subfamily genera together into 'No Subfamily group)
for(i in 1:length(tribes_with_subtribes)){
  tribe = tribes_with_subtribes[i]
  # Fine records whose parent is the familiy in question and extract the data.
  
  in_formatted = which(grepl(paste0(tribe,'$'),data_formatted$ID))
  data_want = data_formatted[in_formatted,]
  
  # Check if we have any records where we have genus---tribe (i.e no  tribe)
  without_subtribe = which(!data_want$labels %in% all_subtribes)
  
  #If we have at least one genus-tribe we need to group these into no tribe
  if(length(without_subtribe) > 0){
    data_without_tribe = data_want[without_subtribe,]
    
    new_ID = paste0('No Subtribe','---', tribe)
    
    new_node = new = c(new_ID, 'No Subtribe', data_want$parents[1], sum(as.numeric(data_without_tribe$values)), sum(as.numeric(data_without_tribe$in_LC)))
    
    data_without_tribe$ID = stringr::str_replace(data_without_tribe$ID,pattern = tribe, replacement = 'No Subtribe')
    data_without_tribe$parents = new_ID
    
    
    # Replace original genus-family with the new genus-tribe
    data_formatted[in_formatted[without_subtribe],] = data_without_tribe
    
    # Add the new node for the tribe
    data_formatted[nrow(data_formatted)+1,] = new_node
  }
  
}


#############################################################################

}



data_formatted$percentage = as.numeric(data_formatted$in_LC) / as.numeric(data_formatted$values)
rbPal <- colorRampPalette(c("#FEEDDE", "#FDD0A2", "#FDAE6B", "#FD8D3C", "#F16913", "#D94801", "#8C2D04"))
data_formatted$Col <- rbPal(100)[as.numeric(cut(data_formatted$percentage,breaks = 100))]

data_formatted$hover = paste0(round(data_formatted$percentage*100,digits = 2),'% of ', data_formatted$labels, ' trees (genera level) found within the LC (',data_formatted$in_LC,'/',data_formatted$values,')')
```

```{r, Create  taxonomic diversity at genus with contained/missing, echo = F}
if(report_kind == 'interactive'){
 fig <- plotly::plot_ly(data_formatted,
                             ids = ~ID,
                             labels = ~labels,
                             parents =~parents,
                             values = ~values,
                             type = 'sunburst',
                             insidetextorientation='radial',
                             branchvalues = 'total',
                             maxdepth = 4,
                             marker=list(colors=data_formatted$Col, line = list(color = 'white')),
                             hoverinfo = "text",  hovertext = data_formatted$hover
                             )

 fig2 <- plotly::plot_ly(data_formatted,
                             ids = ~ID,
                             labels = ~labels,
                             parents =~parents,
                             values = ~values,
                             type = 'treemap',
                             branchvalues = 'total',
                             maxdepth = 4,
                             marker=list(colors=data_formatted$Col, line = list(color = 'white')),
                         hoverinfo = "text",  hovertext = data_formatted$hover)
                        
if(separate_figure_folder){
  htmlwidgets::saveWidget(fig, file = paste0(figures_dir, '/','sunburst:taxonomic_diversity.html'))
  htmlwidgets::saveWidget(fig2, file = paste0(figures_dir, '/','treemap:taxonomic_diversity.html'))
}

}
```

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Sunburst"}`
```{r  Sunburst genera, fig.fullwidth=TRUE, fig.dim = c(10, 8), eval = report_kind == 'interactive'}
fig
```

`r if(report_kind == 'interactive'){"###### Treemap"}`
```{r  tree map genera, fig.fullwidth=TRUE, fig.dim = c(10, 5), eval = report_kind == 'interactive'}
fig2
```

`r if(report_kind == 'interactive'){"##### {-}"}`

***

### Native, endemic and threatened trees

```{r, Among the native plants in a LC, how many of them are endemic or redlisted - Data}
endemic = rep(FALSE, nrow(Tree_existing))
endemic[which(Tree_existing$endemic == 'Endemic')] = TRUE
total_endemic = sum(endemic)

threatened = rep(FALSE, nrow(Tree_existing))
threatened[which(Tree_existing$POWO_Red_category %in% c('EN', 'VU', 'CR', 'EW', 'EX'))] = TRUE
threatened[which(Tree_existing$redList_category %in% c('EN', 'VU', 'CR', 'EW', 'EX'))] = TRUE
total_threatened = sum(threatened)

native_tree = rep(FALSE, nrow(Tree_existing))
native_tree[which(Tree_existing$native == 'Native')] = TRUE
total_native= sum(native_tree)


# interest = Tree_existing[which(endemic|threatened),]
# BB = interest[c('TaxonNameFull', 'endemic', 'threatened', 'geography_codes')]
total_threat_endemic = sum(endemic & threatened)
total_threat_native = sum(native_tree & threatened)
total_native_endemic = sum(endemic & native_tree)
total_threat_endemic_native = sum(endemic & threatened & native_tree)


need_venn = total_endemic > 0 | total_threatened > 0 | total_native > 0
overlap = FALSE
if(total_threat_endemic > 0 | total_threat_native > 0 | total_native_endemic > 0){
  overlap = TRUE
}
```

In this section we find the subsets of trees that are native, endemic or threatened and how these sets overlap. Below we produce Venn diagrams at both the items and species level of trees split into these categories.

`r if(report_kind == 'interactive'){"#####  {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Items"}`
```{r, Items of tree by native, endemic and threatened - Venn Diagram, echo = FALSE, results='hide',fig.keep='all', message=FALSE, fig.dim=c(4,4), fig.align = 'center', eval = report_kind == 'interactive'}
if(T){
  library("VennDiagram") 

# move to new plotting page 
grid.newpage() 

# create pairwise Venn diagram 
# draw.pairwise.venn(area1=total_endemic, area2=total_threatened,cross.area=total_threat_endemic, 
#                    category=c("Endemic","Threatened"),fill=c("Yellow", "Red"))

VennDiagram::draw.triple.venn(
	area1 = total_native,
	area2 = total_threatened,
	area3 = total_endemic,
	n12 = total_threat_native,
	n23 = total_threat_endemic,
	n13 = total_native_endemic,
	n123 = total_threat_endemic_native,
	category = c("Native", "Threatened", "Endemic"),
	fill = interactive_colour(3), #|> BGSmartR::add_alpha(alpha = 0.4),
	# col =  interactive_colour(3),
	euler.d = FALSE,
	lwd = 1,
	cex = 1.1,
	cat.cex = 1.1,
	# cat.fontface = "bold",
  cat.default.pos = "outer",
  cat.dist = c(0.1, 0.1, 0.1),
	# cat.col =  interactive_colour(3),
	margin = 0.1,
	scaled = FALSE,
	main.fontfamily = "arial",
  main.fontface = "sans"
	)

      if(separate_figure_folder){
ggplot2::ggsave(filename = paste0(figures_dir, '/','Native_threatened_endemic_Venn_diagram_items.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
}

```

`r if(report_kind == 'interactive' & do_over_time){"###### Species"}`
```{r, Species of tree by native, endemic and threatened - Venn Diagram, echo = FALSE, results='hide',fig.keep='all', message=FALSE, fig.dim=c(4,4), fig.align = 'center', eval = report_kind == 'interactive'}
if(T){
  Tree_existing_species <- Tree_existing[match(unique(Tree_existing$best_name),Tree_existing$best_name), ]
  
  
  endemic_species = rep(FALSE, nrow(Tree_existing_species))
endemic_species[which(Tree_existing_species$endemic == 'Endemic')] = TRUE
total_endemic = sum(endemic_species)

threatened_species = rep(FALSE, nrow(Tree_existing_species))
threatened_species[which(Tree_existing_species$POWO_Red_category %in% c('EN', 'VU', 'CR', 'EW', 'EX'))] = TRUE
threatened_species[which(Tree_existing_species$redList_category %in% c('EN', 'VU', 'CR', 'EW', 'EX'))] = TRUE
total_threatened = sum(threatened_species)

native_tree_species = rep(FALSE, nrow(Tree_existing_species))
native_tree_species[which(Tree_existing_species$native == 'Native')] = TRUE
total_native= sum(native_tree_species)


# interest = Tree_existing_species[which(endemic|threatened),]
# BB = interest[c('TaxonNameFull', 'endemic', 'threatened', 'geography_codes')]
total_threat_endemic = sum(endemic_species & threatened_species)
total_threat_native = sum(native_tree_species & threatened_species)
total_native_endemic = sum(endemic_species & native_tree_species)
total_threat_endemic_native = sum(endemic_species & threatened_species & native_tree_species)

  
  library("VennDiagram") 

# move to new plotting page 
grid.newpage() 

# create pairwise Venn diagram 
# draw.pairwise.venn(area1=total_endemic, area2=total_threatened,cross.area=total_threat_endemic, 
#                    category=c("Endemic","Threatened"),fill=c("Yellow", "Red"))

draw.triple.venn(
	area1 = total_native,
	area2 = total_threatened,
	area3 = total_endemic,
	n12 = total_threat_native,
	n23 = total_threat_endemic,
	n13 = total_native_endemic,
	n123 = total_threat_endemic_native,
	category = c("Native", "Threatened", "Endemic"),
	fill =  interactive_colour(3), #|> BGSmartR::add_alpha(alpha = 0.4),
	# col =  interactive_colour(3),
	euler.d = FALSE,
	lwd = 1,
	cex = 1.1,
	cat.cex = 1.1,
	# cat.fontface = "bold",
  cat.default.pos = "outer",
  cat.dist = c(0.1, 0.1, 0.1),
	# cat.col =  interactive_colour(3),
	margin = 0.1,
	scale = F,
	main.fontfamily = "arial",
  main.fontface = "sans"
	)

      if(separate_figure_folder){
ggplot2::ggsave(filename = paste0(figures_dir, '/','Native_threatened_endemic_Venn_diagram_items.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
    }
}

```

`r if(report_kind == 'interactive' & do_over_time){"##### {-}"}`


`r if(need_venn){"For these native and endemic/threatened plants we produce a table below detailing how many of each species is in the collection together with the accession number and when each item was last checked."}`

```{r, Among the native plants in a LC, how many of them are endemic or redlisted - get important taxa, ft.keepnext = FALSE, eval = need_venn}
if('ItemAccNoFull' %in% names(Tree_existing)){
  acc_item = Tree_existing$ItemAccNoFull
}else{
  acc_item = Tree_existing$AccNoFull
}
accessions = Tree_existing$AccNoFull
taxa = paste0(Tree_existing$POWO_taxon_name, ' ', Tree_existing$POWO_taxon_authors)
ItemStatusDate = Tree_existing$ItemStatusDate

data = data.frame(accessions =accessions, 
                  taxa = taxa,
                  ItemStatusDate = ItemStatusDate, 
                  endemic = endemic, 
                  threatened = threatened,
                  native_tree = native_tree,
                  acc_item = acc_item)
data_compressed <- data |>
  dplyr::group_by(.data$taxa) |>
  dplyr::summarise(endemic = .data$endemic[1],
                   threatened = .data$threatened[1],
                   native_tree = .data$native_tree[1],
                   Items = length(.data$ItemStatusDate)
                   
  ) |>
  dplyr::ungroup()

data_compressed = data_compressed[data_compressed$endemic | data_compressed$threatened | data_compressed$native_tree,]

endemic_val = rep('No', nrow(data_compressed))
endemic_val[data_compressed$endemic] = 'Yes'
data_compressed$endemic = endemic_val

threat_val = rep('No', nrow(data_compressed))
threat_val[data_compressed$threatened] = 'Yes'
data_compressed$threatened = threat_val

threat_val = rep('No', nrow(data_compressed))
threat_val[data_compressed$native_tree] = 'Yes'
data_compressed$native_tree = threat_val

 names(data_compressed) = c("Taxa", "Endemic", "Threatened", "Native", "Number of items" )

if(export_data){
  exporting_data_store$Detail_threatened_and_endemic_native_plants_in_LC = data.frame(data_compressed)
}


```

```{r, Among the native plants in a LC, how many of them are endemic or redlisted - table, ft.keepnext = FALSE, eval = need_venn}
if(report_kind == 'static'){
  data_compressed |>
  flextable() |>
  set_caption(caption = paste0('Endemic and threatened plants in the native sub-collection')) |> 
  font(fontname = "Calibri (Body)", part = "all") |> 
  fontsize(size = table_font_size, part = "body") |> 
  # add footer if you want
  # add_footer_row(values = "* p < 0.05. ** p < 0.01. *** p < 0.001.", 
  #                colwidths = 4) |> 
  theme_booktabs() |> # default theme
  autofit() |>
  set_table_properties(width = 1, layout = "autofit")
}
if(report_kind == 'interactive'){
  data_compressed |>  DT::datatable(extensions = 'Buttons',
                  rownames = FALSE,
                  options = list(scrollX = TRUE,
                                 pageLength = min(nrow(data_compressed), 10),
                                 dom = 'Btp',
                                 buttons = c('copy', 'csv', 'excel', 'pdf'),
                                 paging=T,
                                 ordering=T),
                  filter = list(position = "top"))
}

```

:::: {.blackbox data-latex=""}

For further information you can download the endemic/threatened native plants using the button below. 


```{r link to download  threatened/endemic native plants, eval = report_kind == 'interactive'}
data_save = data
data_save = data_save[data_save$endemic | data_save$threatened | data_save$native_tree,]
data_save = data_save[order(data_save$taxa),]

endemic_val = rep('No', nrow(data_save))
endemic_val[data_save$endemic] = 'Yes'
data_save$endemic = endemic_val

threat_val = rep('No', nrow(data_save))
threat_val[data_save$threatened] = 'Yes'
data_save$threatened = threat_val

threat_val = rep('No', nrow(data_save))
threat_val[data_save$native_tree] = 'Yes'
data_save$native_tree = threat_val

data_save = data_save[,c(7,2:6)]
names(data_save) = c("Accession + Item Number", "Taxonomic Name", "ItemStatusDate","Is endemic?", "Is Threatened?","Is Native?" )

data_save |>
  download_this(
    output_name = "Native, Endemic or threatened Trees in the LC",
    output_extension = ".xlsx",
    button_label = "Download native, endemic and threatened trees (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained =  T
  )
```

::::

***
