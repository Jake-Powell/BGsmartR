---
title: "Data health of the LC and enhancement"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(plotly)
library(htmltools)
library(sf)
library(here)
library(flextable)
library(ggrepel)
```

```{r, imported parameters}
# Inputs
# As an input we get 
# - Enriched report
# - collection the name to be printed in the report.
load("/Users/jakepowell/Cambridge/Enriched_reports_Jake/CUBG_June2023_enriched_report.rda")
coordinates = c(52.19375565279363, 0.1277770504441467)
collection = 'CUBG'

separate_figure_folder = FALSE
output_dir = getwd()
load('/Users/jakepowell/Cambridge/Geography Module/wgsrpd3.rda')
# load('/Users/jakepowell/Cambridge/Modules/Basic Stats/wgsrpd3.rda)
report_kind = 'static'
native = 'Naturally occurring only'
extinct = TRUE
doubtful_locations = FALSE
ggtheme = NULL
value_on_fig = TRUE
```

```{r theme_ggplot2}
library(ggplot2)
# Changing the default theme
if(is.null(ggtheme)){
   ggtheme <- function(base_size = 16) {
      ggplot2::theme_bw(base_size = base_size) %+replace%
        ggplot2::theme(
          plot.title = ggplot2::element_text(size = rel(1), face = "bold", margin = margin(0,0,5,0), hjust = 0),
          panel.grid.minor = ggplot2::element_blank(),
          panel.background = element_rect(fill = 'transparent', color = NA),
          panel.border = ggplot2::element_blank(),
          axis.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
          axis.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
          axis.line = ggplot2::element_line(color = "black"),
          legend.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
          legend.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
          legend.key = ggplot2::element_rect(fill = "transparent", colour = NA),
          legend.key.size = ggplot2::unit(1.5, "lines"),
          legend.background = ggplot2::element_rect(fill = "transparent", colour = NA),
          strip.background = ggplot2::element_rect(fill = "#17252D", color = "#17252D"),
          strip.text = ggplot2::element_text(size = rel(0.85), face = "bold", color = "white", margin = margin(5,0,5,0))
        )
    }
}
theme_set(ggtheme())
update_geom_defaults("line", list(size = 2))

# Set the colour scale for the plots
scale_colour_continuous <- scale_colour_continuous
scale_colour_discrete   <- scale_colour_discrete
scale_colour_binned     <- scale_colour_binned
scale_fill_continuous <- scale_fill_continuous
scale_fill_discrete <- scale_fill_discrete
scale_fill_binned <- scale_fill_binned
```

```{r, onRender text}
render_barplot ="
    function(el) { 
    console.log(el)
      el.on('plotly_hover', function(data){
  var pn='',
      tn='',
      colors=[];
  for(var i=0; i < data.points.length; i++){
    pn = data.points[i].pointNumber;
    tn = data.points[i].curveNumber;
    colors = data.points[i].data.marker.color;
  };
  colors[pn] = '#31a354';
    
  var update = {'marker':{color: colors}};
  Plotly.restyle(el.id, update, [tn]);
});
      el.on('plotly_unhover', function(data){
  var pn='',
      tn='',
      colors=[];
  for(var i=0; i < data.points.length; i++){
    pn = data.points[i].pointNumber;
    tn = data.points[i].curveNumber;
    colors = data.points[i].data.marker.color;
  };
  colors[pn] = '#addd8e';
  var update = {'marker':{color: colors}};
  Plotly.restyle(el.id, update, [tn]);
});
    }
  "
```

```{r, Add combined geography column to enriched report}
geography_data = enriched_report[,grepl('_area_code_l3', names(enriched_report))]
want = c('000','010','001','011','100','110','101')

#Depending on the values of the options reduce `want` to only the satisfactory values.
##A) introduced / naturally occurring only.
if(native == 'Introduced only'){
 want = want[grepl('^1',want)]
}else if(native == 'Naturally occurring only'){
 want = want[grepl('^0',want)]
}
## B) Extinct
if(!extinct){
 want = want[!grepl('010|011|110',want)]
}
## C) Doubtful
if(!doubtful_locations){
 want = want[!grepl('001|011|101',want)]
}
# Get the columns in wanted info that contain the geography information we want.
geography_data = geography_data[,grepl(paste0(want,collapse='|'), names(geography_data))]

if(length(want) > 1){
 level3codes =do.call("paste", c(geography_data, sep = ", "))
 level3codes = stringr::str_remove(level3codes, ', NA$')
 level3codes = stringr::str_remove(level3codes, 'NA, ')
}else{
 level3codes = geography_data
}
level3codes[level3codes == "NA"] = NA

enriched_report$geography_codes = level3codes
```

`r if(any(!c('AccNoFull', 'Family', 'Genus', 'GenusSpecies', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"*** \n **Warning!**\n\n This enriched report contains missing 'original' columns needed to perform the analyses in this report. Default values have been created. In particular, the following were missing "}`

`r if(!'AccNoFull' %in% names(enriched_report)){"- AccNoFull: Each item is assumed to be a unique accession.\n"}`
`r if(!'Family' %in% names(enriched_report)){"- Family: Only families found by matching to POWO will be used (No non-vascular families). \n"}`
`r if(!'Genus' %in% names(enriched_report)){"- Genus: Only genera found by matching to POWO will be used."}`
`r if(!'GenusSpecies' %in% names(enriched_report)){"- GenusSpecies: Only species found in POWO will be used."}`
`r if(!'AccYear' %in% names(enriched_report)){"- AccYear: All Accession years set to missing. \n"}`
`r if(!'ItemStatusDate' %in% names(enriched_report)){"- ItemStatusDate: All set to missing. \n"}`
`r if(!'ItemStatusType' %in% names(enriched_report)){"- ItemStatusType: All set to exisiting. \n"}`

`r if(any(!c('AccNoFull', 'Family', 'Genus', 'GenusSpecies', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"***"}`

```{r, Extracting information from enriched report}
# Add required columns if missing.
needed_columns = c('AccNoFull', 'Family', 'Genus', 'GenusSpecies', 'AccYear', 'ItemStatusDate', 'ItemStatusType')
if(!'AccNoFull' %in% names(enriched_report)){
  enriched_report$AccNoFull = 1:nrow(enriched_report)
}
if(!'Family' %in% names(enriched_report)){
  enriched_report$Family =rep(NA, nrow(enriched_report))
}
if(!'Genus' %in% names(enriched_report)){
  enriched_report$Genus = rep(NA, nrow(enriched_report))
}
if(!'GenusSpecies' %in% names(enriched_report)){
  enriched_report$GenusSpecies = rep(NA, nrow(enriched_report))
}
if(!'AccYear' %in% names(enriched_report)){
  enriched_report$AccYear = rep(0, nrow(enriched_report))
}
if(!'ItemStatusDate' %in% names(enriched_report)){
  enriched_report$ItemStatusDate = rep(0, nrow(enriched_report))
}
if(!'ItemStatusType' %in% names(enriched_report)){
  enriched_report$ItemStatusType = rep('Existing', nrow(enriched_report))
}

do_coord = !is.na(coordinates[1])
# Set report to only the existing items.
report = enriched_report[enriched_report$ItemStatusType == 'Existing',]

#Extract endemic information from report
endemic = rep('Not Endemic', nrow(report))
endemic_index = which(stringr::str_length(report$geography_codes) == 3)
endemic[endemic_index] = 'Endemic'
report$endemic = endemic
rm(endemic)

# Extract threatened. 
threat_cat = c('VU','EN','CR','EW','EX')
threatened = rep('Not Threatened', nrow(report))
threatened[which(report$redList_category %in% threat_cat)] = 'Threatened'
threatened[which(report$POWO_Red_category %in% threat_cat)] = 'Threatened'
report$threatened = threatened
rm(threatened)

# Extract threatened category. 
threatened_category = rep(NA, nrow(report))
for(i in 1:length(threat_cat)){
 threatened_category[which(report$redList_category == threat_cat[i])] = threat_cat[i]
 threatened_category[which(report$POWO_Red_category == threat_cat[i])] = threat_cat[i]
}
report$threatened_category = threatened_category
rm(threatened_category)

# Convert Provenance code to text.
report$ProvenanceCode[report$ProvenanceCode == 'G'] = 'Garden'
report$ProvenanceCode[report$ProvenanceCode == 'U'] = 'Unknown'
report$ProvenanceCode[report$ProvenanceCode == 'W'] = 'Wild'
report$ProvenanceCode[report$ProvenanceCode == 'Z'] = 'Wild-derived'

# Create a sanitised taxonomic name.
report$good_name = paste0(report$sanitised_taxon, ' ', report$extracted_author)

best_name = paste0(report$POWO_taxon_name, ' ', report$POWO_taxon_authors)
best_name[which(best_name == 'NA NA')] = report$good_name[which(best_name == 'NA NA')]
report$good_name = paste0(report$sanitised_taxon, ' ', report$extracted_author)

report_original = report

if(separate_figure_folder){
  figures_dir = paste0(output_dir,'/',collection,'_Figures')
  dir.create(figures_dir,showWarnings = FALSE)
}

# Extract the location of the collection.
pnts <- data.frame(x = coordinates[1], y = coordinates[2])

# create a points collection
pnts_sf <- do.call("st_sfc",c(lapply(1:nrow(pnts), 
                                     function(i) {sf::st_point(as.numeric(pnts[i, ]))}), list("crs" = 4326))) 

pnts_trans <- st_transform(pnts_sf, 2163) # apply transformation to pnts sf
tt1_trans <- st_transform(wgsrpd3, 2163)      # apply transformation to polygons sf

intersect = as.vector(st_intersects(tt1_trans, pnts_trans, sparse = FALSE))
collection_geog_details = wgsrpd3[which(intersect),-5]
level3_name = collection_geog_details$LEVEL3_NAM
level3_code = collection_geog_details$LEVEL3_COD

```

```{r, Get location_type_text}
location_type_text = ''
if(native == 'Naturally occurring only'){
 location_type_text = paste0(location_type_text, 'naturally occuring only,', collapse = ' ')  
}else if(native == 'Introduced only'){
  location_type_text = paste0(location_type_text, 'introduced only,', collapse = ' ')  
 
}else{
  location_type_text = paste0(location_type_text, 'Either naturally occurring or introduced,', collapse = ' ')  
}
if(extinct){
   location_type_text = paste0(location_type_text, ' allowing extinct regions and', collapse = ' ')  
}else{
  location_type_text = paste0(location_type_text, ' not including extinct regions and', collapse = ' ')  
}
if(doubtful_locations){
   location_type_text = paste0(location_type_text, ' allowing doubtful regions.', collapse = ' ')  
 
}else{
  location_type_text = paste0(location_type_text, ' not allowing doubtful regions.', collapse = ' ')  
}
```

```{r, Find LC location}
coord_contained = TRUE
# Extract the location of the collection.
pnts <- data.frame( x = coordinates[2], y = coordinates[1])

# create a points collection
pnts_sf <- do.call("st_sfc",c(lapply(1:nrow(pnts), 
                                     function(i) {sf::st_point(as.numeric(pnts[i, ]))}), list("crs" = 4326))) 

pnts_trans <- st_transform(pnts_sf, 2163) # apply transformation to pnts sf
tt1_trans <- st_transform(wgsrpd3, 2163)      # apply transformation to polygons sf

intersect = as.vector(st_intersects(tt1_trans, pnts_trans, sparse = FALSE))
collection_geog_details = wgsrpd3[which(intersect),-5]
location_name = collection_geog_details$LEVEL3_NAM
location_code = collection_geog_details$LEVEL3_COD

if(length(location_name) == 0){
  coord_contained = FALSE
  # Try and find the nearest polygon.
  collection_geog_details  =  wgsrpd3[which.min(as.vector(sf::st_distance(tt1_trans, pnts_trans))),-5]
  location_name = collection_geog_details$LEVEL3_NAM
  location_code = collection_geog_details$LEVEL3_COD
}
```

This report explores data health within `r collection`, and data enhancement.

### Where is the LC? 


 To determine the geographic distribution of items in the LC we enrich with information from [Plants of the World Online](https://powo.science.kew.org), by matching taxonomic names. POWO uses [TDWG geographical codes](https://www.tdwg.org/standards/wgsrpd/) (Brummitt, 2001) expressed to that system's third level. This splits the world into 369 regions. Thus, each accepted name in POWO is associated with a list of geographic regions. POWO splits the geographic regions associated with a taxa by three conditions:

- Native / introduced,
- Extinct / Not extinct,
- Location is doubtful / otherwise.

This document considers locations that are : `r location_type_text` 
 
`r if(coord_contained){paste0("Within TDWG geographical codes ",collection," is  found within the region ",location_name,".")}`
`r if(!coord_contained){paste0("Within TDWG geographical codes ",collection," is not found within any regions, however the nearest region is ",location_name,".")}`
Therefore, any taxa whose geographic distribution includes `r location_name` is classed as native to the LC. Otherwise taxa are classed as non-native.

The location of the LC and the native region are shown below.

```{r, LC location and native region plot, fig.fullwidth=TRUE, fig.dim = c(10, 6), results='hide',fig.keep='all', message=FALSE}
collection_geog_details$occurrence_type = 'native'
lims <- st_bbox(collection_geog_details)
p <- rWCVP::wcvp_distribution_map(collection_geog_details, crop_map=TRUE) + 
  theme(legend.position="none") +
  geom_sf(data=pnts_sf, fill="purple",col="purple", shape=20, size = 3) +
  coord_sf(xlim=lims[c(1,3)], ylim=lims[c(2,4)]) +
  theme(legend.position = "none",
        axis.line=element_blank(),
        axis.text.x=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks=element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        plot.title = element_text(hjust = 0.5))

if(separate_figure_folder){
ggplot2::ggsave(plot = p, filename = paste0(figures_dir, '/','Map_LC_location_and_native region.pdf'),device = 'pdf', scale = 1, limitsize = FALSE)
}

p
```





## Taxonomic Standardisation

