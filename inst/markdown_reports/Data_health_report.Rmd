---
title: "Data health and enhancement"
output: html_document
always_allow_html: true
---

###### {-} 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(plotly)
library(htmltools)
library(sf)
library(here)
library(flextable)
library(ggrepel)
library(downloadthis)

interactive_colour <- function(n){
  color = c('#f46d43', "#FDAE6B", '#848484', '#e6e6e6')
  if(n==2){
    return(color[c(1,4)])
  }
  color[1:n]
}

color_binary <- rev(c('#f46d43', '#848484'))
palette = 'Oranges'
```


```{r, imported parameters}
# Inputs
# As an input we get 
# - Enriched report
# # - collection the name to be printed in the report.
# load("/Users/jakepowell/Cambridge/Enriched_reports_Jake/CUBG_May2024_enriched_report.rda")
# # coordinates = c(52.19375565279363, 0.1277770504441467)
# collection = 'CUBG'
# 
# separate_figure_folder = FALSE
# output_dir = getwd()
# load('/Users/jakepowell/Cambridge/Geography Module/wgsrpd3.rda')
# # load('/Users/jakepowell/Cambridge/Modules/Basic Stats/wgsrpd3.rda)
# report_kind = 'interactive'
# native = 'Naturally occurring only'
# extinct = TRUE
# doubtful_locations = FALSE
# ggtheme = NULL
# value_on_fig = TRUE
```

```{css, echo = FALSE}
/* from https://ianlunn.github.io/Hover/ */
.hvr-sweep-to-left {
  display: inline-block;
  vertical-align: middle;
  -webkit-transform: perspective(1px) translateZ(0);
  transform: perspective(1px) translateZ(0);
  box-shadow: 0 0 1px rgba(0, 0, 0, 0);
  position: relative;
  -webkit-transition-property: color;
  transition-property: color;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
}
.hvr-sweep-to-left:before {
  content: "";
  position: absolute;
  z-index: -1;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: #f46d43;
  -webkit-transform: scaleX(0);
  transform: scaleX(0);
  -webkit-transform-origin: 100% 50%;
  transform-origin: 100% 50%;
  -webkit-transition-property: transform;
  transition-property: transform;
  -webkit-transition-duration: 0.3s;
  transition-duration: 0.3s;
  -webkit-transition-timing-function: ease-out;
  transition-timing-function: ease-out;
}
.hvr-sweep-to-left:hover, .hvr-sweep-to-left:focus, .hvr-sweep-to-left:active {
  color: white;
}
.hvr-sweep-to-left:hover:before, .hvr-sweep-to-left:focus:before, .hvr-sweep-to-left:active:before {
  -webkit-transform: scaleX(1);
  transform: scaleX(1);
}

.blackbox {
  padding: 1em;
  background: #FDAE6B;
  border: 2px solid #e6e6e6;
  border-radius: 10px;
}
.center {
  text-align: center;
}
```

```{r theme_ggplot2}
library(ggplot2)
# Changing the default theme
if(is.null(ggtheme)){
   ggtheme <- function(base_size = 16) {
      ggplot2::theme_bw(base_size = base_size) %+replace%
        ggplot2::theme(
          plot.title = ggplot2::element_text(size = rel(1), face = "bold", margin = margin(0,0,5,0), hjust = 0),
          panel.grid.minor = ggplot2::element_blank(),
          panel.background = element_rect(fill = 'transparent', color = NA),
          panel.border = ggplot2::element_blank(),
          axis.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
          axis.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
          axis.line = ggplot2::element_line(color = "black"),
          legend.title = ggplot2::element_text(size = rel(0.85), face = "bold"),
          legend.text = ggplot2::element_text(size = rel(0.70), face = "bold"),
          legend.key = ggplot2::element_rect(fill = "transparent", colour = NA),
          legend.key.size = ggplot2::unit(1.5, "lines"),
          legend.background = ggplot2::element_rect(fill = "transparent", colour = NA),
          strip.background = ggplot2::element_rect(fill = "#17252D", color = "#17252D"),
          strip.text = ggplot2::element_text(size = rel(0.85), face = "bold", color = "white", margin = margin(5,0,5,0))
        )
    }
}
theme_set(ggtheme())
update_geom_defaults("line", list(size = 2))

# Set the colour scale for the plots
scale_colour_continuous <- scale_colour_continuous
scale_colour_discrete   <- scale_colour_discrete
scale_colour_binned     <- scale_colour_binned
scale_fill_continuous <- scale_fill_continuous
scale_fill_discrete <- scale_fill_discrete
scale_fill_binned <- scale_fill_binned
```

```{r, onRender text}
render_barplot ="
    function(el) { 
    console.log(el)
      el.on('plotly_hover', function(data){
  var pn='',
      tn='',
      colors=[];
  for(var i=0; i < data.points.length; i++){
    pn = data.points[i].pointNumber;
    tn = data.points[i].curveNumber;
    colors = data.points[i].data.marker.color;
  };
  colors[pn] = '#31a354';
    
  var update = {'marker':{color: colors}};
  Plotly.restyle(el.id, update, [tn]);
});
      el.on('plotly_unhover', function(data){
  var pn='',
      tn='',
      colors=[];
  for(var i=0; i < data.points.length; i++){
    pn = data.points[i].pointNumber;
    tn = data.points[i].curveNumber;
    colors = data.points[i].data.marker.color;
  };
  colors[pn] = '#addd8e';
  var update = {'marker':{color: colors}};
  Plotly.restyle(el.id, update, [tn]);
});
    }
  "

icon_svg_path = "M15.608,6.262h-2.338v0.935h2.338c0.516,0,0.934,0.418,0.934,0.935v8.879c0,0.517-0.418,0.935-0.934,0.935H4.392c-0.516,0-0.935-0.418-0.935-0.935V8.131c0-0.516,0.419-0.935,0.935-0.935h2.336V6.262H4.392c-1.032,0-1.869,0.837-1.869,1.869v8.879c0,1.031,0.837,1.869,1.869,1.869h11.216c1.031,0,1.869-0.838,1.869-1.869V8.131C17.478,7.099,16.64,6.262,15.608,6.262z M9.513,11.973c0.017,0.082,0.047,0.162,0.109,0.226c0.104,0.106,0.243,0.143,0.378,0.126c0.135,0.017,0.274-0.02,0.377-0.126c0.064-0.065,0.097-0.147,0.115-0.231l1.708-1.751c0.178-0.183,0.178-0.479,0-0.662c-0.178-0.182-0.467-0.182-0.645,0l-1.101,1.129V1.588c0-0.258-0.204-0.467-0.456-0.467c-0.252,0-0.456,0.209-0.456,0.467v9.094L8.443,9.553c-0.178-0.182-0.467-0.182-0.645,0c-0.178,0.184-0.178,0.479,0,0.662L9.513,11.973z"

dl_button <- list(
    name = "Download data",
    icon = list(
        path = icon_svg_path,
        transform = "scale(0.84) translate(-1, -1)"
        ),
    click = htmlwidgets::JS("
          function(gd) {
            var text = '';
            for(var i = 0; i < gd.data.length; i++){
              text += gd.layout.xaxis.title.text + gd.data[i].name + ',' + gd.data[i].x + '\\n';
              text += gd.layout.yaxis.title.text + gd.data[i].name + ',' + gd.data[i].y + '\\n';
            };
            var blob = new Blob([text], {type: 'text/plain'});
            var a = document.createElement('a');
            const object_URL = URL.createObjectURL(blob);
            a.href = object_URL;
            a.download = 'data.csv';
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(object_URL);
          }
   ")
)

dl_button_map <- list(
    name = "Download data",
    icon = list(
        path = icon_svg_path,
        transform = "scale(0.84) translate(-1, -1)"
        ),
    click = htmlwidgets::JS("
          function(gd) {
            var text = '';
            for(var i = 0; i < gd.data.length; i++){
              text += gd.layout.xaxis.title.text + gd.data[i].name + ',' + gd.data[i].z + '\\n';
              text += gd.layout.yaxis.title.text + gd.data[i].name + ',' + gd.data[i].hovertext + '\\n';
            };
            var blob = new Blob([text], {type: 'text/plain'});
            var a = document.createElement('a');
            const object_URL = URL.createObjectURL(blob);
            a.href = object_URL;
            a.download = 'data.csv';
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(object_URL);
          }
   ")
)
```

```{r, Add combined geography column to enriched report}
geography_data = enriched_report[,grepl('_area_code_l3', names(enriched_report))]
want = c('000','010','001','011','100','110','101')

#Depending on the values of the options reduce `want` to only the satisfactory values.
##A) introduced / naturally occurring only.
if(native == 'Introduced only'){
 want = want[grepl('^1',want)]
}else if(native == 'Naturally occurring only'){
 want = want[grepl('^0',want)]
}
## B) Extinct
if(!extinct){
 want = want[!grepl('010|011|110',want)]
}
## C) Doubtful
if(!doubtful_locations){
 want = want[!grepl('001|011|101',want)]
}
# Get the columns in wanted info that contain the geography information we want.
geography_data = geography_data[,grepl(paste0(want,collapse='|'), names(geography_data))]

if(length(want) > 1){
 level3codes =do.call("paste", c(geography_data, sep = ", "))
 level3codes = stringr::str_remove(level3codes, ', NA$')
 level3codes = stringr::str_remove(level3codes, 'NA, ')
}else{
 level3codes = geography_data
}
level3codes[level3codes == "NA"] = NA

enriched_report$geography_codes = level3codes
```

`r if(any(!c('AccNoFull', 'Family', 'Genus', 'GenusSpecies', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"*** \n **Warning!**\n\n This enriched report contains missing 'original' columns needed to perform the analyses in this report. Default values have been created. In particular, the following were missing "}`

`r if(!'AccNoFull' %in% names(enriched_report)){"- AccNoFull: Each item is assumed to be a unique accession.\n"}`
`r if(!'Family' %in% names(enriched_report)){"- Family: Only families found by matching to WCVP will be used (No non-vascular families). \n"}`
`r if(!'Genus' %in% names(enriched_report)){"- Genus: Only genera found by matching to WCVP will be used."}`
`r if(!'GenusSpecies' %in% names(enriched_report)){"- GenusSpecies: Only species found in WCVP will be used."}`
`r if(!'AccYear' %in% names(enriched_report)){"- AccYear: All Accession years set to missing. \n"}`
`r if(!'ItemStatusDate' %in% names(enriched_report)){"- ItemStatusDate: All set to missing. \n"}`
`r if(!'ItemStatusType' %in% names(enriched_report)){"- ItemStatusType: All set to exisiting. \n"}`

`r if(any(!c('AccNoFull', 'Family', 'Genus', 'GenusSpecies', 'AccYear', 'ItemStatusDate', 'ItemStatusType') %in% names(enriched_report))){"***"}`

```{r, Get location_type_text}
location_type_text = ''
if(native == 'Naturally occurring only'){
 location_type_text = paste0(location_type_text, 'naturally occuring only,', collapse = ' ')  
}else if(native == 'Introduced only'){
  location_type_text = paste0(location_type_text, 'introduced only,', collapse = ' ')  
 
}else{
  location_type_text = paste0(location_type_text, 'Either naturally occurring or introduced,', collapse = ' ')  
}
if(extinct){
   location_type_text = paste0(location_type_text, ' allowing extinct regions and', collapse = ' ')  
}else{
  location_type_text = paste0(location_type_text, ' not including extinct regions and', collapse = ' ')  
}
if(doubtful_locations){
   location_type_text = paste0(location_type_text, ' allowing doubtful regions.', collapse = ' ')  
 
}else{
  location_type_text = paste0(location_type_text, ' not allowing doubtful regions.', collapse = ' ')  
}
```

```{r, Find LC location}
coord_contained = TRUE
# Extract the location of the collection.
pnts <- data.frame( x = coordinates[2], y = coordinates[1])

# create a points collection
pnts_sf <- do.call("st_sfc",c(lapply(1:nrow(pnts), 
                                     function(i) {sf::st_point(as.numeric(pnts[i, ]))}), list("crs" = 4326))) 

pnts_trans <- st_transform(pnts_sf, 2163) # apply transformation to pnts sf
tt1_trans <- st_transform(wgsrpd3, 2163)      # apply transformation to polygons sf

intersect = as.vector(st_intersects(tt1_trans, pnts_trans, sparse = FALSE))
collection_geog_details = wgsrpd3[which(intersect),-5]
location_name = collection_geog_details$LEVEL3_NAM
location_code = collection_geog_details$LEVEL3_COD

if(length(location_name) == 0){
  coord_contained = FALSE
  # Try and find the nearest polygon.
  collection_geog_details  =  wgsrpd3[which.min(as.vector(sf::st_distance(tt1_trans, pnts_trans))),-5]
  location_name = collection_geog_details$LEVEL3_NAM
  location_code = collection_geog_details$LEVEL3_COD
}
 collection_geog_details_og = collection_geog_details
```

```{r, Extracting information from enriched report}
# Add required columns if missing.
needed_columns = c('AccNoFull', 'Family', 'Genus', 'GenusSpecies', 'AccYear', 'ItemStatusDate', 'ItemStatusType')
if(!'AccNoFull' %in% names(enriched_report)){
  enriched_report$AccNoFull = 1:nrow(enriched_report)
}
if(!'Family' %in% names(enriched_report)){
  enriched_report$Family =rep(NA, nrow(enriched_report))
}
if(!'Genus' %in% names(enriched_report)){
  enriched_report$Genus = rep(NA, nrow(enriched_report))
}
if(!'GenusSpecies' %in% names(enriched_report)){
  enriched_report$GenusSpecies = rep(NA, nrow(enriched_report))
}
if(!'AccYear' %in% names(enriched_report)){
  enriched_report$AccYear = rep(0, nrow(enriched_report))
}
if(!'ItemStatusDate' %in% names(enriched_report)){
  enriched_report$ItemStatusDate = rep(0, nrow(enriched_report))
}
if(!'ItemStatusType' %in% names(enriched_report)){
  enriched_report$ItemStatusType = rep('Existing', nrow(enriched_report))
}

do_coord = !is.na(coordinates[1])
# Set report to only the existing items.
report = enriched_report

#Extract endemic information from report
endemic = rep('Not Endemic', nrow(report))
endemic_index = which(stringr::str_length(report$geography_codes) == 3)
endemic[endemic_index] = 'Endemic'
report$endemic = endemic
rm(endemic)

# Add native column.
nativeo = rep('Widespread', nrow(report))
native_index = which(grepl(location_code, report$geography_codes))
nativeo[native_index] = 'Native'
report$native = nativeo
rm(nativeo)

# Extract threatened. 
threat_cat = c('VU','EN','CR','EW','EX')
threatened = rep('Not Threatened', nrow(report))
threatened[which(report$redList_category %in% threat_cat)] = 'Threatened'
threatened[which(report$POWO_Red_category %in% threat_cat)] = 'Threatened'
report$threatened = threatened
rm(threatened)

# Extract threatened category. 
threatened_category = rep(NA, nrow(report))
for(i in 1:length(threat_cat)){
 threatened_category[which(report$redList_category == threat_cat[i])] = threat_cat[i]
 threatened_category[which(report$POWO_Red_category == threat_cat[i])] = threat_cat[i]
}
report$threatened_category = threatened_category
rm(threatened_category)

# Convert Provenance code to text.
report$ProvenanceCode[report$ProvenanceCode == 'G'] = 'Garden'
report$ProvenanceCode[report$ProvenanceCode == 'U'] = 'Unknown'
report$ProvenanceCode[report$ProvenanceCode == 'W'] = 'Wild'
report$ProvenanceCode[report$ProvenanceCode == 'Z'] = 'Wild-derived'

# Create a sanitised taxonomic name.
report$good_name = paste0(report$sanitised_taxon, ' ', report$extracted_author)

best_name = paste0(report$POWO_taxon_name, ' ', report$POWO_taxon_authors)
best_name[which(best_name == 'NA NA')] = report$good_name[which(best_name == 'NA NA')]
report$best_name = best_name
report$good_name = paste0(report$sanitised_taxon, ' ', report$extracted_author)

report_original = report

report = report[report$ItemStatusType == 'Existing',]

if(separate_figure_folder){
  figures_dir = paste0(output_dir,'/',collection,'_Figures')
  dir.create(figures_dir,showWarnings = FALSE)
}

# # Extract the location of the collection.
# pnts <- data.frame(x = coordinates[1], y = coordinates[2])
# 
# # create a points collection
# pnts_sf <- do.call("st_sfc",c(lapply(1:nrow(pnts), 
#                                      function(i) {sf::st_point(as.numeric(pnts[i, ]))}), list("crs" = 4326))) 
# 
# pnts_trans <- st_transform(pnts_sf, 2163) # apply transformation to pnts sf
# tt1_trans <- st_transform(wgsrpd3, 2163)      # apply transformation to polygons sf
# 
# intersect = as.vector(st_intersects(tt1_trans, pnts_trans, sparse = FALSE))
# collection_geog_details = wgsrpd3[which(intersect),-5]
# level3_name = collection_geog_details$LEVEL3_NAM
# level3_code = collection_geog_details$LEVEL3_COD

```


This report explores data health within `r collection`, and routes to data enhancement.


## Taxonomic Standardisation

```{r taxonomic standardisation information}
### Reduce to only the fields that we care about.  ----
interest = report[c('TaxonNameFull',
                    'POWO_match_detail',
                    'POWO_match_detail_short',
                    'POWO_author_check',
                    'taxon_type', 
                    'need_sanitise')]
interest_taxa = unique(interest)
### (END) Reduce to only the fields that we care about.  ----


### Get the numbers/stats we want ----
# Number of individuals / taxa
no_items = nrow(interest)
no_taxa = nrow(interest_taxa)

match_without_fix_text = c("SINGLE", "MULTIPLE, AUTHOR", "MULTIPLE, PARTIAL", "MULTIPLE, TAXON_STATUS", "MULTIPLE, SAME_ACC")  
match_without_fix_text = c(match_without_fix_text, paste0(match_without_fix_text, ', ACCEPTED'))


# taxonomic standarisation details (items)
cultivar_indet = sum(interest$POWO_match_detail_short == 'CULT/INDET')
attempted_to_match = no_items - cultivar_indet
match_identical = sum(interest$POWO_match_detail_short %in% match_without_fix_text & interest$POWO_author_check == "Identical")
match_partial =   sum(interest$POWO_match_detail_short %in% match_without_fix_text & interest$POWO_author_check == "Partial")      
match_auth_diff = sum(interest$POWO_match_detail_short %in% match_without_fix_text & interest$POWO_author_check == "Different")        
go_accepted = sum(grepl('ACCEPTED',interest$POWO_match_detail_short))
requiring_fix = sum(grepl('FIX|TYPO',interest$POWO_match_detail_short))
mult_resolve =  sum(grepl('TAXON_STATUS|SAME_ACC|METHOD',interest$POWO_match_detail_short))
mult_no_resolve = sum(grepl('UNCLEAR',interest$POWO_match_detail_short))
no_match = sum(grepl('NO_MATCH',interest$POWO_match_detail_short))
items = c(attempted_to_match, match_identical, match_partial, match_auth_diff, go_accepted, requiring_fix, mult_resolve,mult_no_resolve, no_match)
items = paste0(format(items,big.mark=','), ' (', round(items/(items[1])*100,digits = 2), '%)', sep ='')
items = c(no_items,cultivar_indet,items)
items[1:2] = format(as.numeric(items[1:2]),big.mark=',')


# taxonomic standarisation details (taxa)
cultivar_indet = sum(interest_taxa$POWO_match_detail_short == 'CULT/INDET')
attempted_to_match = no_taxa - cultivar_indet
match_identical = sum(interest_taxa$POWO_match_detail_short %in% match_without_fix_text & interest_taxa$POWO_author_check == "Identical")
match_partial =   sum(interest_taxa$POWO_match_detail_short %in% match_without_fix_text & interest_taxa$POWO_author_check == "Partial")      
match_auth_diff = sum(interest_taxa$POWO_match_detail_short %in% match_without_fix_text & interest_taxa$POWO_author_check == "Different")        
go_accepted = sum(grepl('ACCEPTED',interest_taxa$POWO_match_detail_short))
requiring_fix = sum(grepl('FIX|TYPO',interest_taxa$POWO_match_detail_short))
mult_resolve =  sum(grepl('TAXON_STATUS|SAME_ACC|METHOD',interest_taxa$POWO_match_detail_short))
mult_no_resolve = sum(grepl('UNCLEAR',interest_taxa$POWO_match_detail_short))
no_match = sum(grepl('NO_MATCH',interest_taxa$POWO_match_detail_short))
taxa_info = c(attempted_to_match, match_identical, match_partial, match_auth_diff, go_accepted, requiring_fix, mult_resolve, mult_no_resolve,no_match)
taxa_info = paste0(format(taxa_info,big.mark=','), ' (', round(taxa_info/(taxa_info[1])*100,digits = 2), '%)', sep ='')
taxa_info = c(no_taxa,cultivar_indet,  taxa_info)
taxa_info[1:2] = format(as.numeric(taxa_info[1:2]),big.mark=',')

indet = sum(grepl('0',interest_taxa$taxon_type))
cult = sum(grepl('5',interest_taxa$taxon_type))
sanitised = sum(interest_taxa$need_sanitise[interest_taxa$POWO_match_detail_short != 'CULT/INDET'])
### (END) Get the numbers/stats we want ----

### funnel chart information. ------
# c(cultivar_indet, match_identical, match_partial, match_auth_diff, requiring_fix, mult_no_resolve, no_match) check add to total
funnel_values = c(no_taxa, # total number of taxa
         attempted_to_match,  # total number of taxa after removing cult/indet
         attempted_to_match - match_identical,
         attempted_to_match - match_identical - match_partial,
         attempted_to_match - match_identical - match_partial - mult_no_resolve - no_match,
         requiring_fix + mult_no_resolve + no_match, # the number requiring fixing with those we can't resolve and those we can't match
         mult_no_resolve + no_match, # The number we can't match and those that we can't resolve
         no_match # The number that woe couldn't match
         )
funnel_names = c("All", "Remove Cultivar/Indet", "Exact Match", "Partial Match", "Match, No Author", "Require Fix", "Can't Resolve", "No match")
funnel_data = data.frame(names = funnel_names, values= funnel_values)
funnel_data$percent_total = (funnel_values / funnel_values[1] *100) |> round(digits = 2)
funnel_data$stage_number = c('-',cultivar_indet, match_identical, match_partial, match_auth_diff, requiring_fix, mult_no_resolve, no_match) 
funnel_data$stage_percent = c('-',(as.numeric(funnel_data$stage_number[-1]) / funnel_values[1] *100)|> round(digits = 2))
funnel_data$hover_text = paste0('Stage: ', funnel_data$names, '<br>',
                    'Total enter stage: ', funnel_data$values,  '<br>',
                    'Total in stage: ', funnel_data$stage_number, ' (', funnel_data$stage_percent, '%)', '<br>'
                    )

fig <- plot_ly(data = funnel_data, 
               type = "funnel",
               y = ~names,
               x = ~values,
               hoverinfo = "text", 
               hovertext = ~hover_text,
               marker = list(color = interactive_colour(1))
               ) |>
  layout(yaxis = list(title = '', 
                      categoryarray = c("All", "Remove Cultivar/Indet", "Exact Match", "Partial Match", "Match, No Author", "Require Fix", "Can't Resolve", "No match"))
         )|> 
  config(modeBarButtonsToAdd = list(dl_button), 
         modeBarButtonsToRemove = c('zoom2d','pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale', 'resetScale'))

funnel_fig = fig
### (END) funnel chart information. ------

### Table of the matching information --------
kind = c('All',
         'Cultivars/Indeterminates',
         'Attempted to match to WCVP',
         'Match taxonomic name and author',
         'Match taxonomic name, partial match author',
         'Match taxonomic name, no match author',
         'Matched to a symonym of an accepted name in WCVP',
         'Taxonomic name requires fixing to match',
         'Multiple taxonomic name matches found, resolve via non-author',
         'Multiple taxonomic name matches found, cannot resolve',
         'No match found')

matching_breakdown = data.frame(Group = kind, Individuals = items, Taxa = taxa_info)

# matching_details_table = DT::datatable(matching_breakdown, rownames = FALSE, options = list(scrollX = TRUE,pageLength = nrow(matching_breakdown), dom = 'tp', paging=FALSE))

matching_details_table <- matching_breakdown |>
  DT::datatable(extensions = 'Buttons',
                rownames = FALSE,
                options = list(scrollX = TRUE,
                               pageLength = nrow(matching_breakdown),
                               dom = 'Bt',
                               buttons = c('copy', 'csv', 'excel', 'pdf'),
                               paging=FALSE,
                               ordering=F))
### (END)Table of the matching information --------

### Exportable data frame of the of used name within BGSmartR and the matching process.

export_df = report[c('AccNoFull','TaxonNameFull', 'POWO_match_taxon_name', 'POWO_match_authors', 'POWO_taxon_name', 'POWO_taxon_authors', 'POWO_match_detail_short', 'POWO_author_check')]

export_df$POWO_match_taxon_name = paste0(export_df$POWO_match_taxon_name, ' ', 
                                         export_df$POWO_match_authors)
export_df$POWO_match_authors = NULL
export_df$POWO_match_taxon_name[which(export_df$POWO_match_taxon_name =='NA NA')] = NA 


export_df$POWO_taxon_name = paste0(export_df$POWO_taxon_name, ' ', 
                                         export_df$POWO_taxon_authors)
export_df$POWO_taxon_name[which(export_df$POWO_taxon_name == export_df$POWO_match_taxon_name)] = NA
export_df$POWO_taxon_name[which(export_df$POWO_taxon_name == 'NA NA')] = NA 
export_df$POWO_taxon_authors = NULL


names(export_df) = c('Accession Number',
                     'Original taxonomic name and author',
                     'Matched WCVP taxonomic name and author',
                     'Accepted WCVP taxonomic name and author (if update required)',
                     'Matching tags',
                     'Author Match'
                     )
export_df = unique(export_df)
```

Within the collection there were `r no_items |> format(big.mark= ',')` individuals consisting of `r no_taxa |> format(big.mark= ',')` unique taxonomic names and authorities. To these unique taxonomic names and authorities we first filter out indeterminate taxa (`r indet |> format(big.mark= ',')`) and cultivars (`r cult |> format(big.mark= ',')`) as these are not found in WCVP. The remaining `r attempted_to_match` taxonomic names and authorities to match to WCVP following the matching framework supplied within the BGSmartR package. 

Prior to matching we first attempt to sanitise the taxonomic names where we fix casing issues with the records (convert all taxonomic names to capitalised first letter of genus all other letters lower case). 
`r if(sanitised > 0){paste0("This was required for ", sanitised |> format(big.mark= ',')," taxonomic names. ")}`
`r if(sanitised == 0){"This was not required for any taxonomic names."}`

The process is outlined in the figure below which visualises the process as passing taxonomic names through sieves (stages) which captures matches with varying confidence levels. 

<!-- `r if(report_kind == 'interactive'){"#####   {.tabset}"}` -->
<!-- `r if(report_kind == 'interactive'){"###### Chart"}` -->

`r if(report_kind == 'interactive'){funnel_fig}`


<!-- `r if(report_kind == 'interactive'){"###### Table"}` -->

Moreover a table is also provided with the number of taxonomic names and authorities grouped into key matching groups together with the group size relative to the number of taxonomic names and authorites we attempted to match to WCVP. Included in the table is also the number of taxonomic names within the collection that matched to synonyms within WCVP.

```{r table WCVP matching, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive'}
matching_details_table
```


<!-- `r if(report_kind == 'interactive'){"##### {-}"}` -->

:::: {.blackbox data-latex=""}

Accession level information of taxonomic matching to WCVP can be downloaded using the button below.

```{r, eval = report_kind == 'interactive'}
export_df |>
  download_this(
    output_name = "matching_information",
    output_extension = ".xlsx",
    button_label = "Download accession matching information (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained = T
  )
```

::::

```{r, taxon_status}
interest = report[c('TaxonNameFull',
                    'POWO_taxon_name',
                    'POWO_taxon_authors',
                    'POWO_match_detail_short',
                    'POWO_taxon_status')] 
interest = interest[which(!is.na(report$POWO_plant_name_id)),]
interest$POWO_taxon_name = paste0(interest$POWO_taxon_name, ' ', interest$POWO_taxon_authors)
interest$POWO_taxon_authors = NULL
interest = interest |> 
  group_by(TaxonNameFull) |> 
  summarise(POWO_taxon_status = POWO_taxon_status[1],
            POWO_match_detail_short = POWO_match_detail_short[1])

interest$POWO_taxon_status[grep('ACCEPTED',interest$POWO_match_detail_short)] = paste0(interest$POWO_taxon_status[grep('ACCEPTED',interest$POWO_match_detail_short)], '-via_matching')
interest$POWO_taxon_status[!grepl('Accepted',interest$POWO_taxon_status)] = interest$POWO_taxon_status[!grepl('Accepted',interest$POWO_taxon_status)] |> stringr::str_remove(pattern = '-via_matching')
interest$POWO_taxon_status[which(interest$POWO_taxon_status == 'Accepted-via_matching')] = 'Updated to accepted'
d = table(interest$POWO_taxon_status) |> data.frame()
names(d) = c('name', 'value')
d = d[order(d$value),]


colours = scales::brewer_pal(palette = palette, direction = 1)(nrow(d))
fig <- plot_ly(d, labels = ~name, values = ~value, title = "Matched taxa",
                # hoverinfo = "text",  hovertext = text,
                sort = FALSE, marker = list(colors = colours)) |>
  add_pie(hole = 0.6) |>
  layout(title = "",
                      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
                      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))


```

<br>

### Nomenclature of matched taxa

`r fig`

***

## Data Enrichment

In this section we produce visuals using the enriched information added to the collection via BGSmartR.

```{r, download enrichment info, eval = report_kind == 'interactive'}
interest = report[c('AccNoFull',
                    'TaxonNameFull',
                    'best_name',
                    'POWO_Dist_000_labels',
                    'POWO_geographic_area',
                    'endemic',
                    'native',
                    'POWO_lifeform_description',
                    "POWO_climate_description",
                    'Enrich_is_tree',
                    'threatened',
                    'threatened_category',
                    'no_gardens',
                    'geography_codes')] 
interest = interest[match(unique(interest$AccNoFull), interest$AccNoFull),]
names(interest) = c('Accession Number',
                    'Original Taxonomic Name and Authority',
                    'BGSmartR Taxonomic Name and Authority',
                    'Distribution Description',
                    'Distribution Description (POWO)',
                    'Endemic',
                    'Native',
                    'Lifeform Description',
                    "Climate Description",
                    'Tree',
                    'Threatened',
                    'Threatened Category',
                    'Rarity in cultivation',
                    'BRU codes')

enrich_download = interest |>
  download_this(
    output_name = "Enrichment information",
    output_extension = ".xlsx",
    button_label = "Download enrichement information for accessions (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained = T
  )
```

:::: {.blackbox data-latex=""}

You can download a selection of enrichment data for the collection (BRU codes, Distribution description from interpretation of BRU codes,
Distribution description from WCVP,
Taxa labelled as endemic to 1 BRU level 3 area (or not endemic),
Taxa labelled as native to the country where the collection is located (or non-native),
<!-- Lifeform from WCVP, -->
<!-- Habitat from WCVP, -->
Taxa labelled as tree (or not a tree) according to BGCI's GlobalTreeSearch,
IUCN red-list category,
Rarity in cultivation
) using the download button below. 

`r enrich_download`

::::

### Geographic regions of plants in the collection

```{r, create geographical maps}
### Create location data (for items and endemic) ----
interest = report[c('AccNoFull', 'POWO_Dist_000_area_code_l3')]

level_2 = c("10, 11, 12, 13, 14, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 40, 41, 42, 43, 50, 51, 60, 61, 62, 63, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 90, 91, Northern Europe, Middle Europe, Southwestern Europe, Southeastern Europe, Eastern Europe, Northern Africa, Macaronesia, West Tropical Africa, West-Central Tropical Africa, Northeast Tropical Africa, East Tropical Africa, South Tropical Africa, Southern Africa, Middle Atlantic Ocean, Western Indian Ocean, Siberia, Russian Far East, Middle Asia, Caucasus, Western Asia, Arabian Peninsula, China, Mongolia, Eastern Asia, Indian Subcontinent, Indo-China, Malesia, Papuasia, Australia, New Zealand, Southwestern Pacific, South-Central Pacific, Northwestern Pacific, North-Central Pacific, Subarctic America, Western Canada, Eastern Canada, Northwestern U.S.A., North-Central U.S.A., Northeastern U.S.A., Southwestern U.S.A., South-Central U.S.A., Southeastern U.S.A., Mexico, Central America, Caribbean, Northern South America, Western South America, Brazil, Southern South America, Subantarctic Islands, Antarctic Continent")
level_1 = c("1, 2, 3, 4, 5, 6, 7, 8, 9, Europe, Africa, Asia-Temperate, Asia-Tropical, Australasia, Pacific, Northern America, Southern America, Antarctic")

level_2 = data.frame(matrix(unlist(stringr::str_split(level_2, ', ')), ncol = 2))
names(level_2) = c('code', 'name') ; level_2$code = as.numeric(level_2$code)

level_1 = data.frame(matrix(unlist(stringr::str_split(level_1, ', ')), ncol = 2))
names(level_1) = c('code', 'name') ; level_1$code = as.numeric(level_1$code)

# Get all BRU level 3 location codes.
All_locations = wgsrpd3$LEVEL3_COD

#Get the number of species for each location.
no_items = unlist(lapply(All_locations, function(x){
  sum(grepl(x, interest$POWO_Dist_000_area_code_l3))
}))


#Get the number of endemic species for each location.
endemic_info = interest[stringr::str_length(interest$POWO_Dist_000_area_code_l3) == 3,]
no_endemic = unlist(lapply(All_locations, function(x){
  sum(grepl(x, endemic_info$POWO_Dist_000_area_code_l3))
}))

level_1_names = level_1$name[match(wgsrpd3$LEVEL1_COD, level_1$code)]
level_2_names = level_2$name[match(wgsrpd3$LEVEL2_COD, level_2$code)]

# Combine the wanted information into location data.
location_data = data.frame(code =  wgsrpd3$LEVEL3_COD,
                           name = wgsrpd3$LEVEL3_NAM,
                           level_2 = level_2_names,
                           level_1 = level_1_names,
                           no_items = no_items,
                           rep_regions = no_items > 0,
                           no_endemic = no_endemic,
                           rep_endemic = no_endemic > 0
                           )
location_data$name = stringr::str_replace(location_data$name, pattern = 'I\\.',replacement = 'Island')
location_data$name = stringr::str_replace(location_data$name, pattern = 'Is\\.',replacement = 'Islands')

regions_missing = location_data$name[!location_data$rep_regions]
regions_missing = regions_missing[-grep('Bouvet', regions_missing)]
### (END) Create location data (for items and endemic) ----

### Setup interactive data for cloropleth plot ----
 wgsrpd3_level3_simp = BGSmartR::wgsrpd3_level3_simp
  
  plot_int_info <- wgsrpd3_level3_simp |>
  dplyr::left_join(location_data, by=c("code"="code"))
  plot_int_info$name = plot_int_info$name.x
  plot_int_info$name = stringr::str_replace(plot_int_info$name, pattern = 'I\\.',replacement = 'Island')
  plot_int_info$name = stringr::str_replace(plot_int_info$name, pattern = 'Is\\.',replacement = 'Islands')
  
  data_g = st_geometry(plot_int_info)

  centers = st_centroid(data_g)
  AA = unlist(centers)
  center_df = data.frame(long = AA[seq(1,length(AA),2)], lat = AA[seq(2,length(AA),2)])

  # Convert geometry into a format accepted by plotly
  mapp = sf::st_cast(wgsrpd3_level3_simp, "MULTIPOLYGON")
  geo_sf = geojsonsf::sf_geojson(mapp)
  data = rjson::fromJSON(geo_sf)
  feat = data$features
  for(i in 1:length(feat)){
    feat[[i]]$id = feat[[i]]$properties$code
  }
  data$features = feat

  index = seq(0,1,0.01)
  col_rep = color_binary
  colours = c(rep(col_rep[1],51), rep(col_rep[2],50))
  counter = 1:length(index)
  col_scale_rep = lapply(counter, function(i){return(c(index[i], colours[i]))})
  
  colours_cont = scales::brewer_pal(palette = palette, direction = 1)(7)
  ramp <- scales::colour_ramp(colours_cont)
  colos = ramp(seq(0, 1, length = 100))
  
  
  index = seq(0,1,0.01)
  colours_cont = c("black",colos)
  counter = 1:length(index)
  col_scale = lapply(counter, function(i){return(c(index[i], colours_cont[i]))})
### (END)Setup interactive data for cloropleth plot ----

### Make the plots for  items ----
  rep_species = rep('No', nrow(plot_int_info))
rep_species[plot_int_info$rep_regions] = 'Yes'
plot_int_info$rep_species_yes_no = rep_species
 text = paste0('Region: ', plot_int_info$name, '<br>', 
                'Items from the region:', plot_int_info$no_items, '<br>')
  plot_int_info$hover = text
  
  plot_int_info$WCVP_total = rep(1, nrow(plot_int_info))
  plot_int_info$WCVP_total[grep('Bouvet', plot_int_info$name.x)] = 0
  
  center_df_species = center_df[!plot_int_info$WCVP_total ==0,]

  plot_info_species = plot_int_info[!plot_int_info$WCVP_total ==0,]
  
  fig = plot_ly(plot_info_species,  text = ~hover, hoverinfo = 'text') |>
    add_trace(type="choroplethmapbox",
     geojson=data,
     locations=plot_info_species$code,
     z=as.numeric(plot_info_species$rep_regions),
     colorscale=col_scale_rep,
     reversescale = FALSE,
     marker=list(line=list(
     width=0.01,color ='black'),
     text = plot_info_species$hover,
     hoverinfo = 'text'
    )) |>
    layout(
    mapbox=list(
      style="white-bg",
      center = list(lon = 0 ,lat= 60),
      zoom =0.2, 
      lataxis = list(range = c(-59, 90)))
  ) |>
    hide_colorbar() 
  fig = fig |>
    add_trace(type="scattermapbox",
                          mode = 'markers',
                          data = center_df_species,
                          lon = center_df_species$long,
                          lat = center_df_species$lat,
                          text = plot_info_species$hover,
                          color = I(col_rep[as.numeric(plot_info_species$rep_regions)+1]), 
                          hoverinfo = 'text',
                          inherit = FALSE,
                          showlegend = FALSE) 
map_items = fig   |> 
  config(#modeBarButtonsToAdd = list(dl_button2), 
         modeBarButtonsToRemove = c('pan2d', 'select2d', 'lasso2d', 'resetScale'))
  
  
### (END) Make the plots for items ----
  
### Make the plots for  items ----
  rep_species = rep('No', nrow(plot_int_info))
rep_species[plot_int_info$rep_endemic] = 'Yes'
plot_int_info$rep_species_yes_no = rep_species
 text = paste0('Region: ', plot_int_info$name, '<br>', 
                'Items from the region:', plot_int_info$no_endemic, '<br>')
  plot_int_info$hover = text
  
  plot_int_info$WCVP_total = rep(1, nrow(plot_int_info))
  plot_int_info$WCVP_total[grep('Bouvet', plot_int_info$name.x)] = 0
  
  center_df_species = center_df[!plot_int_info$WCVP_total ==0,]

  plot_info_species = plot_int_info[!plot_int_info$WCVP_total ==0,]
  
  fig = plot_ly(plot_info_species,  text = ~hover, hoverinfo = 'text') |>
    add_trace(type="choroplethmapbox",
     geojson=data,
     locations=plot_info_species$code,
     z=as.numeric(plot_info_species$rep_endemic),
     colorscale=col_scale_rep,
     reversescale = FALSE,
     marker=list(line=list(
     width=0.01,color ='black'),
     text = plot_info_species$hover,
     hoverinfo = 'text'
    )) |>
    layout(
    mapbox=list(
      style="white-bg",
      center = list(lon = 0 ,lat= 60),
      zoom =0.2, 
      lataxis = list(range = c(-59, 90)))
  ) |>
    hide_colorbar() 
  fig = fig |>
    add_trace(type="scattermapbox",
                          mode = 'markers',
                          data = center_df_species,
                          lon = center_df_species$long,
                          lat = center_df_species$lat,
                          text = plot_info_species$hover,
                          color = I(col_rep[as.numeric(plot_info_species$rep_endemic)+1]), 
                          hoverinfo = 'text',
                          inherit = FALSE,
                          showlegend = FALSE) 
map_endemic = fig  |> 
  config(#modeBarButtonsToAdd = list(dl_button),
         modeBarButtonsToRemove = c('pan2d', 'select2d', 'lasso2d', 'resetScale'))
  
  
### (END) Make the plots for items ----  
```

By enriching the collection with information from WCVP we retrieve geographic distribution of accepted plants (according to WCVP). The distribution can be split into regions that are native/introduced, extinct/non-extinct and location doubtful/not doubtful. 

Below we produce a map of the geographic regions represented in the collection together with the number of individuals in the collection that are native (not-extinct, not doubtful) to each region specified by WCVP. 

```{r, fig.dim=c(8,6), fig.align = "left", eval = report_kind == 'interactive'}
map_items
```

Within the collection there are `r regions_missing |> length()` regions that are not represented in the collection. Namely, `r paste0(regions_missing, collapse = ', ')`.

***

### Geographic regions of endemic plants in the collection

Plants that belong to a single region are classed as endemic. The number of endemic plants in the collection is outlined below. 

```{r, fig.dim=c(8,6), fig.align = "left", eval = report_kind == 'interactive'}
map_endemic
```

***

### Proportion of the collection by enriched information

Within the enrichment process we extract the number of trees, endemic, threatened and native (to `r location_name`) plants within the collection. 

Below we show the proportion of the collection that are in the categories above. 

```{r, percent enrich info}
interest = report[report$ItemStatusType == 'Existing',]
tree = rep('Not tree',nrow(interest))
tree[which(interest$Enrich_is_tree)] = 'Tree'
interest$tree = tree
type  = rep(NA, nrow(interest))
type[grepl('1', interest$taxon_type)] = 'Species'
type[grepl('0', interest$taxon_type)] = 'Indeterminate'
type[grepl('2|3|4', interest$taxon_type)] = 'Infraspecific'
type[grepl('6', interest$taxon_type)] = 'Hybrid'
type[grepl('5', interest$taxon_type)] = 'Cultivar'
interest$type_plant = type
rarity = rep('Unknown', nrow(interest))
rarity[interest$no_gardens == 1] = 'Unique'
rarity[interest$no_gardens %in% c(2:10)] = 'Very Rare'
rarity[interest$no_gardens %in% c(11:50)] = 'Rare'
rarity[interest$no_gardens %in% c(51:100)] = 'Common'
rarity[interest$no_gardens %in% c(101:10000)] = 'Very Common'
interest$rarity = rarity

interest = interest |>
  group_by(AccNoFull) |>
  summarise(type_plant = type_plant[1],
            ProvenanceCode = ProvenanceCode[1],
            tree = tree[1],
            rarity = rarity[1],
            native = native[1],
            endemic = endemic[1],
            threatened = threatened[1],
            POWO_plant_name_id = POWO_plant_name_id[1],
            items = length(.data$AccNoFull))
interest$items[interest$items > 4] = '> 4'

# interest_taxa = interest |>
#   group_by(AccNoFull) |>
#   summarise(type_plant = type_plant[1],
#             taxo_group = taxo_group[1],
#             tree = tree[1],
#             rarity = rarity[1],
#             native = native[1],
#             endemic = endemic[1],
#             threatened = threatened[1],
#             items = length(.data$AccNoFull))
# interest_taxa$items[interest$items > 5] = '6+'

# factoring groups for order in plot.
interest$rarity = factor(interest$rarity,
                             levels = c('Unique', 'Very Rare', 'Rare', 'Common', 'Very Common', 'Unknown'))
interest$type_plant = factor(interest$type_plant,
                             levels = c('Species', 'Infraspecific', 'Hybrid', 'Indeterminate', 'Cultivar'))
interest$native = factor(interest$native, levels = c("Native","Non-native"))
interest$endemic = factor(interest$endemic, levels = c("Endemic", "Not Endemic"))
interest$threatened = factor(interest$threatened, levels = c("Threatened", "Not Threatened"))
interest$tree = factor(interest$tree, levels = c("Tree", "Not tree"))
interest$ProvenanceCode = factor(interest$ProvenanceCode, levels = c("Wild" , "Wild-derived", "Garden", "Unknown" ))
interest$items = factor(interest$items, levels = c('1','2','3','4','> 4' ))
interest_POWO = interest[which(!is.na(interest$POWO_plant_name_id)),]


# Extract the wanted information for the composition.
quant = c( 'tree', 'native', 'endemic', 'threatened')
info = pbapply::pblapply(quant, function(q){
  table_counts = interest |> dplyr::count(across(q))
  table_counts$percent = round(table_counts$n/ sum(table_counts$n) *100, digits = 2)
  table_counts$type = 'Whole collection'
  if(nrow(table_counts) %in% c(1,2)){
    table_counts$colors = color_binary[1:nrow(table_counts)] |> rev()
  }else if(nrow(table_counts) %in% c(3,4)){
    table_counts$colors = interactive_colour(nrow(table_counts))
  }else{
    table_counts$colors = scales::brewer_pal(palette = palette, direction = 1)(nrow(table_counts))
  }
  
  table_counts_POWO = interest_POWO |> dplyr::count(across(q))
  table_counts_POWO$percent = round(table_counts_POWO$n/ sum(table_counts_POWO$n) *100, digits = 2)
  table_counts_POWO$type = 'Match POWO only'
  if(nrow(table_counts_POWO) %in% c(1,2)){
    table_counts_POWO$colors = color_binary[1:nrow(table_counts_POWO)] |> rev()
  }else if(nrow(table_counts_POWO) %in% c(3,4)){
    table_counts_POWO$colors = interactive_colour(nrow(table_counts_POWO))
  }else{
    table_counts_POWO$colors = scales::brewer_pal(palette = palette, direction = 1)(nrow(table_counts_POWO))
  }
  
  comb = rbind(table_counts, table_counts_POWO)
  names(comb) = c('category', 'n', 'percent', 'type', 'color')
  comb$collect_part = q
  comb
  
})
names(info) =  c( 'Tree', 'Native', 'Endemic', 'Threatened')
# info$family_use = info$family_use[order(info$family_use$n, decreasing = T),]
comb = do.call('rbind',info)
# comb$category = factor(comb$category, levels = unique(comb$category))
comb$collect_part  = comb$collect_part |> dplyr::case_match("type_plant" ~ 'Type of Plant',
                                       "ProvenanceCode" ~ 'Provenance',
                                       "taxo_group" ~ 'Taxonomic <br> Composition',
                                        "tree" ~ 'Tree',
                                        "rarity" ~'Rarity',
                                       'items' ~ 'Duplication',
                                        "native" ~ 'Native',
                                        "endemic" ~ 'Endemic',
                                        "threatened" ~ 'Threatened')
comb$collect_part = factor(comb$collect_part, levels = rev(unique(comb$collect_part)))
comb$hover = paste0(comb$percent |> round(1), '% (', comb$n,' accessions) ', comb$category)
        
comb$color[which(comb$category == 'Tree')]   = '#f46d43'  
comb$color[which(comb$category == 'Not tree')]   = '#848484'    

  

### Create the horizontal bar plots.
comb_cur = comb[comb$type == 'Whole collection',]
hor_stack_bar_plot = plot_ly(comb_cur,
                             type = 'bar',
                             y = ~collect_part,
                             x = ~percent,
                             group = ~category,
                             # colors = ~color,
                             orientation = 'h',
                             hovertext = ~hover, hoverinfo = 'text',
                             showlegend = FALSE,
                             marker = list(color = ~color)) |>
  plotly::layout(xaxis = list(title = "Percentage of collection (accessions)"),
                 yaxis = list(title = ''),barmode = 'stack'
                 # hovermode = 'y unified'
  )


```

`r if(report_kind == 'interactive'){hor_stack_bar_plot}`


***


### Change in IUCN RedListed plants 

```{r IUCN redlisted individuals comparision}
figs = list()
has_redlist_cat = 'IUCNRedList' %in% names(report)
### Option 1: the original report doesn't have threatened categories of plants. (I.e no IUCNRedList) ----
if(!has_redlist_cat){
  interest = report[c('AccNoFull', 'best_name', 'threatened_category', 'threatened')]
  new = table(interest$threatened_category) |> data.frame() 
  for_plot = new
  names(for_plot) = c('Category', 'Individuals')
  for_plot = for_plot[for_plot$Category != 'NA',]
  table_item  = for_plot
  
for_plot$Category = for_plot$Category |> as.character() |> factor(levels = c('VU', 'EN','CR', 'EW','EX'))

# Create bar plot.
figs$individuals = plot_ly(for_plot,
        x = ~Category,
        y = ~Individuals,
        # colors = interactive_colour(1),
        type = 'bar', 
        marker =list(color = interactive_colour(1) )) |>
    layout(yaxis = list(title = 'Number of individuals'),
         xaxis = list(title = 'Threatened category')) |> 
  config(modeBarButtonsToAdd = list(dl_button), 
         modeBarButtonsToRemove = c('zoom2d','pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale', 'resetScale'))

interest_taxa = interest |> 
  group_by(best_name) |>
  summarise(new = toString(unique(threatened_category))
  )

no_extinct = sum(grepl('EX',interest_taxa$new))
if(no_extinct > 0){
  acc_extinct = unique(interest[which(interest$threatened_category == 'EX'), c('AccNoFull', 'best_name')]) |> group_by(best_name) |> summarise(acc = toString(AccNoFull))
  acc_extinct = paste0(acc_extinct$best_name, ' (',acc_extinct$acc,')')
}

cat = c('VU', 'EN','CR', 'EW','EX')
taxa_count = rep(NA, length(cat))
for(i in 1:length(cat)){
  taxa_count[i] = sum(grepl(cat[i], interest_taxa$new))
}
new = data.frame(cat = cat, count = taxa_count)
new = new[new$count >0,]
for_plot =  new
names(for_plot) = c('Category', 'Individuals')

table_taxa= for_plot
for_plot$Category = for_plot$Category |> as.character() |> factor(levels = c('VU', 'EN','CR', 'EW','EX'))

# Create bar plot.
figs$taxa = plot_ly(for_plot,
        x = ~Category,
        y = ~Individuals,
        type = 'bar',
         marker =list(color = interactive_colour(1) )) |>
  layout(yaxis = list(title = 'Number of taxa'),
         xaxis = list(title = 'Threatened category'))|> 
  config(modeBarButtonsToAdd = list(dl_button), 
         modeBarButtonsToRemove = c('zoom2d','pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale', 'resetScale'))
}
### (END) Option 1 ----

### Option 1: the original report has threatened categories of plants. (I.e IUCNRedList) ----
if(has_redlist_cat){
cleansed_version = rep(NA, nrow(report))
report$IUCNRedList = tolower(report$IUCNRedList)
cleansed_version[grepl('^vu', report$IUCNRedList)] = 'VU'
cleansed_version[grepl('^en', report$IUCNRedList)] = 'EN'
cleansed_version[grepl('^cr', report$IUCNRedList)] = 'CR'
cleansed_version[grepl('^ex', report$IUCNRedList)] = 'EX'
cleansed_version[grepl('^ew|wild', report$IUCNRedList)] = 'EW'
report$OG_cleansed = cleansed_version

interest = report[c('AccNoFull', 'best_name', 'IUCNRedList', 'OG_cleansed', 'threatened_category', 'threatened')]

OG = table(interest$OG_cleansed) |> data.frame() ; OG$from = 'Original'
new = table(interest$threatened_category) |> data.frame() ; new$from = 'Enriched'
for_plot = rbind(OG, new)
names(for_plot) = c('Category', 'Individuals', 'Source')
for_plot = for_plot[for_plot$Category != 'NA',]
for_plot 

table_item = reshape2::dcast(for_plot, Category ~ Source, value.var = "Individuals")
table_item$percent = ((table_item$Enriched - table_item$Original) / table_item$Original *100 ) |> round(2)
table_item$percent = paste0(table_item$percent, '%')
names(table_item) = c("Category", "Enriched", "Original", "Percent change")

for_plot$Category = for_plot$Category |> as.character() |> factor(levels = c('VU', 'EN','CR', 'EW','EX'))
# Create bar plot.
figs$individuals = plot_ly(for_plot,
        x = ~Category,
        y = ~Individuals,
        color = ~Source,
        colors = interactive_colour(2),
        type = 'bar') |>
    layout(yaxis = list(title = 'Number of individuals'),
         xaxis = list(title = 'Threatened category'))|> 
  config(modeBarButtonsToAdd = list(dl_button), 
         modeBarButtonsToRemove = c('zoom2d','pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale', 'resetScale'))

interest_taxa = interest |> 
  group_by(best_name) |>
  summarise(OG = toString(unique(OG_cleansed)),
            new = toString(unique(threatened_category))
  )
no_extinct = sum(interest_taxa$new == 'EX')
if(no_extinct > 0){
  acc_extinct = unique(interest[which(interest$threatened_category == 'EX'), c('AccNoFull', 'best_name')]) |> group_by(best_name) |> summarise(acc = toString(AccNoFull))
  acc_extinct = paste0(acc_extinct$best_name, ' (',acc_extinct$acc,')')
}
OG = table(interest_taxa$OG) |> data.frame() ; OG$from = 'Original'
new = table(interest_taxa$new) |> data.frame() ; new$from = 'Enriched'
for_plot = rbind(OG, new)
names(for_plot) = c('Category', 'Individuals', 'Source')
for_plot = for_plot[for_plot$Category != 'NA',]

table_taxa= reshape2::dcast(for_plot, Category ~ Source, value.var = "Individuals")
table_taxa$percent = ((table_taxa$Enriched - table_taxa$Original) / table_taxa$Original *100 ) |> round(2)
table_taxa$percent = paste0(table_taxa$percent, '%')
names(table_taxa) = c("Category", "Enriched", "Original", "Percent change")
for_plot$Category = for_plot$Category |> as.character() |> factor(levels = c('VU', 'EN','CR', 'EW','EX'))
# Create bar plot.
figs$taxa = plot_ly(for_plot,
        x = ~Category,
        y = ~Individuals,
        color = ~Source,
        colors = interactive_colour(2),
        type = 'bar') |>
  layout(yaxis = list(title = 'Number of taxa'),
         xaxis = list(title = 'Threatened category'))|> 
  config(modeBarButtonsToAdd = list(dl_button), 
         modeBarButtonsToRemove = c('zoom2d','pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale', 'resetScale'))
}
### (END) Option 2 ----

```

In the enrichment process we match the original taxonomic names and those matched to WCVP to IUCN's RedList to find threatened taxa in the collection. 

<!-- Inform on extinct taxa if any exist in the collection -->
`r if(no_extinct > 0){paste0("Your collection includes ", no_extinct ," taxa that are considered as Extinct by the IUCN red-list. We suggest verifying their identity.")}`

`r if(no_extinct > 0){paste0("The extinct plants (with accession number) are ", paste0(acc_extinct, collapse = ', ') )}`

<!-- If the OR has threatened category information -->
`r if(has_redlist_cat){"Below we compare the number of threatened species found by enrichement to the plants already tagged as threatened in the collection "}`

`r if(has_redlist_cat){"Below we show the number of threatened species found by enrichement"}`

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Taxa"}`

`r if(report_kind == 'interactive'){figs$taxa}`

`r if(report_kind == 'interactive'){"###### Individuals"}`

`r if(report_kind == 'interactive'){figs$individuals}`

`r if(report_kind == 'interactive'){"###### Tables"}`

**Taxa**

```{r, eval = report_kind == 'interactive'}
table_taxa |> DT::datatable(rownames = FALSE,
                 options = list(scrollX = TRUE,
                                pageLength = nrow(table_taxa),
                                dom = 'tp',
                                paging=FALSE,
                                ordering = FALSE))
```

**Individuals**

```{r, eval = report_kind == 'interactive'}
table_item |> DT::datatable(rownames = FALSE,
                 options = list(scrollX = TRUE,
                                pageLength = nrow(table_item),
                                dom = 'tp',
                                paging=FALSE,
                                ordering = FALSE))
```

`r if(report_kind == 'interactive'){"##### {-}"}`

***


## Data Enhancement Recommendations

```{r Data Enhancement information}
### Reduce to only the fields that we care about.  ----
interest = report[c('ItemAccNoFull',
                    'AccNoFull',
                    'TaxonNameFull',
                    'ItemStatusDate', 
                    'AccYear')]
interest$ItemStatusDate_year = BGSmartR::extract_year(interest$ItemStatusDate)
### (END) Reduce to only the fields that we care about.  ----

### Find the number of ItemStatusDates that are missing any information (all, month, day) ----

year_cur = stringr::str_extract(string = Sys.Date(),pattern = '[0-9]{4}') |> as.numeric()
current_year = year_cur
# For ItemStatusDate
missing = which(interest$ItemStatusDate == '' |is.na(interest$ItemStatusDate))
year_only = which(stringr::str_length(interest$ItemStatusDate) == 4 &
                    grepl('[0-9]{4}',interest$ItemStatusDate))
year_month_only = which(stringr::str_length(interest$ItemStatusDate) == 7 &
                    grepl('[0-9]{4}-[0-9]{2}',interest$ItemStatusDate))
year_after_current = which(interest$ItemStatusDate_year > year_cur)
year_too_old = which(interest$ItemStatusDate_year < 1650)
before_acc_year = which(interest$ItemStatusDate_year < interest$AccYear)
oldest_ItemStatusDate = min(interest$ItemStatusDate_year[interest$ItemStatusDate_year > 1650], na.rm = T)

ItemStatusDate_details = data.frame(type = c('Missing entirely',
                                             'Only contains the year',
                                             'Only contains the year and month',
                                             'The year is after the current year',
                                             # 'The year is prior to 1650',
                                             'The year is prior to the item been accessioned'),
                                    value =  c(length(missing),
                                               length(year_only),
                                               length(year_month_only),
                                               length(year_after_current),
                                               # length(year_too_old),
                                               length(before_acc_year))
                              ) 
ItemStatusDate_details = ItemStatusDate_details[ItemStatusDate_details$value > 0,]
names(ItemStatusDate_details) = c('Issue', 'Total individuals')
ItemStatusDate_details_table = ItemStatusDate_details |> 
   DT::datatable(rownames = FALSE,
                 options = list(scrollX = TRUE,
                                pageLength = nrow(ItemStatusDate_details),
                                dom = 'tp',
                                paging=FALSE,
                                ordering = FALSE))

issue_index_for_plot = unique(c(missing, year_after_current, year_too_old
                                ))
issue_df = interest[unique(c(missing, year_only, year_month_only, year_after_current,# year_too_old,
                             before_acc_year)),]

ItemStatusIssue_download = issue_df |>
  download_this(
    output_name = "ItemStatusDate issues",
    output_extension = ".xlsx",
    button_label = "Download records with most recent update date issues (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained = T
  )

# missing_year = which(!grepl('[0-9]{4}', interest$ItemStatusDate))
### (END) Find the number of dates that are missing any information (all, month, day) ----

### Find the number of AccYear that are missing any information or incorrect ----
missing = which(interest$AccYear == '' |is.na(interest$AccYear))
year_after_current = which(interest$AccYear > year_cur)
# year_too_old = which(interest$AccYear < 1650)

AccYear_details = data.frame(type = c('Missing entirely',
                                             'The year is after the current year'
                                             # 'The year is prior to 1650'
                                      ),
                                    value =  c(length(missing),
                                               length(year_after_current)
                                               # length(year_too_old)
                                               )
                              ) 
AccYear_details = AccYear_details[AccYear_details$value > 0,]
names(AccYear_details) = c('Issue', 'Total individuals')
AccYear_details_table = AccYear_details |> 
   DT::datatable(rownames = FALSE,
                 options = list(scrollX = TRUE,
                                pageLength = nrow(AccYear_details),
                                dom = 'tp',
                                paging=FALSE,
                                ordering = FALSE))

issue_AccYear_df = interest[unique(c(missing, year_after_current
                                     # year_too_old
                                     )),]
AccYear_download = issue_AccYear_df |>
  download_this(
    output_name = "Accession Year issues",
    output_extension = ".xlsx",
    button_label = "Download records with accession year issues (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained = T
  )
### (END) Find the number of dates that are missing any information (all, month, day) ----

### Create last updated plots ----
figs = list()
data = interest
if(length(issue_index_for_plot)> 0){
  data = interest[-issue_index_for_plot,]
}
data$year = BGSmartR::extract_year(data$ItemStatusDate)

# A)  Items
year = data$year
table_year = table(year)
year = names(table_year) ; no_items = as.numeric(table_year)

years = min(as.numeric(year)):current_year
no_items_full = rep(0,length(years))
no_items_full[match(as.numeric(year), years)] = no_items

last_update_items = data.frame(year = years, no_items = no_items_full)
last_update_items$cumulative = cumsum(last_update_items$no_items)
last_update_items$year_num = as.numeric(last_update_items$year)
last_update_items$year_ago = current_year -last_update_items$year_num
last_update_items$textA = paste0(last_update_items$year_ago, ' year/s ago<br>',
                                 last_update_items$no_items, ' items')

figs$items$date <- plot_ly(last_update_items,
               x = ~year,
               y = ~no_items,
               type = 'bar',
               color = interactive_colour(1)) |>
  layout(title = "",
         xaxis = list(title = "Last status update (Year)"),
         yaxis = list(title = "Number of individuals"),
         hovermode = 'x unified') |> 
  config(modeBarButtonsToAdd = list(dl_button), 
         modeBarButtonsToRemove = c('zoom2d','pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale', 'resetScale'))

figs$items$cum <- plot_ly(last_update_items,
               x = ~year,
               y = ~cumulative,
               type = 'bar',
               color = interactive_colour(1)) |>
  layout(title = "",
         xaxis = list(title = "Last status update (Year)"),
         yaxis = list(title = "Number of individuals (cumulative)"),
         hovermode = 'x unified') |> 
  config(modeBarButtonsToAdd = list(dl_button), 
         modeBarButtonsToRemove = c('zoom2d','pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale', 'resetScale'))
  
if(separate_figure_folder){
  htmlwidgets::saveWidget(figs$items$date, file = paste0(figures_dir, '/','Bar-date_of_last_update_items.html'))
}

# B)  Accessions
data = data |>
  group_by(AccNoFull) |>
  summarise(year = max(year))

year = data$year
table_year = table(year)
year = names(table_year) ; no_acc = as.numeric(table_year)

years = min(as.numeric(year)):current_year
no_acc_full = rep(0,length(years))
no_acc_full[match(as.numeric(year), years)] = no_acc

last_update_acc = data.frame(year = years, no_acc = no_acc_full)
last_update_acc$cumulative = cumsum(last_update_acc$no_acc)
last_update_acc$year_num = as.numeric(last_update_acc$year)
last_update_acc$year_ago = current_year -last_update_acc$year_num
last_update_acc$textA = paste0(last_update_acc$year_ago, ' year/s ago<br>',
                                 last_update_acc$no_acc, ' acc')

figs$acc$date <- plot_ly(last_update_acc,
               x = ~year,
               y = ~no_acc,
               type = 'bar',
               color = interactive_colour(1)) |>
  layout(title = "",
         xaxis = list(title = "Last status update (Year)"),
         yaxis = list(title = "Number of accessions"),
         hovermode = 'x unified') |> 
  config(modeBarButtonsToAdd = list(dl_button), 
         modeBarButtonsToRemove = c('zoom2d','pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale', 'resetScale'))

figs$acc$cum <- plot_ly(last_update_acc,
               x = ~year,
               y = ~cumulative,
               type = 'bar',
               color = interactive_colour(1)) |>
  layout(title = "",
         xaxis = list(title = "Last status update (Year)"),
         yaxis = list(title = "Number of accessions (cumulative)"),
         hovermode = 'x unified') |> 
  config(modeBarButtonsToAdd = list(dl_button), 
         modeBarButtonsToRemove = c('zoom2d','pan2d', 'select2d', 'lasso2d', 'zoomIn2d', 'zoomOut2d', 'autoScale', 'resetScale'))
  
if(separate_figure_folder){
  htmlwidgets::saveWidget(figs$acc$date, file = paste0(figures_dir, '/','Bar-date_of_last_update_acc.html'))
}


# Create the smaller pie charts.
five_year_ago = max_year - 5
not_seen = sum(last_update_items$no_items[last_update_items$year < five_year_ago])
seen = sum(last_update_items$no_items[last_update_items$year >= five_year_ago])
simp_last_update_items = data.frame(c('Yes', 'No'), c(seen, not_seen) )
names(simp_last_update_items) = c(paste0('Seen since ', five_year_ago, '?'), 'Items')

not_seen = sum(last_update_acc$no_acc[last_update_acc$year < five_year_ago])
seen = sum(last_update_acc$no_acc[last_update_acc$year >= five_year_ago])
simp_last_update_acc = data.frame(c('Yes', 'No'), c(seen, not_seen) )
names(simp_last_update_acc) = c(paste0('Seen since ', five_year_ago, '?'), 'Accessions')

colours = interactive_colour(2) |> rev()
seen_5_year_pie <- plot_ly() |>
  add_pie(data = simp_last_update_items, labels = simp_last_update_items[,1], values = ~Items, hole = 0.6,
          title = "Items", name ='', sort = FALSE, marker = list(colors = colours),
          domain = list(row = 0, column = 0)) |>
  add_pie(data = simp_last_update_acc, labels = simp_last_update_acc[,1], values = ~Accessions, hole = 0.6,
          title = "Accessions", name ='', sort = FALSE, marker = list(colors = colours),
         domain = list(row = 0, column = 1))  |>
  layout(title = "", showlegend = TRUE,
          grid=list(rows=1, columns=2),
         plot_bgcolor="#f0f0f0",
         legend = list(title = list(text = paste0('<b>','Seen since ', five_year_ago, '?', '</b>')), orientation = 'h', xanchor = "center", x = 0.5),
         xaxis = list(title=paste0('Items', 'Accessions'), showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
         margin = c(0,0,0,0))
### (END) Create last updated plots ----

### Create table of accessions not updated in last 5 years ----
data = interest
if(length(issue_index_for_plot)> 0){
  data = interest[-issue_index_for_plot,]
}
data$year = BGSmartR::extract_year(data$ItemStatusDate)
data = data[data$year < (year_cur - 5),]
data = data[order(data$ItemStatusDate),]
data = data[,c(1:5)]
names(data) = c('Item + Accession Number',
                'Accession Number',
                'Orignal Taxonomic Name and Authority',
                'Most Recent Update',
                'Accession Year')

old5yr_download = data |>
  download_this(
    output_name = paste0("Most recent update prior to ", year_cur - 5),
    output_extension = ".xlsx",
    button_label = paste0("Download individuals whose most recent update was prior to ",year_cur - 5),
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained = T
  )

### (END)Create table of accessions not updated in last 5 years ----

### Create table after for most recent accession/item update.
table_data = data.frame(year = last_update_acc$year,
                        accessions = last_update_acc$no_acc,
                        acc_cum = last_update_acc$cumulative,
                        items = last_update_items$no_items,
                        items_cum = last_update_items$cumulative)
names(table_data) = c('Year', 'Number of <br> Accessions', 'Cumulative Number<br>of Accessions',
                      'Number of <br> individuals', 'Cumulative Number<br>of individuals')

table_data_form = table_data |> DT::datatable(extensions = 'Buttons',
                rownames = FALSE,
                options = list(scrollX = TRUE,
                               pageLength = min(10, nrow(table_data)),
                               dom = 'Btp',
                               buttons = c('copy', 'csv', 'excel', 'pdf'),
                               paging=ifelse( nrow(table_data) < 10, FALSE, TRUE),
                               ordering=T),
                escape = F,
                filter = 'top')
### (END) Create table

### Create pie chart
### (END) Create pie chart

### Find provenance issues
interest = report$ProvenanceCode[report$ItemStatusType == 'Existing']
unique_prov = unique(interest)
prov_issue = unique_prov[!unique_prov %in% c("Unknown", "Garden", "Wild", "Wild-derived")]

prov_issue_flag = ifelse(length(prov_issue)>0, TRUE,FALSE)

if(prov_issue_flag){
  table_prov_issue = prov_issue |> table()
  names(table_prov_issue) = c('Provenance', 'Number of Individuals')
  table_prov_issue = table_prov_issue |>DT::datatable(rownames = FALSE,
                 options = list(scrollX = TRUE,
                                pageLength = nrow(table_prov_issue),
                                dom = 'tp',
                                paging=FALSE,
                                ordering = FALSE))
}
### (END) Find provenance issues
```

`r if(prov_issue_flag){'### Provenance issues'}`

`r if(prov_issue_flag){paste0('There are ', length(prov_issue), ' individuals that have none-standard provenance codes, these are highlighted in the table below. ')}`

`r if(prov_issue_flag & report_kind == 'interactive'){table_prov_issue}`

`r if(prov_issue_flag){'***'}`

### Most recent status update issues

Within the collection there are `r nrow(issue_df)` existing individuals that have potential issues with their most recent status update date. 
`r if( nrow(issue_df) > 0){"The issues are summarised in the table below."}` 


`r if( nrow(issue_df) > 0 & report_kind == 'interactive'){ItemStatusDate_details_table}`

`r if( nrow(issue_df) > 0){':::: {.blackbox data-latex=""}'}`

`r if( nrow(issue_df) > 0){"Detailed information about the accessions affected by potential most recent status update issues can be downloaded using the button below."}`

`r if( nrow(issue_df) > 0 & report_kind == 'interactive'){ItemStatusIssue_download}`

`r if( nrow(issue_df) > 0){'::::'}`

***
 
### Accession year issues

Within the collection there are `r nrow(issue_AccYear_df)` existing individuals that have potential issues with their accession year. 
`r if( nrow(issue_AccYear_df) > 0){"The issues are summarised in the table below."}`

`r if( nrow(issue_AccYear_df) > 0 & report_kind == 'interactive'){AccYear_details_table}`

`r if( nrow(issue_AccYear_df) > 0){':::: {.blackbox data-latex=""}'}`

`r if( nrow(issue_AccYear_df) > 0){"Detailed information about the accessions affected by potential most recent status update issues can be downloaded using the button below."}`

`r if( nrow(issue_AccYear_df) > 0 & report_kind == 'interactive'){AccYear_download}`

`r if( nrow(issue_AccYear_df) > 0){'::::'}`

***

### How recently have plants been updated?

In this section we explore how recently individuals and accessions have been updated in the collection. Where for accessions we use the date of the most recent updated individual in the accession. We extract the year from the latest update date and plot the number of individuals and items by their year of most recent update. 

`r if(report_kind == 'interactive'){"##### {.tabset}"}`

`r if(report_kind == 'interactive'){"###### Snapshot"}`

`r if(report_kind == 'interactive'){seen_5_year_pie}`

`r if(report_kind == 'interactive'){"###### Individuals"}`

**Number each year**

`r if(report_kind == 'interactive'){figs$items$date}`

**Number with status date year equal to or before**

`r if(report_kind == 'interactive'){figs$items$cum}`


`r if(report_kind == 'interactive'){"###### Accessions"}`

**Number each year**

`r if(report_kind == 'interactive'){figs$acc$date}`

**Number with status date year equal to or before**

`r if(report_kind == 'interactive'){figs$acc$cum}`

`r if(report_kind == 'interactive'){"###### Table"}`

**Table of most recent accession year (including cumulative)**

`r if(report_kind == 'interactive'){table_data_form}`

`r if(report_kind == 'interactive'){"##### {-}"}`

:::: {.blackbox data-latex=""}

Use the button below to download individuals in the collection that have not been updated since `r year_cur - 5`. 

`r old5yr_download`

::::

***

### {-} 
<!-- Unknown provenance, only show if there are currently unknown provenance existing in the collection-->
```{r, unknown prov}
interest = report_original 
interest_existing = interest[interest$ItemStatusType == 'Existing',]

no_unknown = sum(interest_existing$ProvenanceCode == 'Unknown')

if(no_unknown > 0){
  
  if(!is.null(old_accession_year_codes)){
    has_old_accessions_code = which(interest$AccYear %in% old_accession_year_codes)
    acc_change_accyear = interest$AccNoFull[has_old_accessions_code] |> unique()

    no_old_accessions = length(has_old_accessions_code)
    interest$AccYear[has_old_accessions_code] = earliest_allowable_record
  }
  to_keep = which(as.numeric(interest$AccYear) >= earliest_allowable_record  & as.numeric(interest$AccYear) <= max_year)
  still_issue = nrow(interest) - length(to_keep)
  interest = interest[to_keep,]
  
  interest = interest[!is.na(interest$ItemStatusDate),]
  
  
  
  unique_accessions = unique(interest$AccNoFull)
  
  LossYear = rep(NA,nrow(interest))
  ItemStatusYear = as.numeric(stringr::str_extract(interest$ItemStatusDate,pattern = '[0-9]{4}'))
  LossYear[interest$ItemStatusType %in% c('NotExisting', 'Not Existing')] = ItemStatusYear[interest$ItemStatusType %in% c('NotExisting', 'Not Existing')]
  interest$LossYear = LossYear
  # Order the items where the lower indices have the most recent death date.
  LossYear_dummy = LossYear
  LossYear_dummy[is.na(LossYear_dummy)] = 4000
  ordered_items = order(LossYear_dummy,decreasing = T)
  interest = interest[ordered_items, ]
  
  #Match to the ordered accessions.
  match_to_best = match(unique_accessions,interest$AccNoFull)
  
  #Reduce the data to unique accessions with most recent death date.
  interest = interest[match_to_best,]
  interest$ProvenanceCode[interest$ProvenanceCode != 'Unknown'] = 'Other'
  
  interest_existing = interest[interest$ItemStatusType == 'Existing',]
  
  
  
  min_year = 1970 ; max_year = Sys.Date() |> format('%Y') |> as.numeric() ; years = min_year:max_year
  date = paste0(years, '-12-31')
  
  plant_existing = BGSmartR::exist_at_date(date, AccessionYear = interest$AccYear,
                                           ItemStatusDate = interest$ItemStatusDate,
                                           ItemStatusType = interest$ItemStatusType,post_date = '3000-12-31')
  
  time_series_info_subsets = pbapply::pblapply(plant_existing, function(x){
    garden_current = interest[x,]
    
    breakdown_provenance = table(garden_current$ProvenanceCode)
    
    return(list(breakdown_provenance = breakdown_provenance))
  })
  names(time_series_info_subsets) = names(plant_existing)
  
  # Snapshot
  data_exist = data.frame(prov = c('Unknown','Other'), acc = c(sum(interest_existing$ProvenanceCode == 'Unknown'),
                                                               sum(interest_existing$ProvenanceCode != 'Unknown'))
  )
  data_exist$prov = data_exist$prov |> factor(levels = c('Unknown','Other'))
  snapshot_plot <- plot_ly(data_exist, labels = ~prov, values = ~acc, title = 'Accessions',
                           # hoverinfo = "text",  hovertext = ~hover,
                           marker = list(colors = color_binary |> rev()),  sort = FALSE) |>
    add_pie(hole = 0.6) |>
    layout(title = "",  showlegend = T,
           xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
           yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE))
  
  
  # Over time
  unknown_trend = lapply(time_series_info_subsets, function(x){
    acc = x$breakdown_provenance['Unknown'] |> as.numeric()
    percent = (acc/sum(x$breakdown_provenance) *100) |> round(2)
    
    return(c(acc,percent))
  }) |> data.frame() |> t() |> data.frame()
  unknown_trend = data.frame(year = years, unknown_trend)
  names(unknown_trend) = c('years', 'acc','percent')
  
  
  df = unknown_trend
  name = 'Accessions'
  df$text = paste0('Date: ', years, '-12-31 <br>', name,': ', df$acc)
  
  fig <- plot_ly(df, x = ~years, y = ~acc, type = 'scatter', mode = 'lines', text = ~text, hoverinfo = 'text', line = list(color = interactive_colour(1)))
  fig <- fig %>% layout(title = "",
                        xaxis = list(title = "Year"),
                        yaxis = list(title = paste0("Number of ", name |> tolower()))) 
  fig <- fig %>% layout(hovermode = 'x')
  
  # if(separate_figure_folder){
  #   htmlwidgets::saveWidget(fig, file = paste0(figures_dir,'/',name,'_trend.html'),selfcontained = T)
  # }
  
  df$text = paste0('Date: ', years, '-12-31 <br>Percent of ', name|> tolower(),': ', df$percent, '%')
  
  fig2 <- plot_ly(df, x = ~years, y = ~percent, type = 'scatter', mode = 'lines', text = ~text, hoverinfo = 'text', line = list(color = interactive_colour(1))) |>
    layout(title = "",
           xaxis = list(title = "Year"),
           yaxis = list(title = paste0("Proportion of ", name |> tolower()))) |>
    layout(hovermode = 'x')
}


# Downloadable table of unknown taxa.
unknown_existing = interest_existing[interest_existing$ProvenanceCode == 'Unknown',
                                     match(c('AccNoFull','AccYear', 'TaxonNameFull', 'POWO_taxon_name', 'endemic', 'native', 'threatened'), names(interest_existing))]

unknown_existing$AccYear = report_original$AccYear[match(unknown_existing$AccNoFull, report_original$AccNoFull)]

names(unknown_existing) = c('Accession Number','Accession Year', 'Original Taxonomic Name and Authority', 'WCVP Taxonomic Name', 'Endemic Status', 'Native Status', 'Threatened Status')
unknown_existing = unknown_existing[order(unknown_existing$`Accession Year` |> as.numeric(), decreasing = T),]
download_unknown = unknown_existing |>
  download_this(
    output_name = "existing_unknown_provenance",
    output_extension = ".xlsx",
    button_label = "Download exisiting plants with unknown provenance (xlsx)",
    button_type = "default",
    has_icon = TRUE,
    icon = "fa fa-save",
    class = "hvr-sweep-to-left",
    self_contained =  T
  )
```

`r if(no_unknown > 0){'### Unknown provenance'}`

`r if(no_unknown > 0){'In this section we explore the number of unknown provenance accessions in the collection and how this has varied over time.'}`

`r if(report_kind == 'interactive' & no_unknown > 0){"#####   {.tabset}"}`

`r if(report_kind == 'interactive' & no_unknown > 0){"###### Snapshot"}`
```{r  snapshot unknown provenance, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & no_unknown > 0}
snapshot_plot
```

`r if(report_kind == 'interactive' & no_unknown > 0){"###### Trend (Number)"}`
```{r  trend unknown provenance, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & no_unknown > 0}
fig
```

`r if(report_kind == 'interactive' & no_unknown > 0){"###### Trend (Percentage)"}`
```{r  trend percent unknown provenance, fig.fullwidth=TRUE, fig.dim = c(10, 4), eval = report_kind == 'interactive' & no_unknown > 0}
fig2
```

`r if(report_kind == 'interactive' & no_unknown > 0){"##### {-}"}`

`r if(no_unknown > 0){':::: {.blackbox data-latex=""}'}`

`r if(no_unknown > 0){'Note that unique/very rare taxa may suffer from inaccurate naming. These taxa can be downloaded using the button below'}`

`r if(no_unknown > 0){download_unknown}`

`r if(no_unknown > 0){'::::'}`

`r if(no_unknown > 0){'***'}`
